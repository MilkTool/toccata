
(def magic "don't ask")

(def Integer (inline C Integer "(Value *)&(Integer){IntegerType, -1, 1};"))

(defn maybe [v]
  ;; wrap `v` in a Maybe value
  (inline C Maybe "
    return(maybe((List *)0, (Value *)0, arg0));"))
(def nothing (inline C Maybe "(Value *)&(Maybe){MaybeType, -1, 0}"))

(defn cons
  ([x]
   (inline C List "return((Value *)listCons(arg0, empty_list));\n"))
  ([x l]
   (inline C List "
   Value *listVal = (Value *)listCons(arg0, (List *)arg1);
   return(listVal);\n")))

;; Internal protocol for types
(defprotocol Type
  (get-type [value]
    (inline C Integer "
    Value *numVal = integerValue(arg0->type);
    dec_and_free(arg0, 1);
    return(numVal);"))

  (type-name [_]
    (inline C String "
    Value *numVal = integerValue(arg0->type);
    dec_and_free(arg0, 1);
    return(integer_str(numVal));"))

  (type-args [x]
    (inline C Vector "
    Value *typeArgs = ((ReifiedVal *)arg0)->typeArgs;
    incRef(typeArgs, 1);
    dec_and_free(arg0, 1);
    return(typeArgs);"))

  (instance? [t x]
    ;; test whether `x` is of type `t`
    (returns a (instance? Maybe a)))

  (same-type? [x y]
    ;; test whether `x` and `y` are of the 'same' type. 'Sameness' could
    ;; also mean that the types of `x` and `y` are different, but have
    ;; been composed into a union type. (Also referred to as "sum types")
    (returns a (instance? Maybe a)))

  (make-value [_])
  (make-value [_ _])
  (make-value [_ _ _])
  (make-value [_ _ _ _])
  (make-value [_ _ _ _ _])
  (make-value [_ _ _ _ _ _])
  (make-value [_ _ _ _ _ _ _])
  (make-value [_ _ _ _ _ _ _ _])
  (make-value [_ _ _ _ _ _ _ _ _]))

;; Internal protocol for implementing the hash map type
(defprotocol HashMapNode
  (hash-seq [m s])
  (get* [m k v hash shift])
  (assoc* [m k v hash shift])
  (dissoc* [m k hash shift]))

;; The core protocols of Toccata
;; A type does not have to implement all the protocols or even all of the
;; protocol functions of a given protocol. In fact, most won't

;; For types whose values can be composed
(defprotocol Composition
  (zero [x]
    ;; Produce a value with same type as `x` that can be `comp`d with any value
    ;;`y` of the same type to return `y`
    (assert (== (comp* (zero q) (list q))
                (comp* q (list (zero q)))
                q)))
  (comp* [x xs]
    ;; Compose a number of values of the same type to produce a single value of
    ;; that type. `xs` is a list of values of same type as `x`.
    ;; `comp*` must be associative
    (assert (== (comp* p (list (comp* q (list r))))
                (comp* (comp* p (list q)) (list r))))))

(defn comp
  ([x] x)
  ([x & xs]
   (comp* x xs)))

;; For types that contain values. Focus is on container
(defprotocol Container
  (flat-map [x f]
    ;; Apply `f` to the value(s) inside `x` and then flatten one level of nesting.
    ;; `f` must take one value and return a value of a type that's compatible with `x`
    (assert (same-type? p (flat-map p f)))
    (assert (== (flat-map (wrap a p) g)
                (g p)))
    (assert (== (flat-map (wrap a p) (fn [q]
                                       (wrap a q)))
                (wrap a p)))
    (assert (== (flat-map (flat-map (wrap a p) g) h)
                (flat-map (wrap a p) (fn [q]
                                       (flat-map (g q) h))))))

  (flatten [x]
    ;; Given a value `x` that contains value(s) of the same type as `x`, remove
    ;; one layer of wrapping.
    (assert (same-type? p (flatten p)))
    (assert (== p (flatten (wrap p p))))

    ;; the default way of flattening. Requires `flat-map` to be implemented
    ;; for `x`
    (flat-map x (fn [y] y)))

  (extend [x f]
    ;; Create a new value of same type as `x` that will apply `f` to
    ;; values `extract`ed from `x`.
    (assert (same-type? p (extend p f)))
    (assert (== (extend p extract) p))
    (assert (== (extract (extend p g)) (g p)))
    (assert (== (extend (extend p g) h)
                (extend p (fn [q]
                            (h (extend q g)))))))

  (extract [x]
    ;; Pull a value out of `x`
    )

  (duplicate [x]
    ;; Add a layer of wrapping to `x`
    (assert (same-type? p (duplicate p)))
    (assert (== p (extract (duplicate p)))))

  (wrap [x v]
    ;; Create a new value of same type as `x` that contains the value `y`
    (assert (same-type? p (wrap p q))))

  (apply* [xf xs]
    ;; Apply a function(s) in `xf` to the value(s) in each of the `xs`,
    ;; wrapping the result in the same type as `xf`.
    (assert (== (apply* (wrap p g) (list q))
                (map q g))))

  (map [x f]
    ;; Create a new value of same type as `x` that contains the results of
    ;; apply `f` to all the values contained in `x`
    (assert (same-type? x (map x f)))
    (assert (== (map (map p g) h)
                (map p (comp h g)))))

  (send* [x f-and-ys]
    ;; Cause the value(s) in `x` to be updated with the results of applying the
    ;; the first item of `f-and-ys` to each of the value(s) in `x` and the rest
    ;; of `f-and-ys`. Should only be implemented for types that support in place
    ;; updating.
    ))

(defn send [v f & args]
  ;; send a function `f` to a value `v`. `f` will be applied to the contents of
  ;; `v` and the list of values in `args`
  (send* v (cons f args)))

;; For types that contain values. Focus is on the contained values.
;; No sense of ordering for contents
(defprotocol Collection
  (empty? [coll]
    ;; Test whether `coll` contains any values
    (returns a (instance? Maybe a)))

  (count [coll]
    ;; Count the number of values in `coll`
    (returns y (instance? Integer y)))

  (empty [coll]
    ;; Create an empty collection of same type as `coll`
    (assert (same-type? coll (empty coll)))
    (assert (empty? (empty p))))

  (conj [coll x]
    ;; Add `x` to `coll`
    (assert (same-type? p (conj p q))))

  (fold [coll f]
    ;; Compose all the values in `coll` to a single value using `f`
    ;; May be parallelized. `f` must have arities for 0, 1 and 2 arguments
    (assert (and (arity 0 f)
                 (arity 1 f)
                 (arity 2 f))))

  (filter [coll f]
    ;; Create a new collection of same type as `coll` with only the values
    ;; for which `f` does not return `nothin`.
    (assert (same-type? p (filter p g)))))

;; Container types that have some sense of ordering of their contents
(defprotocol Seqable
  (seq [coll]
    ;; Create a list of the contents
    (returns a (instance? List a)))

  (vec [coll]
    ;; Create a vector of the contents
    (returns a (instance? Vector a)))

  (first [coll]
    ;; Return the first element in the `coll` (wrapped in a `Maybe`) if `coll`
    ;; is not empty. Returns 'nothing', if `coll` is empty.
    (returns a (instance? Maybe a)))

  (rest [coll]
    ;; Returns a new collection with all but the first value of `coll`
    )

  (last [coll]
    ;; Return the last element in the `coll` (wrapped in a `Maybe`) if `coll`
    ;; is not empty. Returns 'nothing', if `coll` is empty.
    (returns a (instance? Maybe a))
    )

  (butlast [coll]
    ;; Returns a new collection with all but the last value of `coll`
    )

  (reduce [coll x f]
    ;; Produce a single value of same type as `x` by calling `f` repeatedly.
    ;; For example, if `coll` contains `p` and `q`, then: `(f (f x p) q)`
    ;; Will be done sequentially.
    (assert (arity 2 f)))

  (reverse [coll]
    ;; Create a new collection of same type as `coll` with the contents
    ;; in reverse order
    (assert (== p (reverse (reverse p)))))

  (to-str [coll]
    ;; Builds a string from the string representation of all the values in `coll`
    (returns a (instance? String a))))

(defn second [coll]
  ;; get the second element from the sequable `coll`
  (first (rest coll)))

;; For collections whose contents can be indexed by integers
(defprotocol Indexed
  (nth [coll n]
    ;; Retrieve the `n`th value from `coll`, wrapped in a Maybe, if there are
    ;; enough values in `coll`. Otherwise, returns `nothing`.
    (assert (instance? Integer n))
    (returns a (instance? Maybe a)))

  (store [coll n v]
    ;; Create a new copy of `coll` (wrapped in a Maybe)  with `v` at index `n`
    ;; if `coll` is at least size of `n` - 1. Otherwise, return `nothing`.
    (assert (instance? Integer n))
    (returns a (instance? Maybe a))))

;; For types that emulate a key/value store
(defprotocol Associative
  (assoc [m k v]
    ;; Create a new copy of `m` that adds an association of `k` with `v`
    )

  (get [m k]
    ;; Retrieve the value associated with `k` in `m`, wrapped in a `Maybe` if it exists.
    ;; Otherwise, return `nothing`
    (returns a (instance? Maybe a)))

  (get [m k not-found]
    ;; Retrieve the value associated with `k` in `m` if it exists.
    ;; Otherwise, return `not-found`
    )

  (keys [m]
    ;; Get a list of the keys from `m`
    (returns a (instance? List a)))

  (vals [m]
    ;; Get a list of the vals from `m`
    (returns a (instance? List a)))

  (dissoc [m k]
    ;; Create a new copy of `m` without the association of `k` with `v`
    ))

;; For types whose values may be invoked like functions
(defprotocol Function
  (invoke [_])
  (invoke [_ _])
  (invoke [_ _ _])
  (invoke [_ _ _ _])
  (invoke [_ _ _ _ _])
  (invoke [_ _ _ _ _ _])
  (invoke [_ _ _ _ _ _ _])
  (invoke [_ _ _ _ _ _ _ _])
  (invoke [_ _ _ _ _ _ _ _ _]))

;; For types that have some notion of equality between their values
(defprotocol Eq
  (=* [x y]
    ;; Compare two values for equality
    (returns a (instance? Maybe a))))

;; For types that have some notion of order of their values
(defprotocol Ord
  (<* [x y]
    ;; Compare two values for order
    (returns a (instance? Maybe a))))

(defn <
  ([x y] (<* x y))
  ([v & vs]
   (or (and (empty? vs)
            (maybe v))
       (let [[y] vs]
         (apply* (maybe (fn [x _] x))
                 (list (<* v y)
                       (apply* < (list vs))))))))

;; For types whose values can be hashed to an integer
(defprotocol Hashable
  (sha1 [x]
    ;; Compute the SHA1 hash of `x`
    (returns a (instance? Integer a))))

;; For types whose values can be converted to human-readable strings
(defprotocol Stringable
  (string-list [x]
    ;; Create a list of strings of that comprise the representation of `x`
    (returns a (instance List a))))

(def empty-list (inline C List "(Value *)&(List){ListType,-1,0,0,0}"))

;; This is the declaration of the 'list' function. Calls to 'list' are inlined by the compiler
(defn list [& l]
  ;; construct a list of values from the arguments
  l)

(def empty-vector (inline C Vector "(Value *)&(Vector){VectorType,-1,0,5,0,0}"))

;; This is the declaration of the 'vector' function. Calls to 'vector' are inlined by the compiler
(defn vector [& l]
  ;; construct a vector of values from the arguments
  (vec l))


(extend-type Integer
  Type
  (instance? [type val] (inline C Maybe "return(checkInstance(arg0, arg1));"))
  (type-args [n] (list n))
  (type-name [_] "Integer")
  
  Stringable
  (string-list [n] (inline C "return((Value *)listCons(integer_str(arg0), empty_list));\n"))

  Eq
  (=* [x y] (inline C Maybe "return(integer_EQ(arg0, arg1));"))

  Ord
  (<* [x y] (inline C Maybe "return(integerLT(arg0, arg1));"))

  Hashable
  (sha1 [x] (inline C Integer "return(integerSha1(arg0));")))

(extend-type String
  Type
  (type-name [_] "String")
  
  Stringable
  (string-list [s] (list s))

  Eq
  (=* [x y] (inline C "return(strEQ(arg0, arg1));"))
  )

(extend-type Maybe
  Stringable
  (string-list [mv]
    (extract (or (map mv (fn [v]
                           (comp (list "<maybe ")
                                 (string-list v)
                                 (list ">"))))
                 (maybe (list "<nothing>")))))

  Type
  (type-name [_] "Maybe")
  
  Eq
  (=* [x y] (inline C Maybe "return(maybeEQ(arg0, arg1));"))

  Container
  (extract [mv]
    (inline C "return(maybeExtract(arg0));"))

  (wrap [_ mv]
    (maybe mv))

  (apply* [mv args]
    (inline C Maybe "return(maybeApply(arg0, arg1));"))

  (flat-map [mv f]
    (and mv (f (extract mv)))))

(defn interpose [coll sep]
  (rest (flat-map coll (fn [x] (list sep x)))))

(defn list-map [l f]
  (inline C List "return(listMap(arg0, arg1));"))

(defn list-concat [l1]
  (inline C List "return(listConcat(arg0));"))

(defn list-reduce [l result f]
  (or (flat-map (first l)
                (fn [h]
                  (list-reduce (rest l) (f result h) f)))
      (maybe result)))

(extend-type List
  Type
  (type-name [_] "List")

  Eq
  (=* [x y] (inline C List "return(listEQ(arg0, arg1));"))

  Composition
  (comp* [l ls]
    (list-concat (cons l (map ls seq))))

  Container
  (map [l f]
    (list-map l f))

  (flat-map [l mf]
    (list-concat (list-map l mf)))
  
  Seqable
  (reduce [l result f]
    (extract (list-reduce l result f)))

  (first [l]
    (inline C "return(car(arg0));"))

  (rest [l]
    (inline C "return(cdr(arg0));"))
  )

(defn fn-apply [x args]
  (assert (instance? Function x))
  (inline C "return(fnApply(arg0, arg1));"))

(defn pr* [str]
  ;; Send a string to the current output stream
  (assert (instance? String str))
  (inline C Integer "return(pr_STAR(arg0));"))

(defn list*
  ([]
   (returns x (instance? List x))
   empty-list)
  ([arg]
   (assert (instance? List arg))
   (returns x (instance? List x))
   arg)
  ([arg & args]
   (returns x (instance? List x))
   (cons arg (fn-apply list* args))))

(defn abort []
  (inline C Maybe
   "abort();
    return(nothing);"))

(defn print [& vs]
  (map (flat-map (interpose vs " ") string-list) pr*))

(defn println [& vs]
  (map (flat-map (interpose vs " ") string-list) pr*)
  (pr* "\n"))

(defn =
  ([v] (maybe v))
  ([x y] (=* x y)))

(defn add-numbers [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal + ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn subtract-numbers [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal - ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn mult-numbers [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal * ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn rem [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal % ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn +
  ([] 0)
  ([x y]
   (add-numbers x y))
  ([& xs]
   (reduce xs 0 add-numbers)))

(defn inc [x]
  ;; Increment an integer value by 1
  (+ x 1))

(defn -
  ([] 0)
  ([x] x)
  ([x & xs] (reduce xs x subtract-numbers)))

(defn dec [x]
  ;; Deccrement an integer value by 1
  (subtract-numbers x 1))

(defn *
  ([] 1)
  ([x y] (mult-numbers x y))
  ([& xs] (reduce xs 1 mult-numbers)))

(defn bit-and [x y]
  ;; Bitwise AND two integer values
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "return(bitAnd(arg0, arg1));"))

(defn bit-or [x y]
  ;; Bitwise OR two integer values
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "return(bitOr(arg0, arg1));"))

;; (defn partial [f & args]
;;   ;; paritally apply `f` to `args` creating a new function that expects more arguments
;;   (fn [& more-args]
;;     (apply f (comp args more-args))))

(extend-type Function
  Container
  (apply* [f args]
    ;; Remember, the last element of 'args' must be a list
    ;; everything up to that must be prepended to it
    (fn-apply f (fn-apply list* args))))
