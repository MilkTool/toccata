
(def magic "don't ask")

(def Integer (inline C Integer "(Value *)&(Integer){IntegerType, -1, 1};"))
(def String (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringType};"))
(def List (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def Maybe (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def Symbol (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def Vector (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def Function (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def HashMap (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashMapType};"))
(def Promise (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def Future (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))

(defn maybe [v]
  ;; wrap `v` in a Maybe value
  (inline C Maybe "
    return(maybe((List *)0, (Value *)0, arg0));"))

(def nothing (inline C Maybe "(Value *)&(Maybe){MaybeType, -1, 0}"))

(defn cons
  ([x]
   (inline C List "return((Value *)listCons(arg0, empty_list));\n"))
  ([x l]
   (inline C List "
   Value *listVal = (Value *)listCons(arg0, (List *)arg1);
   return(listVal);\n")))

;; Internal protocol for types
(defprotocol Type
  (has-field [_ field] nothing)

  (get-type [value]
    (inline C Integer "
    Value *numVal = integerValue(arg0->type);
    dec_and_free(arg0, 1);
    return(numVal);"))

  (type-name [_]
    (inline C String "
    Value *numVal = integerValue(arg0->type);
    dec_and_free(arg0, 1);
    return(integer_str(numVal));"))

  (type-args [x]
    (inline C Vector "
    if (arg0->type < TypeCount) {
       fprintf(stderr, \"'type-args' undefined for %s (%\" PRId64 \")\\n\",
               extractStr(type_name(empty_list, arg0)), arg0->type);
       abort();
    }
    Value *typeArgs = ((ReifiedVal *)arg0)->typeArgs;
    incRef(typeArgs, 1);
    dec_and_free(arg0, 1);
    return(typeArgs);"))

  (instance? [t x]
    ;; test whether `x` is of type `t`
    (returns a (instance? Maybe a)))

  (same-type? [x y]
    ;; test whether `x` and `y` are of the 'same' type. 'Sameness' could
    ;; also mean that the types of `x` and `y` are different, but have
    ;; been composed into a union type. (Also referred to as "sum types")
    (returns a (instance? Maybe a))))

;; Internal protocol for implementing the hash map type
(defprotocol HashMapNode
  (hash-seq [m s])
  (get* [m k v hash shift])
  (assoc* [m k v hash shift])
  (dissoc* [m k hash shift]))

;; The core protocols of Toccata
;; A type does not have to implement all the protocols or even all of the
;; protocol functions of a given protocol. In fact, most won't

;; For types whose values can be composed
(defprotocol Composition
  (zero [x]
    ;; Produce a value with same type as `x` that can be `comp`d with any value
    ;;`y` of the same type to return `y`
    (assert (== (comp* (zero q) (list q))
                (comp* q (list (zero q)))
                q)))
  (comp* [x xs]
    ;; Compose a number of values of the same type to produce a single value of
    ;; that type. `xs` is a list of values of same type as `x`.
    ;; `comp*` must be associative
    (assert (== (comp* p (list (comp* q (list r))))
                (comp* (comp* p (list q)) (list r))))))

(defn comp
  ([x] x)
  ([x & xs]
   (comp* x xs)))

;; For types that contain values. Focus is on container
(defprotocol Container
  (flat-map [x f]
    ;; Apply `f` to the value(s) inside `x` and then flatten one level of nesting.
    ;; `f` must take one value and return a value of a type that's compatible with `x`
    (assert (same-type? p (flat-map p f)))
    (assert (== (flat-map (wrap a p) g)
                (g p)))
    (assert (== (flat-map (wrap a p) (fn [q]
                                       (wrap a q)))
                (wrap a p)))
    (assert (== (flat-map (flat-map (wrap a p) g) h)
                (flat-map (wrap a p) (fn [q]
                                       (flat-map (g q) h))))))

  (flatten [x]
    ;; Given a value `x` that contains value(s) of the same type as `x`, remove
    ;; one layer of wrapping.
    (assert (same-type? p (flatten p)))
    (assert (== p (flatten (wrap p p))))

    ;; the default way of flattening. Requires `flat-map` to be implemented
    ;; for `x`
    (flat-map x (fn [y] y)))

  (extend [x f]
    ;; Create a new value of same type as `x` that will apply `f` to
    ;; values `extract`ed from `x`.
    (assert (same-type? p (extend p f)))
    (assert (== (extend p extract) p))
    (assert (== (extract (extend p g)) (g p)))
    (assert (== (extend (extend p g) h)
                (extend p (fn [q]
                            (h (extend q g)))))))

  (extract [x]
    ;; Pull a value out of `x`
    )

  (duplicate [x]
    ;; Add a layer of wrapping to `x`
    (assert (same-type? p (duplicate p)))
    (assert (== p (extract (duplicate p)))))

  (wrap [x v]
    ;; Create a new value of same type as `x` that contains the value `y`
    (assert (same-type? p (wrap p q))))

  (apply* [xf xs]
    ;; Apply a function(s) in `xf` to the value(s) in each of the `xs`,
    ;; wrapping the result in the same type as `xf`.
    (assert (== (apply* (wrap p g) (list q))
                (map q g))))

  (map [x f]
    ;; Create a new value of same type as `x` that contains the results of
    ;; apply `f` to all the values contained in `x`
    (assert (same-type? x (map x f)))
    (assert (== (map (map p g) h)
                (map p (comp h g)))))

  (send* [x f-and-ys]
    ;; Cause the value(s) in `x` to be updated with the results of applying the
    ;; the first item of `f-and-ys` to each of the value(s) in `x` and the rest
    ;; of `f-and-ys`. Should only be implemented for types that support in place
    ;; updating.
    ))

(defn send [v f & args]
  ;; send a function `f` to a value `v`. `f` will be applied to the contents of
  ;; `v` and the list of values in `args`
  (send* v (cons f args)))

;; For types that contain values. Focus is on the contained values.
;; No sense of ordering for contents
(defprotocol Collection
  (empty? [coll]
    ;; Test whether `coll` contains any values
    (returns a (instance? Maybe a)))

  (count [coll]
    ;; Count the number of values in `coll`
    (returns y (instance? Integer y)))

  (empty [coll]
    ;; Create an empty collection of same type as `coll`
    (assert (same-type? coll (empty coll)))
    (assert (empty? (empty p))))

  (conj [coll x]
    ;; Add `x` to `coll`
    (assert (same-type? p (conj p q))))

  (fold [coll f]
    ;; Compose all the values in `coll` to a single value using `f`
    ;; May be parallelized. `f` must have arities for 0, 1 and 2 arguments
    (assert (and (arity 0 f)
                 (arity 1 f)
                 (arity 2 f))))

  (filter [coll f]
    ;; Create a new collection of same type as `coll` with only the values
    ;; for which `f` does not return `nothin`.
    (assert (same-type? p (filter p g)))))

;; Container types that have some sense of ordering of their contents
(defprotocol Seqable
  (seq [coll]
    ;; Create a list of the contents
    (returns a (instance? List a)))

  (vec [coll]
    ;; Create a vector of the contents
    (returns a (instance? Vector a)))

  (first [coll]
    ;; Return the first element in the `coll` (wrapped in a `Maybe`) if `coll`
    ;; is not empty. Returns 'nothing', if `coll` is empty.
    (returns a (instance? Maybe a)))

  (rest [coll]
    ;; Returns a new collection with all but the first value of `coll`
    )

  (last [coll]
    ;; Return the last element in the `coll` (wrapped in a `Maybe`) if `coll`
    ;; is not empty. Returns 'nothing', if `coll` is empty.
    (returns a (instance? Maybe a))
    )

  (butlast [coll]
    ;; Returns a new collection with all but the last value of `coll`
    )

  (reduce [coll x f]
    ;; Produce a single value of same type as `x` by calling `f` repeatedly.
    ;; For example, if `coll` contains `p` and `q`, then: `(f (f x p) q)`
    ;; Will be done sequentially.
    (assert (arity 2 f)))

  (reverse [coll]
    ;; Create a new collection of same type as `coll` with the contents
    ;; in reverse order
    (assert (== p (reverse (reverse p)))))

  (to-str [coll]
    ;; Builds a string from the string representation of all the values in `coll`
    (returns a (instance? String a))))

(defn second [coll]
  ;; get the second element from the sequable `coll`
  (first (rest coll)))

;; For collections whose contents can be indexed by integers
(defprotocol Indexed
  (nth [coll n]
    ;; Retrieve the `n`th value from `coll`, wrapped in a Maybe, if there are
    ;; enough values in `coll`. Otherwise, returns `nothing`.
    (assert (instance? Integer n))
    (returns a (instance? Maybe a)))

  (store [coll n v]
    ;; Create a new copy of `coll` (wrapped in a Maybe)  with `v` at index `n`
    ;; if `coll` is at least size of `n` - 1. Otherwise, return `nothing`.
    (assert (instance? Integer n))
    (returns a (instance? Maybe a))))

;; For types that emulate a key/value store
(defprotocol Associative
  (assoc [m k v]
    ;; Create a new copy of `m` that adds an association of `k` with `v`
    )

  (get [m k]
    ;; Retrieve the value associated with `k` in `m`, wrapped in a `Maybe` if it exists.
    ;; Otherwise, return `nothing`
    (returns a (instance? Maybe a)))

  (get [m k not-found]
    ;; Retrieve the value associated with `k` in `m` if it exists.
    ;; Otherwise, return `not-found`
    )

  (keys [m]
    ;; Get a list of the keys from `m`
    (returns a (instance? List a)))

  (vals [m]
    ;; Get a list of the vals from `m`
    (returns a (instance? List a)))

  (dissoc [m k]
    ;; Create a new copy of `m` without the association of `k` with `v`
    ))

;; For types whose values may be invoked like functions
(defprotocol Function
  (invoke [_])
  (invoke [_ _])
  (invoke [_ _ _])
  (invoke [_ _ _ _])
  (invoke [_ _ _ _ _])
  (invoke [_ _ _ _ _ _])
  (invoke [_ _ _ _ _ _ _])
  (invoke [_ _ _ _ _ _ _ _])
  (invoke [_ _ _ _ _ _ _ _ _]))

;; For types that have some notion of equality between their values
(defprotocol Eq
  (=* [x y]
    ;; Compare two values for equality
    (returns a (instance? Maybe a))))

;; For types that have some notion of order of their values
(defprotocol Ord
  (<* [x y]
    ;; Compare two values for order
    (returns a (instance? Maybe a))))

;; For types whose values can be hashed to an integer
(defprotocol Hashable
  (sha1 [x]
    ;; Compute the SHA1 hash of `x`
    (returns a (instance? Integer a))))

;; For types whose values can be converted to human-readable strings
(defprotocol Stringable
  (string-list [x]
    ;; Create a list of strings of that comprise the representation of `x`
    (returns a (instance List a))))

(defn new-type-value [reified-template type-args]
  (inline C "
  ReifiedVal *template = (ReifiedVal *)arg0;
  ReifiedVal *rv = malloc_reified(template->implCount);
  int rvSize = sizeof(ReifiedVal) + sizeof(Function *) * template->implCount;
  memcpy(rv, template, rvSize);
  __atomic_store(&rv->refs, &refsInit, __ATOMIC_RELAXED);
  rv->typeArgs = arg1;
  return((Value *)rv);"))

(defn make-value [reified-template type-args]
  (inline C "
  ReifiedVal *template = (ReifiedVal *)arg0;
  ReifiedVal *rv = malloc_reified(template->implCount);
  int rvSize = sizeof(ReifiedVal) + sizeof(Function *) * template->implCount;
  memcpy(rv, template, rvSize);
  __atomic_store(&rv->refs, &refsInit, __ATOMIC_RELAXED);
  rv->typeArgs = arg1;
  dec_and_free(arg0, 1);
  return((Value *)rv);"))

(defn identical [x y]
  (inline C "
  if (arg0 == arg1) {
    dec_and_free(arg1, 1);
    return(maybe((List *)0, (Value *)0, arg0));
  } else {
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(nothing);
  }"))

(def empty-list (inline C List "(Value *)&(List){ListType,-1,0,0,0}"))

(def empty-vector (inline C Vector "(Value *)&(Vector){VectorType,-1,0,5,0,0}"))

(extend-type Integer
  Eq
  (=* [x y] (inline C Maybe "return(integer_EQ(arg0, arg1));")))

(defn list-count [l]
  (inline C Integer "
   Value *numVal = integerValue(((List *)arg0)->len);
   dec_and_free(arg0, 1);
   return(numVal);"))

(defn mutate-vect-conj [v x]
  (assert (instance? Vector v))
  (inline C "return((Value *)mutateVectConj((Vector *)arg0, arg1));"))

(extend-type Maybe
  Container
  (extract [mv]
    (inline C "return(maybeExtract(arg0));")))

(extend-type List
  Seqable
  (first [l]
    (inline C "return(car(arg0));"))

  (rest [l]
    (inline C "return(cdr(arg0));")))

(defn list-reduce [l result f]
  (assert (instance? List l))
  (or (flat-map (first l)
                (fn [h]
                  (list-reduce (rest l) (f result h) f)))
      (maybe result)))

(defn list-map [l f]
  (inline C List "return(listMap(arg0, arg1));"))

(defn list-concat [l1]
  (inline C List "return(listConcat(arg0));"))

(extend-type List
  Container
  (flat-map [l mf]
    (list-concat (list-map l mf)))

  Seqable
  (reduce [l result f]
    (extract (list-reduce l result f))))

(defn add-numbers [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal + ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn +
  ([] 0)
  ([x y]
   (add-numbers x y))
  ([& xs]
   (reduce xs 0 add-numbers)))

(defn str-malloc [len]
  (assert (instance? Integer len))
  (inline C String "
  String *strVal = malloc_string(((Integer *)arg0)->numVal);
  strVal->len = 0;
  strVal->buffer[0] = 0;
  dec_and_free(arg0, 1);
  return((Value *)strVal);\n"))

(defn str-append [dest src]
  (assert (instance? String dest))
  (inline C Maybe "
  String *s1 = (String *)arg0;
  if (arg1->type == StringType) {
    String *s2 = (String *)arg1;
    strncat(s1->buffer, s2->buffer, s2->len);
    s1->len += s2->len;
  } else if (arg1->type == SubStringType) {
    SubString *s2 = (SubString *)arg1;
    strncat(s1->buffer, s2->buffer, s2->len);
    s1->len += s2->len;
  }
  dec_and_free(arg0, 1);
  dec_and_free(arg1, 1);
  return(nothing);"))

(extend-type List
  Collection
  (empty? [l]
    (and (=* 0 (count l))
         (maybe empty-list)))

  (count [l] (list-count l))

  Seqable
  (vec [l]
    (reduce l empty-vector mutate-vect-conj))

  (to-str [coll]
    (let [ss-list (cons "" (flat-map coll string-list))
          new-len (reduce ss-list 0 (fn [len s] (+ len (count s))))
          new-str (str-malloc new-len)]
      (map ss-list (fn [s]
                     (str-append new-str s)))
      new-str)))

(defn fn-apply [x args]
  (assert (instance? Function x))
  (inline C "return(fnApply(arg0, arg1));"))

(defn list*
  ([]
   (returns x (instance? List x))
   empty-list)
  ([arg]
   (assert (instance? List arg))
   (returns x (instance? List x))
   arg)
  ([arg & args]
   (returns x (instance? List x))
   (cons arg (fn-apply list* args))))

(extend-type Function
  Stringable
  (string-list [_] (list "<Function>"))

  Container
  (apply* [f args]
    ;; Remember, the last element of 'args' must be a list
    ;; everything up to that must be prepended to it
    (fn-apply f (fn-apply list* args))))

(defn pr* [str]
  ;; Send a string to the current output stream
  (assert (instance? String str))
  (inline C Integer "return(pr_STAR(arg0));"))

(defn abort []
  (inline C Maybe
   "abort();
    return(nothing);"))

(defn interpose [coll sep]
  (rest (flat-map coll (fn [x] (list sep x)))))

(defn print [& vs]
  (map (flat-map (interpose vs " ") string-list) pr*))

(defn println [& vs]
  (map (flat-map (interpose vs " ") string-list) pr*)
  (pr* "\n"))

;; This is the declaration of the 'list' function. Calls to 'list' are inlined by the compiler
(defn list [& l]
  ;; construct a list of values from the arguments
  l)

;; This is the declaration of the 'vector' function. Calls to 'vector' are inlined by the compiler
(defn vector [& l]
  ;; construct a vector of values from the arguments
  (vec l))

(defn str [& vs]
  ;; Converts the list of arguments into a single string of characters. Every argument
  ;; must implment the `string-list` protocol function.
  (assert (returns x (instance? String s)))
  (to-str vs))

(defn <
  ([x y] (<* x y))
  ([v & vs]
   (or (and (empty? vs)
            (maybe v))
       (let [[y] vs]
         (apply* (maybe (fn [x _] x))
                 (list (<* v y)
                       (apply* < (list vs))))))))

(defn <=
  ([x] (maybe x))
  ([x y] (or (<* x y) (=* x y)))
  ([x y & ys]
   (and (or (<* x y) (=* x y))
        (apply <= y ys))))

(defn =
  ([v] (maybe v))
  ([x y] (=* x y))
  ([x y & ys]
     (and (=* x y)
          (apply = y ys))))

(defn subtract-numbers [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal - ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn mult-numbers [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal * ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn rem [x y]
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "
    Value *numVal = integerValue(((Integer *)arg0)->numVal % ((Integer *)arg1)->numVal);
    dec_and_free(arg0, 1);
    dec_and_free(arg1, 1);
    return(numVal);"))

(defn inc [x]
  (assert (instance? Integer x))
  ;; Increment an integer value by 1
  (+ x 1))

(defn -
  ([] 0)
  ([x] x)
  ([x & xs] (reduce xs x subtract-numbers)))

(defn dec [x]
  (assert (instance? Integer x))
  ;; Deccrement an integer value by 1
  (subtract-numbers x 1))

(defn *
  ([] 1)
  ([x y] (mult-numbers x y))
  ([& xs] (reduce xs 1 mult-numbers)))

(defn bit-and [x y]
  ;; Bitwise AND two integer values
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "return(bitAnd(arg0, arg1));"))

(defn bit-or [x y]
  ;; Bitwise OR two integer values
  (assert (instance Integer x))
  (assert (instance Integer y))
  (inline C Integer "return(bitOr(arg0, arg1));"))

(extend-type Integer
  Type
  (instance? [type val] (inline C Maybe "return(checkInstance(arg0, arg1));"))
  (type-args [n] (list n))
  (type-name [_] "Integer")

  Stringable
  (string-list [n] (inline C "return((Value *)listCons(integer_str(arg0), empty_list));\n"))

  Ord
  (<* [x y] (inline C Maybe "return(integerLT(arg0, arg1));"))

  Hashable
  (sha1 [x] (inline C Integer "return(integerSha1(arg0));")))

(defn char [n]
  (assert (instance? Integer n))
  (inline C String "
  String *strVal = malloc_string(2);
  strVal->len = 1;
  strVal->buffer[0] = ((Integer *)arg0)->numVal;
  strVal->buffer[1] = 0;
  return((Value *)strVal);\n"))

(defn char-code [c]
  (assert (instance? String c))
  (inline C Integer "
   if (arg0->type == StringType) {
     String *s = (String *)arg0;
     Value *numVal = integerValue((unsigned char)s->buffer[0]);
     dec_and_free(arg0, 1);
     return(numVal);
   } else if (arg0->type == SubStringType) {
     SubString *s = (SubString *)arg0;
     Value *numVal = integerValue((unsigned char)s->buffer[0]);
     dec_and_free(arg0, 1);
     return(numVal);
   } else
     abort();"))

(defn escape-chars [s]
  (assert (instance? String s))
  (inline C String "return(escapeChars(arg0));"))

(defn subs
  ([src index]
   (assert (instance? String src))
   (assert (instance? Integer index))
   (inline C String "return(subs2(arg0, arg1));"))
  ([src index length]
   (assert (instance? String src))
   (assert (instance? Integer index))
   (assert (instance? Integer length))
   (inline C String "return(subs3(arg0, arg1, arg2));")))

(defn symbol [sym-str]
  (assert (instance? String sym-str))
  (inline C Symbol "return(symbol(arg0));"))

(extend-type String
  Type
  (type-name [_] "String")
  (type-args [s] (list s))

  Stringable
  (string-list [s] (list s))

  Composition
  (zero [_] "")

  (comp* [s ss] (to-str (cons s ss)))

  Collection
  (count [s]
    (inline C Integer "return(strCount(arg0));"))

  (empty? [coll]
    (= 0 (count coll)))

  (empty [coll]
    "")

  Seqable
  (seq [coll]
    (inline C List "return(strSeq(arg0));"))

  (vec [coll]
    (inline C List "return(strVec(arg0));"))

  (first [s]
    (map (< 0 (count s))
         (fn [_]
           (subs s 0 1))))

  (rest [s]
    (subs s 1))

  (last [s]
    (let [n (count s)]
      (map (< 0 n)
           (fn [_]
             (subs s (dec n))))))

  (butlast [s]
    (subs s 0 (dec (count s))))

  (reduce [s x f]
    (reduce (seq s) x f))

  (reverse [s]
    (to-str (reverse (seq s))))

  (to-str [s]
    s)

  Eq
  (=* [x y] (inline C Maybe "return(strEQ(arg0, arg1));"))

  Indexed
  (nth [s n]
    (map (< n (count s))
         (fn [_]
           (subs s n 1))))

  Ord
  (<* [x y] (inline C Maybe "return(strLT(arg0, arg1));"))

  Hashable
  (sha1 [s]
    (inline C Integer "return(strSha1(arg0));"))
  )


(extend-type Symbol
  Type
  (type-name [_] "Symbol")
  (type-args [s] (list s))

  Stringable
  (string-list [v] (inline C List "
  Value *strVal = stringValue(((SubString *)arg0)->buffer);
  dec_and_free(arg0, 1);
  return((Value *)listCons(strVal, empty_list));"))

  Eq
  (=* [x y] (inline C Maybe "return(symEQ(arg0, arg1));"))

  Ord
  (<* [x y] (inline C Maybe "return(symLT(arg0, arg1));"))

  Hashable
  (sha1 [s]
    (inline C "return(symbolSha1(arg0));")))


(extend-type Maybe
  Type
  (type-args [v]
    (extract (or (map v list)
                 (maybe empty-list))))

  (type-name [_] "Maybe")

  Stringable
  (string-list [mv]
    (extract (or (map mv (fn [v]
                           (comp (list "<maybe ")
                                 (string-list v)
                                 (list ">"))))
                 (maybe (list "<nothing>")))))

  Function
  (invoke [m t f] (inline C "return(maybeInvoke(arg0, arg1, arg2));"))

  Eq
  (=* [x y] (inline C Maybe "return(maybeEQ(arg0, arg1));"))

  Container
  (extract [mv]
    (inline C "return(maybeExtract(arg0));"))

  (map [mv args]
    (inline C Maybe "return(maybeMap(arg0, arg1));"))

  (wrap [_ mv]
    (maybe mv))

  (apply* [mv args]
    (inline C Maybe "return(maybeApply(arg0, arg1));"))

  (flat-map [mv f]
    (and mv (f (extract mv))))

  Associative
  (get [m _]
    m)

  (get [m _ not-found]
    (or m (maybe not-found))))

(defn splitter [l n]
  (or (empty? l)
      (and (< 0 n)
           (apply-to (fn [head [prefix suffix]]
                       (list (cons head prefix) suffix))
                     (first l)
                     (splitter (rest l) (dec n))))
      (maybe (list empty-list l))))

(defn split [l n]
  (assert (instance? List l))
  ;; Split a list `l` at the `n`th element
  (extract (splitter l n)))

(defn dropper [coll n]
  (or (empty? coll)
      (and (< 0 n)
           (dropper (rest coll) (dec n)))
      (maybe coll)))

(defn drop [coll n]
  (assert (instance? List l))
  ;; Drop `n` elements from the front of list `l`
  (extract (dropper coll n)))

(defn some [coll f]
  (and (< 0 (count coll))
       (or (flat-map (first coll) f)
           (some (rest coll) f))))

(extend-type List
  Type
  (type-name [_] "List")
  (type-args [l] l)

  Stringable
  (string-list [l]
    (comp (list "(")
          (flat-map (interpose l ", ") string-list)
          (list ")")))

  Eq
  (=* [x y] (inline C List "return(listEQ(arg0, arg1));"))

  Composition
  (zero [_] empty-list)

  (comp* [l ls]
    (list-concat (cons l (map ls seq))))

  Container
  (map [l f]
    (list-map l f))

  (wrap [x v]
    (list v))

  (flatten [ls]
    (list-concat ls))

  Collection
  (empty [_] empty-list)

  (conj [l v] (cons v l))

  (filter [coll f]
    (inline C "return(listFilter(arg0, arg1));"))

  Seqable
  (seq [l] l)

  (last [coll]
    (nth coll (dec (count coll))))

  (butlast [coll]
    (extract (flat-map (splitter coll (dec (count coll)))
                       first)))
  (reverse [l]
    (inline C List "return((Value *)reverseList((List *)arg0));"))

  Indexed
  (nth [coll n]
    (or (and (= n 0) (first coll))
        (and (< 0 n) (nth (rest coll) (dec n))))))

(defn vec= [x y n]
  (or (= 0 n)
      (let [n (dec n)]
        (and (= (get x n) (get y n))
             (vec= x y n)))))

(defn vect-count [v]
  (inline C Integer "
   Value *result = integerValue(((Vector *)arg0)->count);
   dec_and_free(arg0, 1);
   return(result);"))

(defn subvec* [v curr-index max-index result]
  (or (and (<= curr-index max-index)
           (flat-map (get v curr-index)
                     (fn [x]
                       (subvec* v (inc curr-index) max-index (mutate-vect-conj result x)))))
      (maybe result)))

(defn subvec
  ([v start]
   (assert (instance? Integer start))
   (extract (subvec* v start (count v) empty-vector)))
  ([v start len]
   (assert (instance? Integer start))
   (assert (instance? Integer len))
   (extract (subvec* v start (dec (+ start len)) empty-vector))))

(defn vect-reduce [v n result f]
  (or (flat-map (get v n)
                (fn [x]
                  (vect-reduce v (inc n) (f result x) f)))
      (maybe result)))

(extend-type Vector
  Type
  (type-name [_] "Vector")
  (type-args [v] (seq v))

  Stringable
  (string-list [v]
    (comp (list "[")
          (interpose (map (seq v) str) ", ")
          (list "]")))

  Composition
  (zero [_] empty-vector)
  (comp* [v vs]
    (reduce (cons v vs) empty-vector
            (fn [v next-v]
              (reduce next-v v mutate-vect-conj))))

  Container
  (map [v f]
    (reduce v empty-vector (fn [v x]
                             (mutate-vect-conj v (f x)))))

  (wrap [v x] [x])

  (flat-map [v mf]
    (reduce v empty-vector
            (fn [result x]
              (reduce (mf x) result
                      (fn [result y]
                        (mutate-vect-conj result y))))))

  (flatten [v]
    (vec (apply comp (seq v))))

  Collection
  (empty? [v]
    (and (= 0 (count v))
         (maybe empty-vector)))

  (empty [coll] empty-vector)

  (count [l]
    (vect-count l))

  (conj [vect v]
   (inline C "
  Value *result = (Value *)vectConj((Vector *)arg0, arg1);
  dec_and_free(arg0, 1);
  return(result);"))

  (filter [v f]
    (reduce v empty-vector
            (fn [result x]
              (extract (or (and (f x) (maybe (mutate-vect-conj result x)))
                           (maybe result))))))

  Seqable
  (seq [v]
    (inline C List "return(vectSeq((Vector *)arg0, 0));\n"))

  (vec [v] v)

  (first [v]
    (get v 0))

  (rest [v]
    (subvec v 1))

  (last [v]
    (and (< 0 (count v))
         (get v (dec (count v)))))

  (butlast [v]
    (subvec v 0 (dec (count v))))

  (reverse [v]
    (inline C "return(vectorReverse(arg0));"))

  (reduce [v result f]
    (extract (vect-reduce v 0 result f)))

  (to-str [coll]
    (let [ss-list (cons "" (flat-map (seq coll) string-list))
          new-len (reduce ss-list 0 (fn [len s] (+ len (count s))))
          new-str (str-malloc new-len)]
      (map ss-list (fn [s]
                     (str-append new-str s)))
      new-str))

  Indexed
  (nth [v n]
    (assert (instance? Integer n))
    (get v n))

  (store [v n x]
    (assert (instance? Integer n))
    (inline C "
  Value *result = vectStore((Vector *)arg0, ((Integer *)arg1)->numVal, (Value *)arg2);
  dec_and_free(arg0, 1);
  dec_and_free(arg1, 1);
  return(result);"))

  Associative
  (get [v n]
    (assert (and (instance? Integer n)
                 (<= 0 n)))
    (inline C "return(vectorGet(arg0, arg1));"))

  Eq
  (=* [x y]
    (and (instance? Vector y)
         (= (count x) (count y))
         (vec= x y (count x))
         (maybe x))))

(def emptyBMI
  (inline C BitmapIndexedNode "(Value *)&emptyBMI"))

(defn identity [x] x)

(defn partitioner [l part n]
  (let [bottomed-out? (empty? l)]
    (or (and bottomed-out?
             (= n (count part))
             (maybe (list (list (reverse part)) empty-list)))
        (and bottomed-out?
             (maybe (list empty-list (reverse part))))
        (and (= (count part) n)
             (map (partitioner l empty-list n)
                  (fn [[partitioned remainder]]
                    (list (cons (reverse part) partitioned)
                          remainder))))
        (let [[head & tail] l]
          (partitioner tail (cons head part) n)))))

(defn partition [coll n]
  (let [[partitioned] (extract (partitioner coll empty-list n))]
    partitioned))

(defn partition-all [coll n]
  (let [[partitioned remainder] (extract (partitioner coll empty-list n))]
    (comp partitioned (list remainder))))

(defn partial [f & args]
  ;; paritally apply `f` to `args` creating a new function that expects more arguments
  (fn [& more-args]
    (apply f (comp args more-args))))

(defn every [coll f]
  (or (and (empty? coll))
      (and (flat-map (first coll) f)
           (every (rest coll) f))))


(extend-type BitmapIndexedNode
  Type
  (type-name [_] "BitmapIndexedNode")

  HashMapNode
  (hash-seq [m s]
    (inline C "return(bmiHashSeq(arg0, arg1));"))

  (assoc* [m k v hash shift]
    (inline C "return(bmiAssoc(arg0, arg1, arg2, arg3, arg4));"))

  (dissoc* [node k hash shift]
    (inline C "return(bmiDissoc(arg0, arg1, arg2, arg3));"))

  (get* [node k v hash shift]
    (inline C "return(bmiGet(arg0, arg1, arg2, arg3, arg4));"))

  Collection
  (count [x]
    (inline C Integer "return(bmiCount(arg0));")))

(extend-type ArrayNode
  Type
  (type-name [_] "ArrayNode")

  Collection
  (count [_]
    (inline C "return(arrayNodeCount(arg0));"))

  HashMapNode
  (assoc* [m k v hash shift]
    (inline C "return(arrayNodeAssoc(arg0, arg1, arg2, arg3, arg4));"))

  (hash-seq [m s]
    (inline C "return(arrayNodeSeq(arg0, arg1));"))

  (get* [m k v hash shift]
    (inline C "return(arrayNodeGet(arg0, arg1, arg2, arg3, arg4));"))

  (dissoc* [m k hash shift]
    (inline C "return(arrayNodeDissoc(arg0, arg1, arg2, arg3));")))

(extend-type HashCollisionNode
  Type
  (type-name [_] "HashCollisionNode")

  Collection
  (count [_]
    (inline C "return(collisionCount(arg0));"))

  HashMapNode
  (assoc* [node k v hash shift]
    (inline C "return(collisionAssoc(arg0, arg1, arg2, arg3, arg4));"))

  (dissoc* [node k hash shift]
    (inline C "return(collisionDissoc(arg0, arg1, arg2, arg3));"))

  (hash-seq [m s]
    (inline C "return(collisionSeq(arg0, arg1));"))

  (get* [node k v hash shift]
    (inline C "return(collisionGet(arg0, arg1, arg2, arg3, arg4));")))

(extend-type HashMap
  Type
  (type-name [_] "HashMap")

  Composition
  (zero [_] emptyBMI)
  (comp* [mval mvals]
    (reduce mvals mval
            (fn [acc mval]
              (reduce (seq mval) acc
                      (fn [acc pair]
                        (apply assoc acc pair))))))

  Collection
  (empty? [x]
    (and (= 0 (count x))
         (maybe emptyBMI)))

  Stringable
  (string-list [n]
    (let [a-list (seq n)]
      (let [kv-strs (map a-list (fn [[k v]]
                                  (comp (string-list k) (list " ") (string-list v))))]
        (comp (list "{")
              (flatten (interpose kv-strs (list ", ")))
              (list "}")))))

  Seqable
  (seq [n]
    (hash-seq n empty-list))

  Eq
  (=* [x y]
    (and (instance? HashMap y)
         (every (seq x) (fn [[k v]]
                          (flat-map (get y k)
                                    (partial = v))))
         (maybe x)))

  Associative
  (keys [m]
    (map (seq m) (fn [[k v]] k)))
  (vals [m]
    (map (seq m) (fn [[k v]] v)))
  (get [m k]
    (inline C "return(hashMapGet(arg0, arg1));"))
  (dissoc [m k]
    (dissoc* m k (sha1 k) 0))
  (assoc [m k v]
    (assoc* m k v (sha1 k) 0)))

(defn hash-map [& kv-pairs]
  (reduce (partition kv-pairs 2)
          emptyBMI
          (fn [m [k v]]
            (assoc* m k v (sha1 k) 0))))


(defn deliver [p v]
  (inline C Promise "return(deliverPromise(arg0, arg1));"))

(defn delivered [p]
  (inline C "return(promiseDelivered(arg0));"))

(extend-type Promise
  Type
  (type-name [_] "Promise")

  Stringable
  (string-list [p]
    (extract (or (flat-map (delivered p)
                           (fn [x]
                             (flat-map (first (string-list x))
                                       (fn [x-str]
                                         (list "<Promise " x-str ">")))))
                 (maybe (list "<Promise>")))))

  Container

  (extract [prom]
    (inline C "return(extractPromise(arg0));")))
  ;; (map [p f]
  ;;   (print-err 'promise-map)
  ;;   (abort))
  ;; (wrap [_ v] (promise v))
  ;; (apply* [f vs]
  ;;   ;; TODO: wrong. This waits on 'vs' at application time
  ;;   (promise (apply (extract f) (map vs extract))))
  ;; (flat-map [v f]
  ;;   ;; TODO: wrong. This waits on 'v' at application time
  ;;   (f (extract v)))

(defn promise
  ([] (inline C Promise "return((Value *)malloc_promise());\n"))
  ([v] (deliver (promise) v)))


(defn future [f]
  (inline C "return(makeFuture(arg0));"))

(defn thread-id []
  (inline C Integer "return(integerValue((int64_t)pthread_self()));"))

(extend-type Future
  Type
  (type-name [_] "Future")

  Stringable
  (string-list [_] (list "<Future>"))

  Container
  (map [fut f]
    (future (fn []
              (f (extract fut)))))
  (wrap [_ v] (future (fn [] v)))
  (apply* [f vs]
    (apply (extract f) (map vs extract)))
  (flat-map [v f]
    (f (extract v)))
  (extract [fut]
    (inline C "return(extractFuture(arg0));"))

  (extend [fut f]
    (future (fn []
              (f fut)))))
