
(add-ns p (module "grammar.toc"))
(add-ns sm (module "state-maybe.toc"))
(add-ns fr (module "free.toc"))

(deftype ParserState [curr-input input parser-fns values]
  Stringable
  (string-list [_] (list "<ParserState>")))

(defprotocol RecursiveDescent
  (recursive-descent [_]))

(defprotocol Ignored
  (ignore? [_] nothing))

(extend-type p/get-state-value
  RecursiveDescent
  (recursive-descent [p]
    (sm/state-maybe
     (sm/new-sm (fn [parser-state]
                  (or (map (get-in parser-state [.values (.key p)])
                           (fn [value]
                             [value parser-state]))
                      (let [_ (print-err "Could not get recursive descent state value"
                                         (str "'" (.key p) "'"))]
                        (abort))))))))

(extend-type p/update-state-value
  RecursiveDescent
  (recursive-descent [p]
    (sm/state-maybe
     (sm/new-sm (fn [parser-state]
                  (or (for [new-state (update-in parser-state [.values (.key p)] (.f p))
                            old-value (get-in parser-state [.values (.key p)])]
                        [old-value new-state])
                      (let [_ (print-err "Could not update recursive descent state value"
                                         (str "'" (.key p) "'"))]
                        (abort))))))))

(extend-type Function
  RecursiveDescent
  (recursive-descent [f]
    (sm/state-maybe (fn [& rules]
                      (apply* (sm/state-maybe (fn [& parsed-values]
                                                (apply f (remove parsed-values ignore?))))
                              rules)))))

(defn next-input-buffer [s]
  (let [input (.input s)]
    (for [new-text (first input)]
      (let [s (assoc s .curr-input new-text)]
        (assoc s .input ((empty? new-text) empty-list (rest input)))))))

(defn reader [n s]
  (let [text (.curr-input s)
        text-length (count text)]
    (or (and (< n text-length)
             (maybe [(subs text 0 n)
                     (assoc s .curr-input (subs text n))]))
        (and (= n text-length)
             (or (map (next-input-buffer s)
                      (fn [new-s]
                        [text new-s]))
                 (maybe [text (assoc s .curr-input "")])))
        ;; (< text-length n)
        (for [new-s (next-input-buffer s)
              [texts final-s] (reader (- n text-length) new-s)]
          [(comp text texts) final-s]))))

(defn fn-reader [f s]
  (let [text (.curr-input s)]
    (let [length (f text)]
      ((= 0 length)
       nothing
       (or (and (= length (count text))
                (for [new-s (next-input-buffer s)
                      [tail final-s] (fn-reader f new-s)]
                  [(cons text tail) final-s]))
           (maybe [(list (subs text 0 length))
                   (assoc s .curr-input (subs text length))]))))))

(extend-type p/parser-not-char
  RecursiveDescent
  (recursive-descent [p]
    (sm/state-maybe
     (sm/new-sm (fn [parser-state]
                  (for [[c new-parser-state] (reader 1 parser-state)
                        :when-not (= (.test-c p) c)]
                    [c new-parser-state]))))))

(extend-type p/parser-char-range
  RecursiveDescent
  (recursive-descent [p]
    (sm/state-maybe
     (sm/new-sm (fn [parser-state]
                  (for [[c new-parser-state] (reader 1 parser-state)
                        :when (< (dec (char-code (.lower p)))
                                 (char-code c)
                                 (inc (char-code (.higher p))))]
                    [c new-parser-state]))))))

(extend-type p/parser-terminal
  RecursiveDescent
  (recursive-descent [p]
    (let [term-str (.term-str p)
          term-count (count term-str)]
      (sm/state-maybe (sm/new-sm (fn [parser-state]
                                   (for [[text new-parser-state] (reader term-count parser-state)
                                         :when (= text term-str)]
                                     [term-str new-parser-state])))))))

(extend-type p/parser-term-fn
  RecursiveDescent
  (recursive-descent [p]
    (sm/state-maybe
     (sm/new-sm (fn [s]
                  (for [[str-list new-s] (fn-reader (.f p) s)
                        :let [line-count (reduce str-list 0
                                                 (fn [line-count s]
                                                   (reduce s line-count
                                                           (fn [line-count c]
                                                             (+ line-count ((= c "\n") 1 0))))))]]
                    [(to-str str-list) new-s]))))))

(extend-type p/repeat-rule
  RecursiveDescent
  (recursive-descent [p]
    (map (.rule p) sm/recur)))

(extend-type p/none-or-more-rule
  RecursiveDescent
  (recursive-descent [p]
    (map (.rule p) (fn [rule]
                     (comp (sm/recur rule)
                           (sm/state-maybe empty-list))))))

(extend-type p/ignore-rule
  Stringable
  (string-list [_] (list "ignored"))
  RecursiveDescent
  (recursive-descent [p]
    (map (.rule p) (fn [rule]
                     (apply-to (constantly (reify
                                             Stringable
                                             (string-list [_] (list "<Ignored>"))

                                             Ignored
                                             (ignore? [_] (maybe 'ignore))))
                               rule)))))

(extend-type p/parser-always
  RecursiveDescent
  (recursive-descent [p]
    (sm/state-maybe (sm/state-maybe (.v p)))))

(extend-type p/parser-rule
  RecursiveDescent
  (recursive-descent [p]
    (.grammar p)))

(extend-type p/recursive-parser-rule
  RecursiveDescent
  (recursive-descent [p]
    (for [parser (map (.grammar p) sm/new-sm)
          _ (sm/set-val (.name p) parser)]
      parser)))

(extend-type p/recursion-rule
  RecursiveDescent
  (recursive-descent [p]
    (sm/state-maybe
     (flatten (comp (sm/get-in-val [.parser-fns (.rule-name p)])
                    (map (sm/state-maybe '_)
                         (fn [_]
                           (let [_ (print-err "No parser rule defined for "
                                              (str "'" (.rule-name p) "'"))]
                             (abort)))))))))

(extend-type p/Union
  RecursiveDescent
  (recursive-descent [u]
    (apply* (sm/state-maybe (fn [& rules]
                              (apply comp rules)))
            (.rules u))))

(extend-type p/Cat
  RecursiveDescent
  (recursive-descent [u]
    (apply* (sm/state-maybe (fn [& rules]
                              (apply* (sm/state-maybe (fn [& parsed-values]
                                                        (remove parsed-values ignore?)))
                                      rules)))
            (.rules u))))

(defn parser [grammar]
  (let [[grammar-parser recursive-rules] (extract ((fr/evaluate grammar recursive-descent) {}))]
    (fn
      ([input]
       (flat-map (grammar-parser (ParserState "" input "" recursive-rules {}))
                 first))
      ([values input]
       (flat-map (grammar-parser (ParserState "" input recursive-rules values))
                 first)))))
