
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "3435b1b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "b667c1b"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "95851e0"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "f655efc"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "2978872"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "1e280ff"))
(add-ns ev (git-dependency "https://github.com/Toccata-Lang/eval.git"
                           "eval.toc"
                           :sha "e1f2232"))
(add-ns interp (git-dependency "https://github.com/Toccata-Lang/eval.git"
                               "interpreter.toc"
                               :sha "e1f2232"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "1957ade"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "1c09660"))
(add-ns strm (git-dependency "https://github.com/Toccata-Lang/stream.git"
                             "stream.toc"
                             :sha "c778079"))
(add-ns sh (git-dependency "https://github.com/Toccata-Lang/shell-proc.git"
                           "shell-proc.toc"
                           :sha "a33e2cc"))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(def string-writer (agent ""))
(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def Tagged (comp Symbol
                  rdr/tagged-symbol))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "\n")

(defn line-marker [file-name line-number marker]
  (either (and (= "" file-name)
               (maybe "\n#\n"))
          ["\n" marker "\n// #line "
           (str line-number) " " "\""
           (either (and (= 'core file-name)
                        (maybe path-to-core))
                   file-name)
           "\"\n"]))

(defn line-macro [ast marker]
  (wrap sm/zero-sm (line-marker (ast/file-name ast) (ast/line-number ast) marker)))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeConstraintType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -1, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AllValuesType};"))
(def MultiConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MultiConstraintType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ResultConstraintType};"))
(def ItemsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ItemsConstraintType};"))
(def FieldConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FieldConstraintType};"))
(def StaticIntConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StaticIntConstraintType};"))
(def MinValueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MinValueType};"))
(def MaxValueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaxValueType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, InferredInnerType};"))
(def StaticLengthConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1,
    StaticLengthConstraintType};"))
(def StaticStrConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StaticStrConstraintType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ContentsConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringBufferType "String"
                 SubStringType "String"
                 FnArityType "FnArity"
                 FunctionType "Fn"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"
                 UnknownType "UnknownType"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-type-nums {'Integer IntegerType
                     'StringBuffer StringBufferType
                     'SubString SubStringType
                     'FnArity FnArityType
                     'Function FunctionType
                     'Fn FunctionType
                     'List ListType
                     'Maybe MaybeType
                     'Vector VectorType
                     'Symbol SymbolType
                     'BitmapIndexedNode BitmapIndexedType
                     'ArrayNode ArrayNodeType
                     'HashCollisionNode HashCollisionNodeType
                     'Promise PromiseType
                     'Future FutureType
                     'Agent AgentType
                     'Opaque OpaqueType
                     'TypeCount TypeCount})

(deftype TypeInfo [sym type-map]
  (assert (instance? (map-of Integer HashSet) type-map))

  Stringable
  (string-list [_]
    (list "<TypeInfo " (str sym) ">"))

  Type
  (type-mapping [_]
    type-map))

(def core-types {IntegerType (TypeInfo 'Integer {IntegerType #{}})
                 StringBufferType (TypeInfo 'String {StringBufferType #{}})
                 SubStringType (TypeInfo 'String {SubStringType #{}})
                 FnArityType (TypeInfo 'FnArity {FnArityType #{}})
                 FunctionType (TypeInfo 'Fn {FunctionType #{}})
                 ListType (TypeInfo 'List {ListType #{}})
                 MaybeType (TypeInfo 'Maybe {MaybeType #{}})
                 VectorType (TypeInfo 'Vector {VectorType #{}})
                 SymbolType (TypeInfo 'Symbol {SymbolType #{}})
                 BitmapIndexedType (TypeInfo 'BitmapIndexedNode {BitmapIndexedType #{}})
                 ArrayNodeType (TypeInfo 'ArrayNode {ArrayNodeType #{}})
                 HashCollisionNodeType (TypeInfo 'HashCollisionNode {HashCollisionNodeType #{}})
                 PromiseType (TypeInfo 'Promise {PromiseType #{}})
                 FutureType (TypeInfo 'Future {FutureType #{}})
                 AgentType (TypeInfo 'Agent {AgentType #{}})
                 OpaqueType (TypeInfo 'Opaque {OpaqueType #{}})})

(def fn-constraint (c/TypeConstraint {FunctionType #{}} empty-list 'Fn nothing ""))
(def sym-constraint (c/TypeConstraint {SymbolType #{}} empty-list 'Symbol nothing ""))
(def vect-constraint (c/TypeConstraint {VectorType #{}} empty-list 'Vector nothing ""))
(def list-constraint (c/TypeConstraint {ListType #{}} empty-list 'List nothing ""))
(def string-constraint (c/TypeConstraint {StringBufferType #{} SubStringType #{}}
                                         empty-list 'String nothing ""))
(def int-constraint (c/TypeConstraint {IntegerType #{}} empty-list 'Integer nothing ""))
(def maybe-constraint  (c/TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map (wrap sm/zero-sm "") (fn [_]
                           (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params result-constraint])

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; produce a constraint from an assertion ast
  (to-constraint [ast]
    (wrap sm/zero-sm c/top-type))

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    sm/zero-sm)

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x)))

  ;; unpack the 'list-var' and bind the items to the 'elem-vars'
  (bind-list [list-var params]
    (assert (instance? ast/params-ast params)))

  ;; get the constraints for a symbol or params-ast
  (get-param-constraints [_ constraint-map]
    (assert-result x (instance? sm/new-sm x)))

  ;; update the constraint map for symbol
  (constrain-sym [sym constraint]
    (wrap sm/zero-sm constraint))

  (update-call-site-count [_]
    (assert-result x (instance? sm/new-sm x)))

  (call-site-meta-data [c-var file-name line-number]
    (assert-result x (instance? sm/new-sm x)))

  ;; encode a static representation of a core data structure
  (encode [m]
    (emit m))

  (encode [m var-prefix])

  ;; encode a statically initialized representation of a core data structure
  (encode-static [m]
    sm/zero-sm)

  (runtime-check [constraint value-info file-name line-number]
    ;; TODO: this causes weird error messages
    ;;  (assert (instance? String file-name))
    ;;  (assert (instance? Integer line-number))

    ;; generated code must preserve ref counts
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            (runtime-check constraint value-info
                           (either (and (= "" file-name)
                                        (maybe "\"\""))
                                   (str "\"at " file-name ": " line-number "\"")))))

  (runtime-check [constraint value-info sym-location]))

(defn destruct-seq [seq-c-var elem-c-vars dest-args file-name line-num]
  (assert (instance? String seq-c-var))
  (assert (instance? String dest-args))

  (let [elem-count (count elem-c-vars)]
    [(map elem-c-vars (fn [var]
                        ["Value *" var ";" line-sep]))
     "Value **" dest-args "[" elem-count "] = {"
     (interpose (map elem-c-vars (fn [var] ["&" var])) ", ")
     "};" line-sep "destructValue(\"" file-name "\", \"" line-num
     "\", (Value *)" seq-c-var ", " elem-count ", "
     dest-args ");" line-sep]))

(deftype FnValPtr [var]
  ;; pointer to a Fn struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ArityValPtr [var struct]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype StaticFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ProtoDispFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(def CFnPtr (comp StaticFnPtr
                  ProtoDispFnPtr))

(def PointerVar (comp FnValPtr
                      ArityValPtr
                      CFnPtr))

(extend-type PointerVar
  Emitter
  (encode-static [x]
    (emit (.var x)))

  Stringable
  (string-list [x]
    (list (str (.var x))))

  Hashable
  (sha1 [x]
    (sha1 (.var x)))

  (sha1-update [x context]
    (sha1-update (.var x) context)))

(defprotocol C-Code
  (expr-constraints [expr]
    (assert-result x (instance? c/Constraints x)))

  (constrain-expr [expr constraint])

  (collapse-expressions* [x y]))

(defn expr-type-num [expr]
  (either (-> expr
              expr-constraints
              c/extract-type-map
              (flat-map (fn [type-map]
                          (let [type-nums (keys type-map)]
                            (and (= 1 (count type-nums))
                                 (first type-nums))))))
          UnknownType))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; refs-map: map of C variables that are used in 'init' and how many times

(deftype empty-code [c-var init decl refs-map constraints]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/Constraints) constraints))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

(def empty-c-code (empty-code "" [] [] {} {}))

(defn merge-constraint-maps [file-name line-number x y]
  (assert (instance? (map-of String c/Constraints) x))
  (assert (instance? (map-of String c/Constraints) y))

  (merge-with (fn [x-constraint y-constraint]
                (either (c/compose-constraints file-name line-number x-constraint y-constraint)
                        (abort)))
              x y))

(deftype c-code [c-var init decl refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/Constraints) constraints))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-reified [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Reified " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-str [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-String " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-int [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Int " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-sym [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Symbol " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-vector-fn [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Vector-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-maybe-fn [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Maybe-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-list-fn [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-List-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-protocol-fn [c-var init decl refs-map constraints c-struct arities]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Protocol-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-arity [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Arity " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-fn [c-var init decl refs-map constraints c-struct arities]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) " " (str arities) ">")))

(deftype c-static-val [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Value " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(def C-Static-Value (comp c-static-int
                          c-static-str
                          c-static-sym
                          c-static-reified
                          c-list-fn
                          c-maybe-fn
                          c-vector-fn
                          c-static-fn
                          c-static-arity
                          c-protocol-fn
                          c-static-val))

(extend-type C-Static-Value
  Emitter
  (encode-static [x]
    (wrap sm/zero-sm x)))

(def C-Value (comp c-code
                   C-Static-Value))

(extend-type C-Value
  Collection
  (empty? [c]
    (and (empty? (.init c))
         (empty? (.decl c))
         (empty? (.constraints c))))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing))

;; same as 'c-init', but specifically for anon closure functions
(deftype c-closure-fn [c-var init decl refs-map constraints arities file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Closure " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) " " (str arities) ">"))

  Collection
  (empty? [c] nothing))

;; same as 'c-code', but defines a function parameter
(deftype c-param [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints))

  Stringable
  (string-list [_]
    (list "<C-Param " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing))

(def C-expr (comp empty-code
                  C-Value
                  c-param
                  c-closure-fn
                  c-init))

(extend-type empty-code
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (comp* y (rest xs))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    y))

(extend-type c-param
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (collapse-expressions* x y))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [init (either (or (for [refs (get-in y [.refs-map (.c-var x)])]
                             [(.init x)
                              (either (and (< refs 2)
                                           (maybe ""))
                                      ["incRef(" (.c-var x) ", " (dec refs) ");" line-sep])
                              (.init y)])
                           (and (= "" (.c-var x))
                                (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" (.c-var x) ", 1);" line-sep
                        (.init y)])
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           (.c-var x))
          refs-map (assoc refs-map (.c-var x) 0)]
      (c-code (.c-var y)
              init [(.decl x) (.decl y)] refs-map
              (merge-constraint-maps (ast/file-name x) (ast/line-number x)
                                     (.constraints x) (.constraints y))))))

(extend-type c-init
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))]
                     (collapse-expressions* x y))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          init [(.init x)
                (either (for [constraint (get (.constraints y) c-var)
                              value-info (or (get (.constraints x) c-var)
                                             (maybe c/top-type))]
                          (-> constraint
                              (c/update-var c-var)
                              (runtime-check value-info file-name line-number)))
                        "")
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(either (and (< refs 2)
                                            (maybe ""))
                                       ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          constraints-map (merge-constraint-maps file-name line-number
                                                 (.constraints x) (.constraints y))]
      (-> y
          (.init init)
          (.decl [(.decl x) (.decl y)])
          (.refs-map refs-map)
          (.constraints constraints-map)))))

(extend-type c-closure-fn
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))]
                     (collapse-expressions* x y))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          init [(.init x)
                (either (for [constraint (get (.constraints y) c-var)
                              value-info (or (get (.constraints x) c-var)
                                             (maybe c/top-type))]
                          (-> constraint
                              (c/update-var c-var)
                              (runtime-check value-info file-name line-number)))
                        "")
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(either (and (< refs 2)
                                            (maybe ""))
                                       ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          constraints-map (merge-constraint-maps file-name line-number
                                                 (.constraints x) (.constraints y))]
      (-> y
          (.init init)
          (.decl [(.decl x) (.decl y)])
          (.refs-map refs-map)
          (.constraints constraints-map)))))

(extend-type C-Value
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (-> y
                         (.init [(.init x) (.init y)])
                         (.decl [(.decl x) (.decl y)])
                         (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
                         (.constraints (merge-constraint-maps ""  0
                                                              (.constraints x) (.constraints y)))))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [x (either (and (empty? (.init x))
                         (maybe (.refs-map x {})))
                    x)]
      (-> y
          (.init [(.init x) (.init y)])
          (.decl [(.decl x) (.decl y)])
          (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
          (.constraints (merge-constraint-maps ""  0
                                               (.constraints x) (.constraints y)))))))

(defn collapse-expressions [cs]
  (either (or (and (empty? cs)
                   (maybe empty-c-code))
              (and (empty? (rest cs))
                   (first cs)))
          (let [[c & cs] cs]
            (collapse-expressions* c (collapse-expressions cs)))))

(deftype Closures [closures refs-map constraints]
  (assert (instance? (vector-of Vector) closures))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? (map-of String c/ContentsConstraint) constraints)))

(def empty-closures (Closures [] {} {}))

(deftype ConstantValues [numbers strings symbols type-names other]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names)))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count syms context-syms closed-over]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols types declarations]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; types            map of type symbols to type definitions
  (assert (instance? HashMap types))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
;; TODO: might be able to remove the 'fns' field
(deftype GlobalContext [fn-context rt-init modules fns namespaces constants reify-fn-index type-maps]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit rt-init))
  ;; modules                info for each module compiled
  (assert (instance? HashMap modules))
  ;; fns                    static functions
  (assert (instance? HashMap fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))

  Stringable
  (string-list [_] (list "<GlobalContext>")))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      new-context (comp (-> curr-fn-context .context-syms)
                                        (-> curr-fn-context .syms))]
                  (maybe [curr-fn-context
                          (.fn-context s (FunctionArityContext {} 0 {} new-context empty-closures))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.fn-context s) (.fn-context s new-fn-context)])))))

(defn extract-sym-path [s sym]
  (let [file-name (ast/file-name sym)]
    (flat-map (rdr/namespace sym)
              (fn [ns-sym]
                (or (get-in (.namespaces s) [file-name ns-sym])
                    (get-in (.namespaces s) [file-name (rdr/tag ns-sym)]))))))

(defn sym-ns-path [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (map (extract-sym-path s sym) (fn [path]
                                                   [path s]))
                   (maybe [(ast/file-name sym) s])))))

(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str (list* start (seq remaining))))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (either (check-C-var (str sym "_"))
                                       arg-name)
                               sym-count)
                          new-ctxt]))))))

(deftype ParamBinding [vars destruct]
  (assert (instance? Vector vars))
  (assert (instance? Vector destruct))

  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (vec (cons x xs))]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name]
   (wrap sm/zero-sm (str (gensym (str "g_" arg-name)))))
  ([sym arg-name]
   (wrap sm/zero-sm (str (gensym (str "g_" (either (check-C-var (str sym "_"))
                                                  arg-name)))))))


(deftype ProtoImpl [dispatch-type c-var ast param-constraints result-constraint c-fn]
  (assert (instance? ArityValPtr c-var))
  (assert (instance? Integer dispatch-type))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))
  (assert (instance? CFnPtr c-fn))

  Stringable
  (string-list [_] (list "<ProtoImpl type: " (target-type-name dispatch-type) " " (str c-var) " "
                         (str c-fn) ">"))

  Emitter
  (encode [x]
    (encode-static x))

  (encode-static [_]
    (either (and (= "" (.var c-var))
                 (maybe sm/zero-sm))
            (wrap sm/zero-sm (c-static-val (str "(Value *)" c-var) [] [] {} {} (.struct c-var))))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [protos (get-in s [.modules path .protocols])
                     _ (some (vals protos) (fn [proto] (get proto (rdr/untag fn-sym))))]
                 [path s]))))

(defn find-protocol-path [fn-sym]
  (comp (for [path (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym path)]
          path)
        (lookup-protocol-path fn-sym 'core)))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(defn new-proto-impl [proto-sym fn-sym arg-count dispatch-type var ast param-constraints result-constraint c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-sym))
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/fn-arity-ast ast))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))
  (assert (instance? ArityValPtr var))
  (assert (instance? CFnPtr c-fn))

  (for [protocol-path (find-protocol-path fn-sym)
        _ (sm/assoc-in-val [.modules protocol-path .protocols (rdr/untag proto-sym) (rdr/untag fn-sym)
                            arg-count dispatch-type]
                           (ProtoImpl dispatch-type var ast param-constraints result-constraint c-fn))]
    ""))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [path (either (extract-sym-path s proto-sym)
                                      (ast/file-name proto-sym))]
                     (for [proto-info (-> (.modules s)
                                          (get path)
                                          (flat-map (fn [module]
                                                      (get (.protocols module) (rdr/untag proto-sym)))))]
                       [proto-info s]))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.protocols module) (rdr/untag proto-sym)))))]
                     [proto-info s])))))

;; TODO: it feels like these 2 arities are too different
(defn get-proto-impl
  ([fn-sym arg-count type-num]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (or (let [proto-path (either (extract-sym-path s fn-sym)
                                             (ast/file-name fn-sym))]
                      (for [protocols (get-in s [.modules proto-path .protocols])
                            impl-info (some (vals protocols)
                                            (fn [dispatchers]
                                              (get-in dispatchers [(rdr/untag fn-sym) arg-count type-num])))]
                        [impl-info s]))
                    (for [protocols (get-in s [.modules 'core .protocols])
                          impl-info (some (seq protocols)
                                          (fn [[proto-name dispatchers]]
                                            (get-in dispatchers [(rdr/untag fn-sym) arg-count type-num])))]
                      [impl-info s])))))
  ([proto-sym fn-sym arg-count type-num]
   (flat-map (sm/new-sm (fn [s]
                          (maybe [(either (extract-sym-path s proto-sym)
                                          (ast/file-name proto-sym))
                                  s])))
             (fn [proto-path]
               (comp (sm/get-in-val [.modules proto-path .protocols (rdr/untag proto-sym) (rdr/untag fn-sym)
                                     arg-count type-num])
                     (sm/get-in-val [.modules 'core .protocols (rdr/untag proto-sym) (rdr/untag fn-sym)
                                     arg-count type-num])
                     ;; (compilation-error "Invalid protocol fn:"
                     ;;                    (str "'" fn-sym "' in")
                     ;;                    (str (ast/file-name fn-sym) ",")
                     ;;                    (ast/line-number fn-sym))
                     )))))

(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.modules s)
                   (get (ast/file-name sym))
                   (flat-map (fn [module]
                               (map (get-in (.declarations module) [sym '_])
                                    (fn [expr]
                                      [expr s]))))))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

(defn find-global-sym [sym]
  ;; Attempt to look up the global (ie. not closed over) value given a symbol.
  (for [ns-path (sym-ns-path sym)
        expr (sm/get-in-val [.modules ns-path .values sym])]
    expr))

;; This is so hideous on purpose. It's called *A LOT* so I unwound it for performance's sake
(defn lookup-sym [sym]
  ;; Look up a value given a symbol. Will abort if the symbol cannot be found.
  (let [sym-file (ast/file-name sym)]
    (comp (sm/new-sm
           (fn [s]
             (assert (instance? GlobalContext s))
             (let [ctxt (.fn-context s)
                   syms (.syms ctxt)
                   modules (.modules s)
                   closed-over (.closed-over ctxt)
                   closures (.closures closed-over)
                   refs-map (.refs-map closed-over)]
               (or (map (or (and (rdr/namespace sym)
                                 (or (-> (flat-map (extract-sym-path s sym)
                                                   (fn [x]
                                                     (get modules x)))
                                         (flat-map (fn [module]
                                                     (let [values (.values module)]
                                                       (or (get values (rdr/untag sym))
                                                           (get values (rdr/tag (rdr/untag sym))))))))
                                     (do
                                       (print-err "Undefined symbol" (str "'" sym "'") "at"
                                                  (str sym-file ":")
                                                  (ast/line-number sym))
                                       (maybe (abort)))))
                            (get syms sym))
                        (fn [expr]
                          [expr s]))
                   (map (-> ctxt .context-syms (get sym))
                        (fn [sym-info]
                          (either (some closures
                                        (fn [[closure-var sym-literal]]
                                          (and (= sym sym-literal)
                                               (map (get refs-map closure-var)
                                                    (fn [refs-count]
                                                      (let [new-refs-map (assoc refs-map closure-var (inc refs-count))
                                                            new-closed-over (.refs-map closed-over new-refs-map)
                                                            new-ctxt (.closed-over ctxt new-closed-over)]
                                                        [(c-code closure-var [] [] {closure-var 1}
                                                                 {closure-var (expr-constraints sym-info)})
                                                         (.fn-context s new-ctxt)]))))))
                                  (let [sym-count (.sym-count ctxt)
                                        closure-var (str "val" sym-count)
                                        new-sym-count (inc sym-count)
                                        new-closures (conj closures [closure-var sym (expr-constraints sym-info)])
                                        new-refs-map (assoc refs-map closure-var 1)
                                        new-closed-over (-> closed-over
                                                            (.closures new-closures)
                                                            (.refs-map new-refs-map))
                                        new-ctxt (-> ctxt
                                                     (.sym-count new-sym-count)
                                                     (.closed-over new-closed-over))]
                                    [(c-code closure-var [] [] {closure-var 1}
                                             {closure-var (expr-constraints sym-info)})
                                     (.fn-context s new-ctxt)]))))
                   (map (or (flat-map (get modules sym-file)
                                      (fn [module]
                                        (or (get (.values module) sym)
                                            (get-in (.declarations module) [sym '_]))))
                            (flat-map (get modules 'core)
                                      (fn [module]
                                        (get (.values module) sym))))
                        (fn [expr] [expr s]))
                   (do
                     (print-err "Undefined symbol" (str "'" sym "'") "at"
                                (str sym-file ":")
                                (ast/line-number sym))
                     (abort)))))))))

(extend-type c/Constraints
  Emitter
  (encode-static [x]
    ;; TODO: for some reason, encoding the sym doesn't alwys work,
    ;; fortunately, it's not needed
    (let [x (either (map (instance? c/SymbolConstraints x)
                         (fn [x]
                           (-> x
                               (.var "")
                               (.sym nothing))))
                    x)]
      (comp (for [args (encode-static (type-args x))
                  struct (global-var "reified_")
                  var (global-var "reified_")]
              (collapse-expressions
               [args (c-static-val var []
                                   ["ReifiedVal " struct " = {" (str (get-type x)) ", -1, "
                                    ;; TODO: should be the args's .c-structs
                                    "0, {}};" line-sep
                                    "Value *" var "= (Value *)&" struct ";" line-sep]
                                   {} {} struct)]))
            ;; TODO remove
            (for [_ (debug 'missing x)
                  :when nothing]
              '_)))))

(extend-type c/StaticConstraints
  Emitter
  (runtime-check [constraint value-info sym-location]
    []))

(extend-type c/ItemsConstraint
  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            (either (and (empty? (.items-constraints constraint))
                         (maybe []))
                    [(-> (c/TypeConstraint {ListType #{} VectorType #{}} (.path constraint) 'Sequence
                                           (.sym constraint) (.var constraint))
                         (runtime-check value-info sym-location))
                     (let [min-count (str (count (.items-constraints constraint)))]
                       ["if (countSeq(incRef(" (.var constraint) ", 1)) < " min-count ") {"
                        "\n#ifndef EMBEDDED\n"
                        "fprintf(stderr, \"Insufficient values for '"
                        (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");\n"
                        "fprintf(stderr, \"Needed " min-count
                        ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, "
                        (.var constraint) "))->numVal);" line-sep
                        "fprintf(stderr, \"" (interpose (c/format-path constraint (inc (count (.path constraint))))
                                                        "\\n")
                        "\\n\");\n#endif\nabort();" line-sep "}\n"])
                     "if (1) {\n"
                     "incRef(" (.var constraint) ", 1);" line-sep
                     (let [items (map (range (inc (count (.items-constraints constraint))))
                                      (partial str (.var constraint) "_"))]
                       [(destruct-seq (.var constraint) items (str (.var constraint) "_args") "" 9999)
                        (for [[constraints item] (zip-lists (.items-constraints constraint) items)]
                          (let [constraints (either (map (.sym constraint) (fn [sym]
                                                                             (c/update-sym constraints sym)))
                                                    constraints)]
                            (-> constraints
                                (c/update-var item)
                                (runtime-check value-info sym-location))))
                        (map items (fn [item]
                                     (str "dec_and_free(" item ", 1);" line-sep)))])
                     "}" line-sep]))))

(extend-type c/NoValues
  Emitter
  (runtime-check [constraint value-info sym-location]
    ["abort();\n#\n"]))

(extend-type c/AllValues
  Emitter
  (emit [constraint]
    (wrap sm/zero-sm empty-c-code))

  (runtime-check [constraint value-info sym-location]
    []))

(defn get-type-info [path type-symbol]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [modules (.modules s)]
                 (for [type-num (or (flat-map (get modules path)
                                              (fn [module]
                                                (get (.types module) type-symbol)))
                                    (flat-map (get modules 'core)
                                              (fn [module]
                                                (get (.types module) type-symbol))))
                       type-map (get-in s [.type-maps type-num .type-map])]
                   [type-map s])))))

(defn get-type-sym-info [type-symbol]
  (comp (for [ns-path (sym-ns-path type-symbol)
              type-info (get-type-info ns-path type-symbol)]
          type-info)
        (wrap sm/zero-sm {})))

(extend-type c/SymbolConstraints
  Emitter
  (to-constraint [ast]
    (wrap sm/zero-sm ast))

  (tail-call [constraint _ _]
    constraint)

  (replace-syms [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs old-sym)]
              (wrap sm/zero-sm (c/update-sym constraint new-sym)))
            (wrap sm/zero-sm constraint)))

  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (for [sym-info (lookup-sym sym)
                         :let [var (constrain-expr sym-info (-> constraint
                                                                (c/update-var (.c-var sym-info))))]
                         _ (set-sym sym var)]
                     (.refs-map var (dissoc (.refs-map sym-info) (.c-var sym-info))))))
            (wrap sm/zero-sm empty-c-code))))

(extend-type c/InferredInner
  Emitter
  (to-constraint [ast]
    (for [new-inner (to-constraint (.inner ast))]
      (.inner ast new-inner)))

  (runtime-check [constraint value-info sym-location]
    ;; TODO: this needs to be implemented, or something
    []))

(extend-type c/ContentsConstraint
  Emitter
  (to-constraint [ast]
    (for [new-constraints (ev/traverse (seq (.constraints ast)) to-constraint)]
      (.constraints ast new-constraints)))

  (runtime-check [constraint value-info sym-location]
    ;; TODO: this needs to be implemented, or something
    []))

(extend-type c/TypeConstraint
  Emitter
  (to-constraint [ast]
    (map (get-type-sym-info (.type-sym ast))
         (fn [type-info]
           (either (and (empty? type-info)
                        (maybe c/top-type))
                   (.type-maps ast type-info)))))

  (emit [ast]
    (either (map (.sym ast)
                 (fn [sym]
                   (for [constraint (map (get-type-sym-info (.type-sym ast))
                                         (fn [type-info]
                                           (either (and (empty? type-info)
                                                        (maybe c/top-type))
                                                   (.type-maps ast type-info))))
                        _ (constrain-sym sym constraint)
                         var (lookup-sym sym)]
                     (c-code "" [] [] {} (.constraints var)))))
            (wrap sm/zero-sm empty-c-code)))

  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["switch (" (.var constraint) "->type) {" 
             (map (keys (.type-maps constraint)) (fn [type-num]
                                                   ["case " type-num ": " ]))
             "break; default:"
             "\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Invalid type of value for '"
             (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");\n"
             "fprintf(stderr, \"Needed " (str (.type-sym constraint))
             ", got %s\\n\", extractStr(type_name(empty_list, " (.var constraint) ")));" 
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             "\n#endif\nabort();}"])))

(extend-type c/MaxValue
  Emitter
  (to-constraint [ast]
    (wrap sm/zero-sm ast))

  (emit [ast]
    (either (map (.sym ast)
                 (fn [sym]
                   (for [_ (constrain-sym sym ast)
                         var (lookup-sym sym)]
                     (c-code "" [] [] {} (.constraints var)))))
            (wrap sm/zero-sm empty-c-code)))

  (runtime-check [constraint value-info sym-location]
    ;; TODO: checking the type here actually results in two checks back-to-back for
    ;; runtime-tests/int-too-large.toc
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            [(-> int-constraint
                 (.var (.var constraint))
                 (.sym (.sym constraint))
                 (runtime-check value-info sym-location))
             "if (" (str (.max constraint)) " < ((Integer *)" (.var constraint) ")->numVal) {"
             "\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Value of '" (either (.sym constraint) "<unknown>")
             "' is too large %s\\n\", " sym-location ");\n"
             "fprintf(stderr, \"Maximum allowed value is " (str (.max constraint))
             ", got %\" PRId64 \"\\n\", ((Integer *)" (.var constraint) ")->numVal);\n"
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             "\n#endif\nabort();}"])))

(extend-type c/FieldConstraint
  Emitter
  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (for [sym-info (lookup-sym sym)
                         field-var (lookup-sym (.field constraint))
                         :let [var (constrain-expr sym-info (-> constraint
                                                                (.field-var (.c-var field-var))
                                                                (c/update-var (.c-var sym-info))))]
                         _ (set-sym sym var)]
                     (.refs-map var (dissoc (.refs-map sym-info) (.c-var sym-info))))))
            (wrap sm/zero-sm empty-c-code)))

  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["if(1) {\n"
             "Value *dork = hasField(empty_list, incRef(" (.var constraint) ", 1), "
             (.field-var constraint) ");\n" "if (isNothing(dork,\"\",0)) {\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Value '" (either (.sym constraint) "<unknown>")
             "' of type '%s' does not have field '"
             (.field constraint) "' %s\\n\", extractStr(type_name(empty_list, "
             (.var constraint) ")), " sym-location ");\n" 
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             "\n#endif\n"
             "abort();" 
             "}\ndec_and_free(dork, 1);\n}\n"])))

(extend-type c/MultiConstraint
  Emitter
  (to-constraint [ast]
    (for [new-consts (ev/traverse (.constraints ast) to-constraint)]
      (.constraints ast new-consts)))

  (runtime-check [constraint value-info sym-location]
    (either (and (or (some (.constraints constraint)
                           (partial instance? c/StaticConstraints))
                     (c/satisfied-by constraint value-info))
                 (maybe ""))
            (do
              ;; TODO: minimize the runtime checks
              ;; TODO: make this like ItemsConstraints
              (map (.constraints constraint)
                   (fn [c]
                     (runtime-check c value-info sym-location))))))

  (emit [constraint]
    (map (ev/traverse (.constraints constraint) emit)
         (fn [[expr & exprs]]
           (comp* expr exprs)))))

(extend-type c/ResultConstraint
  Emitter
  (tail-call [constraint _ _]
    constraint)

  (emit [ast]
    (wrap sm/zero-sm empty-c-code))

  (runtime-check [constraint value-info sym-location]
    ;; TODO: perhaps this should be implemented
    [])

  (to-constraint [ast]
    (to-constraint (.assertion ast))))

(extend-type Maybe
  Emitter
  (encode-static [v]
    (either (map v (fn [v]
                     (for [expr (encode-static v)
                           struct (global-var "maybe_")
                           var (global-var "maybe_")]
                       (comp expr
                             (c-static-val var []
                                           ["Maybe " struct " = (Maybe){MaybeType, -1, (Value *)&" (.c-struct expr)
                                            "};" line-sep
                                            "Maybe *" var " = &" struct ";" line-sep] {} {} struct)))))
            (wrap sm/zero-sm
                  (c-static-val "nothing" [] [] {} {} "nothing_struct")))))

(extend-type List
  Emitter
  (encode-static [l]
    (either (map (first l)
                 (fn [head]
                   (for [tail-expr (encode-static (rest l))
                         head-expr (encode-static head)
                         struct (global-var "list_")
                         var (global-var "list_")]
                     (comp tail-expr
                           head-expr
                           (c-static-val var []
                                         ["List " struct " = {ListType, -1, " (str (count l))
                                          ", (Value *)&" (.c-struct head-expr)
                                          ", &" (.c-struct tail-expr) "};" line-sep]
                                         {} {} struct)))))
            (wrap sm/zero-sm
                  (c-static-val "empty_list" [] [] {} {} "empty_list_struct"))))

  (tail-call [asts args result-constraint]
    (let [asts (reverse asts)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args result-constraint)
                    (cons init)
                    reverse))))))

(defn encodeVectorInfo [v]
  (inline C Vector "
  Vector *v = (Vector *)v_0;

  Vector *array = empty_vect;
  for (int i = 0; i < v->count; i++) {
    Value *val = v->tail[i];
    incRef(val, 1);
    array = mutateVectConj(array, val);
  }

  Vector *result = empty_vect;
  result = mutateVectConj(result, integerValue(v->shift));
  result = mutateVectConj(result, integerValue(v->tailOffset));
  if (v->root != (VectorNode *)0) {
    fprintf(stderr, \"Encode Vector root\\n\");
    abort();
  } else {
    result = mutateVectConj(result, nothing);
  }
  result = mutateVectConj(result, (Value *)array);

  dec_and_free(v_0, 1);
  return((Value *)result);
  "))

(def vector-array-len (inline C List "(Value *)&(Integer){IntegerType,-1,VECTOR_ARRAY_LEN}"))

(extend-type Vector
  Emitter
  (encode-static [v]
    (let [[shift offset root array] (encodeVectorInfo v)]
      (for [items (ev/traverse array encode-static)
            root (either (map root encode-static)
                         (wrap sm/zero-sm (c-static-val "NULL" [] [] {} {} "NULL")))
            struct (global-var "vect_")
            var (global-var "vect_")]
        (comp* empty-c-code (comp items
                                  (let [items (either (and (empty? items)
                                                           (maybe "0"))
                                                      (interpose (map items
                                                                      (fn [expr]
                                                                        (str "(Value *)&" (.c-struct expr))))
                                                                 ", "))]
                                    [(c-static-val var []
                                                   ["Vector " struct " = {VectorType, -1, "
                                                    (str (count array))
                                                    ", " (str shift) ", " (str offset) ", "
                                                    (.c-struct root) ", " items
                                                    (map (range (- vector-array-len (count array))) (fn [_] ", 0"))
                                                    "};" line-sep
                                                    "Value *" var "= (Value *)&" struct ";" line-sep]
                                                   {} {} struct)]))))))

  (tail-call [asts params result-constraint]
    (either (flat-map (last asts)
                  (fn [tail]
                    (store asts (dec (count asts))
                           (tail-call tail params result-constraint))))
            asts)))

(deftype TailHashMap [m]
  Stringable
  (string-list [_]
    (list (str m)))

  Emitter
  (emit [_]
    ;; TODO: put the code to init the value in the run time init
    (map (encode m)
         (fn [expr]
           (.init expr (comp (.init expr) ["return(" (.c-var expr) ");" line-sep]))))))

(defn bmiArray [m]
  (inline C Vector "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  int cnt = __builtin_popcount(node->bitmap);
  Vector *v = empty_vect;
  for (int i = 0; i < cnt * 2; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe(empty_list, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiBitmap [m]
  (inline C Integer "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  Value *result = integerValue(node->bitmap);
  dec_and_free(m_0, 1);
  return((Value *)result);
  "))

(extend-type BitmapIndexedNode
  Emitter
  (encode-static [m]
    (for [items (ev/traverse (bmiArray m) (fn [v]
                                            (either (map v (fn [v]
                                                             (map (encode-static v) maybe)))
                                                    (wrap sm/zero-sm nothing))))
          struct (global-var "bmi_")
          var (global-var "bmi_")]
      (comp* empty-c-code (comp (map items (fn [v] (either v empty-c-code)))
                                (let [items (either (and (empty? items)
                                                         (maybe "0"))
                                                    (interpose (map items
                                                                    (fn [v]
                                                                      (either (map v (fn [expr]
                                                                                       (str "(Value *)&"
                                                                                            (.c-struct expr))))
                                                                              "NULL")))
                                                               ", "))]
                                  [(c-static-val var []
                                                 ["BitmapIndexedNode " struct " = {BitmapIndexedType, -1, "
                                                  (str (bmiBitmap m))
                                                  ", " items
                                                  "};" line-sep
                                                  "Value *" var "= (Value *)&" struct ";" line-sep]
                                                 {} {} struct)]))))))

(defn arrayNodeArray [m]
  (inline C Vector "
  ArrayNode *node = (ArrayNode *)m_0;
  Vector *v = empty_vect;
  for (int i = 0; i < ARRAY_NODE_LEN; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe(empty_list, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(extend-type ArrayNode
  Emitter
  (encode-static [m]
    (for [items (ev/traverse (arrayNodeArray m) (fn [v]
                                                  (either (map v (fn [v]
                                                                   (map (encode-static v) maybe)))
                                                          (wrap sm/zero-sm nothing))))
          struct (global-var "arrayNode_")
          var (global-var "arrayNode_")]
      (comp* empty-c-code (comp (map items (fn [v] (either v empty-c-code)))
                                (let [items (either (and (empty? items)
                                                         (maybe "0"))
                                                    (interpose (map items
                                                                    (fn [v]
                                                                      (either (map v (fn [expr]
                                                                                       (str "(Value *)&"
                                                                                            (.c-struct expr))))
                                                                              "NULL")))
                                                               ", "))]
                                  [(c-static-val var []
                                                 ["ArrayNode " struct " = {ArrayNodeType, -1, " items "};"
                                                  line-sep "Value *" var "= (Value *)&" struct ";" line-sep]
                                                 {} {} struct)]))))))

(extend-type HashMap
  Emitter
  (emit [m]
    ;; TODO: put the code to init the value in the run time init
    (comp (encode-static m)
          (encode m)))

  (tail-call [m params result-constraint]
    ;; TODO: does a hash-map satisfy the result-constraint
    (TailHashMap m))

  (encode [m] (encode m "var_"))

  (encode [m var-prefix]
    (comp (encode-static m)
          (for [map-var (global-var var-prefix)
                :let [_ (write-strings [["Value *" map-var " = (Value *)&emptyBMI;\n"]])]
                assocs (ev/traverse (seq m)
                                    (fn [[sym var]]
                                      (for [sym-var (either (and (instance? Tagged sym)
                                                                 (maybe (emit (ast/quoted-ast sym))))
                                                            (emit sym))
                                            expr (comp (encode-static var)
                                                       (encode var))]
                                        (do
                                          (write-strings [(.decl sym-var) (.decl expr)])
                                          [(.init sym-var) (.init expr)
                                           map-var " = hashMapAssoc((Value *)" map-var
                                           ", incRef(" (.c-var sym-var) ", 1), " (.c-var expr) ");\n"]))))]
            (c-code map-var
                    (comp* [] assocs)
                    [] {} {})))))


(deftype StaticArityInfo [c-var param-constraints result-constraint]
  (assert (instance? CFnPtr c-var))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))

  Stringable
  (string-list [_]
    (list "<StaticArityInfo " (str c-var) " " (str param-constraints) " " (str result-constraint) ">")))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity-info [fn-var num-params]
  (assert (instance? FnPTr fn-var))
  
  (sm/get-in-val [.fns fn-var num-params]))

(defn lookup-core-fn-arity [sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [module (get (.modules s) 'core)
                     fn-sym (get (.values module) sym)
                     expr (get-in (.fns s) [(.c-var fn-sym) num-args .c-var])]
                 [expr s]))))

(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (wrap sm/zero-sm (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] {} {})))

  (emit-defined-value [_ x] (wrap sm/zero-sm []))
  (emit-definition [_] (wrap sm/zero-sm []))

  (tail-call [ast params result-constraint] ast))

(defn make-static-string [str-val]
  ;; TODO: when adding meta data, make sure to update this as well
  (let [str-len (count str-val)]
    (comp (sm/get-in-val [.constants .strings str-val])
          (for [str-idx (sm/new-sm (fn [s]
                                     (assert (instance? GlobalContext s))
                                     (-> s
                                         .constants
                                         .strings
                                         count
                                         (vector s)
                                         maybe)))
                :let [str-sym (str "str" str-idx)
                      str-ptr (str "strPtr" str-idx)]
                _ (sm/assoc-in-val [.constants .strings str-val]
                                   (c-static-str str-ptr [] [] {}
                                                 {str-ptr (.var string-constraint str-ptr)}
                                                 str-sym))]
            (c-static-str str-ptr
                          []
                          ["struct {TYPE_SIZE type;
        REFS_SIZE refs;
        int64_t len;
        Integer *hash;
        char buffer["
                           (inc str-len)
                           "];\n} " str-sym " = {StringBufferType, -1, "
                           str-len ", 0, \"" (escape-chars str-val) "\"};\n"
                           "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
                          {} {str-ptr (.var string-constraint str-ptr)}
                          str-sym)))))

(defn type-constraint [type-num file-name line-number]
  (comp (for [type-info (sm/get-in-val [.type-maps type-num])]
          (either (and (empty? (.type-map type-info))
                       (maybe c/top-type))
                  (-> (.type-map type-info)
                      (c/TypeConstraint empty-list (.sym type-info) nothing "")
                      (c/update-path file-name line-number))))
        (wrap sm/zero-sm c/top-type)))

(defn get-type-numbers [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              type-nums (get-type-sym-info type-symbol)]
          (set (keys type-nums)))
        (wrap sm/zero-sm #{})))

(defn get-type-number [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              type-nums (get-type-sym-info type-symbol)]
          (either (and (= 1 (count type-nums))
                       (first (keys type-nums)))
                  UnknownType))
        (wrap sm/zero-sm UnknownType)))


(extend-type HashSet
  Emitter
  (encode-static [hs]
    (for [m (encode-static [(.set-map hs)])
          struct (global-var "set_")
          var (global-var "set_")]
      (comp m (c-static-val var []
                            ["ReifiedVal " struct " = {" (str (get-type hs))
                             ", -1, 1, (Value *)&" (.c-struct m) "};\n"
                             "Value *" var " = (Value *)&" struct ";" line-sep]
                            {} {} struct))))

  (emit [hs]
    (for [expr (encode (.set-map hs))
          var (genlocal "set_")]
      (-> expr
          (.c-var var)
          (.init (comp (.init expr) ["Value *" var " = newHashSet(empty_list, " (.c-var expr) ");" line-sep]))))))

(defn emit-tail-expr [ast result-constraint expr]
  ;; TODO: periodically enable this to check on things
  ;; (print-err 'check (some return-assertions assert-return-type) return-type
  ;;            (ast/file-name ast) (ast/line-number ast))
  (collapse-expressions [expr
                         (c-code (.c-var expr)
                                 ["return(" (.c-var expr) ");" line-sep]
                                 [] {(.c-var expr) 1}
                                 {(.c-var expr) result-constraint})]))

(deftype TailCall [ast params result-constraint]
  (assert (instance? Vector params))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) " " (string-list result-constraint) " "
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))

  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    ;; TODO: make sure this gernates good code
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (instance? Tagged (.call-target ast))))
                target (emit (.call-target ast))
                _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (remove (partial instance? ast/NoCode))
                         (ev/traverse emit))
                line (line-macro ast "// recursive-fixed")]
            (comp* empty-c-code (comp args
                                      [(c-code ""
                                               [line
                                                (map (zip-lists params (map args .c-var))
                                                     (fn [[param arg]]
                                                       [param " = " arg ";" line-sep]))]
                                               [] {} {})])))
          (map (emit ast)
               (fn [expr]
                 (let [expr (either (and (instance? Tagged ast)
                                         (maybe (.refs-map expr {})))
                                    expr)]
                   (emit-tail-expr ast result-constraint expr)))))))

(extend-type String
  Emitter
  (emit [str-val]
    (make-static-string str-val)))

(defn make-static-num [num]
  (comp (sm/get-in-val [.constants .numbers num])
        (for [num-idx (sm/new-sm (fn [s]
                                   (assert (instance? GlobalContext s))
                                   (-> s
                                       .constants
                                       .numbers
                                       count
                                       (vector s)
                                       maybe)))
              :let [num-sym (str "num" num-idx)
                    num-ptr (str "numPtr" num-idx)
                    constraint (c/StaticIntConstraint num empty-list nothing num-ptr)]
              _ (sm/assoc-in-val [.constants .numbers num]
                                 (c-static-int num-ptr [] [] {}
                                               {num-ptr constraint}
                                               num-sym))]
          (c-static-int num-ptr []
                        ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
                         "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
                        {} {num-ptr constraint}
                        num-sym))))

(extend-type Integer
  Emitter
  (emit [num]
    (make-static-num num)))

(extend-type ast/quoted-ast
  Emitter
  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)
                        constraint (c/update-path sym-constraint
                                                (ast/file-name ast) (ast/line-number ast))]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-static-sym sym-ptr [] [] {}
                                                   {sym-ptr constraint}
                                                   sym-var))]
              (c-static-sym sym-ptr
                            []
                            ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                             ", 0, 0, \"" sym "\"};\n"
                             "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                            {} {sym-ptr constraint} sym-var))))))


(def LiteralValues (comp ast/quoted-ast
                         ast/string-ast
                         ast/integer-ast
                         Integer
                         String))

(extend-type LiteralValues
  Emitter
  (encode-static [n]
    (emit n))

  (replace-syms [ast _]
    (wrap sm/zero-sm ast))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.decl [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint)))

(extend-type ast/string-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-string (.string ast))
          :let [expr (.constraints expr (assoc (.constraints expr)
                                          (.c-var expr) (-> expr
                                                            expr-constraints
                                                            (c/update-path (ast/file-name ast)
                                                                           (ast/line-number ast)))))]
          _ (sm/assoc-in-val [.constants .strings (.string ast)]
                             (-> expr
                                 (.init [])
                                 (.decl [])))]
      expr)))

(extend-type ast/integer-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-num (.int ast))
          :let [expr (.constraints expr (assoc (.constraints expr)
                                          (.c-var expr) (-> expr
                                                            expr-constraints
                                                            (c/update-path (ast/file-name ast)
                                                                           (ast/line-number ast)))))]
          _ (sm/assoc-in-val [.constants .numbers (.int ast)]
                             (-> expr
                                 (.init [])
                                 (.decl [])))]
      expr)))

(defn call-vector [target args]
  (assert (instance? Vector args))

  (for [vect-sym (genlocal "newVect")
        result-sym (genlocal "vect")
        line (line-macro target "// call-vector")]
    (let [file-name (ast/file-name target)
          line-number (ast/line-number target)
          arg-constraints (.constraints (collapse-expressions args))
          constraints (-> vect-constraint
                          (c/intersect (c/StaticLengthConstraint (count args)
                                                                 empty-list
                                                                 nothing
                                                                 result-sym))
                          (c/intersect (c/ItemsConstraint (map args (fn [arg]
                                                                      (either (get arg-constraints (.c-var arg))
                                                                              c/top-type)))
                                                          empty-list
                                                          nothing
                                                          result-sym)))
          constraints (c/update-path constraints file-name line-number)]
      (c-init result-sym
              [line
               "Vector *" vect-sym " = empty_vect;" line-sep
               (map args
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [vect-sym " = mutateVectConj(" vect-sym ", "
                         arg-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
              [] {}
              {result-sym constraints}
              file-name line-number))))

(defn call-list [target args]
  (assert (instance? Vector args))

  (for [line (line-macro target "// call-list")
        list-sym (genlocal "newList")
        result-sym (genlocal "list")]
    (let [file-name (ast/file-name target)
          line-number (ast/line-number target)
          arg-constraints (.constraints (collapse-expressions args))
          constraints (-> list-constraint
                          (c/intersect (c/StaticLengthConstraint (count args)
                                                                 empty-list
                                                                 nothing
                                                                 result-sym))
                          (c/intersect (c/ItemsConstraint (map args (fn [arg]
                                                                      (either (get arg-constraints (.c-var arg))
                                                                              c/top-type)))
                                                          empty-list
                                                          nothing
                                                          result-sym)))]
      (c-init result-sym
              [line "List *" list-sym " = empty_list;" line-sep
               (map (reverse args)
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [list-sym " = listCons(" "(Value *)" arg-sym
                         ", " list-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
              [] {}
              {result-sym (c/update-path constraints file-name line-number)}
              file-name line-number))))

(defn call-maybe [target [arg]]
  (for [line (line-macro target "// call-maybe")
        result-sym (genlocal "maybe")]
    (let [file-name (ast/file-name target)
          line-number (ast/line-number target)
          constraints (c/intersect maybe-constraint
                                   (either (= c/top-type (expr-constraints arg))
                                           (c/InferredInner (expr-constraints arg)
                                                              empty-list nothing result-sym)))]
      (c-init result-sym
              [line "Value *" result-sym " = (Value *)maybe((List *)0, (Value *)0, " (.c-var arg) ");" line-sep]
              [] {}
              {result-sym (c/update-path constraints file-name line-number)}
              file-name line-number))))

(defn arg-constraints [arg-asts arg-vars constraints file-name line-number]
  (assert (instance? c/ItemsConstraint constraints))

  (for [constraint-maps (ev/traverse (zip-lists (seq arg-asts)
                                                (seq arg-vars)
                                                (.items-constraints constraints))
                                     (fn [[ast var constraint]]
                                       (let [constraint (c/update-path constraint file-name line-number)
                                             constraints (c/update-path (expr-constraints var) file-name line-number)
                                             new-const (either (c/compose-constraints file-name line-number
                                                                                      constraint
                                                                                      constraints)
                                                               (abort))]
                                         (comp (for [_ (constrain-sym ast constraint)]
                                                 {(.c-var var) new-const})
                                               (wrap sm/zero-sm {(.c-var var) new-const})))))]
    (comp* {} constraint-maps)))

(defn add-contents-constraint [ast args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)
        target (.call-target ast)]
    (either (flat-map (or (and (or (= target 'conj)
                                   (= target 'store))
                               (= 2 (count args))
                               (maybe args))
                          (and (= target 'cons)
                               (= 2 (count args))
                               (maybe (reverse args)))
                          (and (= target 'assoc)
                               (= 3 (count args))
                               (let [[collection k v] args]
                                 ;; TODO: still to be implemented
                                 ;; (print-err 'assoc-key k)
                                 nothing)))
                      (fn [[collection contents]]
                        (or (= (expr-constraints contents) c/top-type)
                            (-> (c/ContentsConstraint (-> contents
                                                          expr-constraints
                                                          (c/update-path file-name line-number)
                                                          vector)
                                                      empty-list nothing "")
                                (c/update-path file-name line-number)
                                maybe))))
            c/top-type)))

(defn call-proto-impl [target disp-type args ast]
  (let [num-args (count args)]
    (for [impl-info (get-proto-impl target num-args disp-type)
          constraints (arg-constraints (.args ast) args (.param-constraints impl-info)
                                       (ast/file-name ast) (ast/line-number ast))
          _ (comp (sm/update-in-val [.constants .other 'type-known-sites] inc)
                  (sm/assoc-in-val [.constants .other 'type-known-sites] 1))
          result-var (genlocal "rslt")
          line (line-macro target (str "// call proto fn " target))]
      (constrain-expr (c-init result-var
                              [line "Value *" result-var " = " (.c-fn impl-info) "("
                               (interpose (list* "empty_list" (map args .c-var)) ", ")
                               ");" line-sep]
                              [] {}
                              (assoc constraints
                                result-var (.result-constraint impl-info))
                              (ast/file-name ast) (ast/line-number ast))
                      (add-contents-constraint ast args)))))

(defn inline-wrap-and-apply [name args]
  ;; TODO: this is subtly broken in replacing syms/bound-vars. It breaks on:
  ;; (for [name (list 1 2 3 4)
  ;;       :let [name (str name)]
  ;;       :when-not (= "." (subs name 0 1))]
  ;;   name)

  ;; (let [[dispatch-ast & arg-asts] args]
  ;;   (for [dispatch-val (emit dispatch-ast)
  ;;         impl-ast (map (get-proto-impl name (count args)
  ;;                                       (expr-type-num dispatch-val))
  ;;                       .ast)
  ;;         expr (-> impl-ast
  ;;                  (replace-bound-vars {})
  ;;                  (inline-expr (cons dispatch-val arg-asts)))]
  ;;     expr))
  sm/zero-sm
  )


(defn inline-flat-map [name args]
  (let [[dispatch-ast f-ast] args]
    (for [dispatch-val (emit dispatch-ast)
          :let [dispatch-type (expr-type-num dispatch-val)]
          :when-not (= UnknownType dispatch-type)
          impl-ast (map (get-proto-impl name 2 dispatch-type)
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (ev/traverse (.body impl-ast)
                                  (fn [ast]
                                    (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(extend-type Tagged
  Emitter
  (constrain-sym [sym constraint]
    (for [var (sm/get-in-val [.fn-context .syms sym])
          :let [constraint (-> (either (c/compose-constraints (ast/file-name sym) (ast/line-number sym)
                                                              constraint (expr-constraints var))
                                       (abort))
                               (c/update-var (str (.c-var var)))
                               (c/update-sym sym))]
          _ (set-sym sym (.constraints var (assoc (.constraints var)
                                             (.c-var var) constraint)))]
      constraint))

  (get-param-constraints [sym constraint-map]
    (for [expr (lookup-sym sym)]
      (-> (either (get constraint-map (.c-var expr))
                  c/top-type)
          (c/update-var (.c-var expr))
          (c/update-sym sym))))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] {arg-var 1} {})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                constraint (expr-constraints evalled)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] []
                                    {(.c-var evalled) 1}
                                    {(.c-var evalled) constraint})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [(c-init (.c-var evalled) (.init evalled) (.decl evalled)
                                     (.refs-map evalled)
                                     (.constraints evalled)
                                     (ast/file-name binding) (ast/line-number binding))]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (emit sym)
          _ (new-module-def defined-sym value)]
      [value]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (replace-syms [ast subs]
    (wrap sm/zero-sm (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (remove arg-asts (partial instance? ast/NoCode))
          num-args (count args)]
      (either (or (and (< 0 num-args)
                       (or (= name 'wrap)
                           (= name 'apply))
                       (maybe (inline-wrap-and-apply name args)))
                  (and (= 2 num-args)
                       (or (= name 'flat-map)
                           (= name 'map))
                       (maybe (inline-flat-map name args))))
              sm/zero-sm)))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))

(extend-type rdr/tagged-symbol
  Emitter
  (encode-static [x]
    (emit (ast/quoted-ast (.sym x)))))

(extend-type Symbol
  Emitter
  (encode-static [sym]
    (emit (ast/quoted-ast sym))))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          line-info (line-macro ast "// inline")
          :let [init [line-info (.txt ast) "\n#\n"]]
          type-num (get-type-number (.result-type ast))
          expr (either (and (= UnknownType type-num)
                            (maybe (wrap sm/zero-sm (c-code "" init [] {} {}))))
                       (for [c-var (genlocal "rslt")
                             constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))]
                         (c-code c-var init [] {} {c-var constraint})))]
      expr))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] [] {}
                                                {(str c-var) constraint}))
          line-info (line-macro ast "// inline")]
      [(c-code c-var [] [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"]
               {} {c-var constraint})]))

  (emit-definition [ast]
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] {} {})]))

  (tail-call [ast params result-constraint]
    ;; TODO: statically verify the return type, if possible
    ast)

  (replace-syms [ast _]
    (wrap sm/zero-sm ast)))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (ev/traverse (.value-exprs ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] {} {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              [(-> c-info
                   (.c-var "")
                   (.decl ["Value *" c-var ";\n"]))])))))

(extend-type StaticFnPtr
  Emitter
  (call-site-meta-data [v f l]
    (wrap sm/zero-sm (c-code "empty_list" [] [] {} {})))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'static-fixed-sites] inc)
          (sm/assoc-in-val [.constants .other 'static-fixed-sites] 1))))

(extend-type ProtoDispFnPtr
  Emitter
  (call-site-meta-data [_ file-name line-number]
    (let [str-val (str "at " file-name ": " line-number)]
      (map (make-static-string str-val)
           (fn [expr]
             (.c-var expr (str "(List *)" (.c-var expr)))))))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'proto-dispatch-sites] inc)
          (sm/assoc-in-val [.constants .other 'proto-dispatch-sites] 1))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arity-info arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [constraints (arg-constraints (.args ast) arg-vars (.param-constraints arity-info)
                                       file-name line-number)
          result-sym (genlocal "rslt")
          _ (update-call-site-count (.c-var arity-info))
          line (line-macro ast "// static-fixed")
          call-site-location (call-site-meta-data (.c-var arity-info) file-name line-number)]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (cons (.c-var call-site-location)
                                (seq (map arg-vars .c-var))) ", ") ");" line-sep]
              (.decl call-site-location)
              {} (assoc constraints
                   result-sym (c/update-path (.result-constraint arity-info)
                                             file-name line-number))
              file-name line-number))))

(defn call-static-variadic [target arity-info arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arg-consts (arg-constraints (.args ast) arg-vars (.param-constraints arity-info)
                                      file-name line-number)
          _ (comp (sm/update-in-val [.constants .other 'static-variadic-sites] inc)
                  (sm/assoc-in-val [.constants .other 'static-variadic-sites] 1))
          args-list (call-list (rdr/tag 'list file-name line-number)
                               (map arg-vars (fn [arg]
                                               (.init arg []))))
          result-sym (genlocal "rslt")
          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               line
               "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
               (.c-var args-list) ");" line-sep]
              [] {}
              (assoc-all arg-consts
                         (.c-var args-list) (either (c/compose-constraints file-name line-number
                                                                           (.param-constraints arity-info)
                                                                           (expr-constraints args-list))
                                                    (abort))
                         result-sym (.result-constraint arity-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn call-dyn-fn-value [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (expr-type-num target))
        _ (comp (sm/update-in-val [.constants .other 'dyn-fn-sites] inc)
                (sm/assoc-in-val [.constants .other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [args (map args .c-var)
          arg-syms (comp [(str arity-sym "->closures")] args)
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              [] {} {}
              (ast/file-name ast) (ast/line-number ast)))))

(def symbols-sym (symbol "#symbols"))
(def protocols-sym (symbol "#protocols"))
(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type 'core 0))
(def Function-sym (rdr/tag 'Function 'core 0))
(def Container-sym (rdr/tag 'Container 'core 0))
(def Stringable-sym (rdr/tag 'Stringable 'core 0))
(def type-name-sym (rdr/tag 'type-name))
(def type-mapping-sym (rdr/tag 'type-mapping))
(def =*-sym (rdr/tag '=*))
(def apply-sym (rdr/tag 'apply))
(def get-type-sym (rdr/tag 'reified-get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative 'core 0))
(def get-symb (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode 'core 0))
(def Hashable-sym (rdr/tag 'Hashable 'core 0))
(def sha1-sym (rdr/tag 'sha1))
(def sha1-update-sym (rdr/tag 'sha1-update))
(def sha1-init-sym (rdr/tag 'sha1-init))
(def sha1-finalize-sym (rdr/tag 'sha1-finalize))
(def sha1-update-type-sym (rdr/tag 'sha1-update-type))
(def assoc-sym (rdr/tag 'assoc))
(def update-field-sym (rdr/tag 'update-field))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def get-field-sym (rdr/tag 'get-field))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [num-args (count args)
        num-invoke-args (inc num-args)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (lookup-core-fn-arity invoke-sym num-invoke-args)
          _ (comp (sm/update-in-val [.constants .other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.constants .other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")
          sym-location (emit (either (= "\"\"" file-name)
                                     (str "\"at " file-name ": " line-number "\"")))]
      (let [args (map args .c-var)
            arg-syms (comp [(str arity-sym "->closures")] args)]
        (comp sym-location
              (c-init result-sym
                      [line "Value *" result-sym ";" line-sep
                       "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                       result-sym " = " invoke-arity-sym "("
                       (interpose (list* (str "(List *)" (.c-var sym-location))
                                         (.c-var target) args) ", ") ");"
                       line-sep "} else {" line-sep

                       "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                       "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                       "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                       line-sep
                       result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                       "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                       "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                       "List *" variadic-sym " = empty_list;" line-sep
                       (map (reverse (rest arg-syms))
                            (fn [arg-sym]
                              (str variadic-sym " = (List *)listCons("
                                   arg-sym ", " variadic-sym ");" line-sep)))
                       result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                       variadic-sym ");" line-sep
                       "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                       "((Function *)" (.c-var target) ")->name"
                       ");" line-sep "  abort();" line-sep "}" line-sep
                       "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                      [] {} {}
                      file-name line-number))))))

(defn call-invoke [target args ast]
  (let [num-args (inc (count args))
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)
        target-type (expr-type-num target)]
    (for [_ (sm/when-not (= UnknownType target-type))
          invoke-info (get-proto-impl Function-sym invoke-sym num-args target-type)
          _ (comp (sm/update-in-val [.constants .other 'invoke-sites] inc)
                  (sm/assoc-in-val [.constants .other 'invoke-sites] 1))
          constraints (arg-constraints (cons target (seq (.args ast)))
                                       (comp [target] args)
                                       (.param-constraints invoke-info)
                                       (ast/file-name ast) (ast/line-number ast))
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-fn invoke-info) "("
               (interpose (list* "empty_list" (.c-var target) (map args .c-var)) ", ")
               ");" line-sep]
              [] {} (assoc constraints
                      result-sym (.result-constraint invoke-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (remove (partial instance? ast/NoCode))
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse
                vec))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(defprotocol CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (call-dyn-fn-value target args ast)
          (call-dyn-unknown-type target args ast))))

(extend-type c-static-reified
  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(defn static-call-site [target args ast]
  (comp (for [fn-info (sm/get-in-val [.fns (.c-var target)])
              site (either (or (map (get fn-info (count args))
                                    (fn [arity-info]
                                      (call-static-fixed target arity-info args ast)))
                               (map (get fn-info 'variadic)
                                    (fn [arity-info]
                                      (call-static-variadic target arity-info args ast))))
                           sm/zero-sm)]
          (constrain-expr site (add-contents-constraint ast args)))
        (compilation-error "No arity with" (count args) "arguments found"
                           (either (map (instance? Tagged (.call-target ast))
                                        (fn [sym]
                                          (str "for '" sym "'")))
                                   "")
                           "at:" (ast/file-name ast) (ast/line-number ast))))

(extend-type c-maybe-fn
  CallSite
  (emit-call-site [target args ast]
    (call-maybe (.call-target ast) args)))

(extend-type c-list-fn
  CallSite
  (emit-call-site [target args ast]
    (call-list (.call-target ast) args)))

(extend-type c-vector-fn
  CallSite
  (emit-call-site [target args ast]
    (call-vector (.call-target ast) args)))

(extend-type c-static-fn
  CallSite
  (emit-call-site [target args ast]
    (static-call-site target args ast)))

;; TODO: test add-inner-constraint on state-maybe values
;; TODO: possible contenders to add; apply
;; TODO: Add contents constraint for conj, cons, store
;; TODO: add inner constraint to Strings
;; TODP: insert InferredInner into anon fn passed to higher order fn

(defn inner-constraint-for-reduce [ast args]
  (and (= (.call-target ast) 'reduce)
       (= 3 (count args))
       (let [[v initial-val f] args
             file-name (ast/file-name ast)
             line-number (ast/line-number ast)
             inner-const (either (for [info (get-in f [.arities 2])
                                            c (-> info
                                                  .param-constraints
                                                  .items-constraints
                                                  second)]
                                   (c/InferredInner c empty-list nothing ""))
                                 c/top-type)
             inner-const (-> inner-const
                             (c/update-path file-name line-number)
                             (c/update-var (.c-var v)))
             new-const (either (c/compose-constraints file-name line-number
                                                      inner-const
                                                      (expr-constraints v))
                               (abort))]
         (maybe [[(.constraints v (assoc (.constraints v)
                                    (.c-var v) new-const))
                  initial-val f]
                 c/top-type]))))

(def ignore-result-type #{'split-with 'filter 'drop-while 'take-while})

(defn add-inner-constraint [ast args]
  (or (inner-constraint-for-reduce ast args)
      (and (or (= (.call-target ast) 'map)
               (= (.call-target ast) 'flat-map)
               (ignore-result-type (.call-target ast)))
           (< 1 (count args))
           (let [[v f & args] args]
             (for [info (or (get-in f [.arities 1])
                            (get-in f [.arities 'variadic]))
                   inner-const (or (map (-> info
                                            .param-constraints
                                            .items-constraints
                                            first)
                                        (fn [c]
                                          (c/InferredInner c empty-list nothing "")))
                                   (maybe c/top-type))]
               (let [file-name (ast/file-name ast)
                     line-number (ast/line-number ast)
                     rc (.result-constraint info)
                     inner-const (-> inner-const
                                     (c/update-path file-name line-number)
                                     (c/update-var (.c-var v)))
                     new-const (either (c/compose-constraints file-name line-number
                                                              inner-const
                                                              (expr-constraints v))
                                       (abort))]
                 [(list* (.constraints v (assoc (.constraints v)
                                           (.c-var v) new-const))
                         f args)
                  (either (or (and (ignore-result-type (.call-target ast))
                                   (maybe c/top-type))
                              (and (= (.call-target ast) 'flat-map)
                                   (maybe rc)))
                          (-> (c/InferredInner rc empty-list nothing "")
                              (c/update-path file-name line-number)))]))))))

(def returns-collection #{'seq 'vec 'rest 'butlast 'reverse 'last 'nth 'get 'vals})

(defn propogate-inner-constraint [ast args]
  (for [arg (first args)
        :let [arg-const (expr-constraints arg)]
        :when-not (= c/top-type arg-const)
        result (or (and (returns-collection (.call-target ast))
                        (maybe [args (c/extract-inner-constraint arg-const)]))
                   ;; TODO: test this when the KeyConstraint is done
                   (for [_ (= (.call-target ast) 'hash-seq)
                         inner-const (get (c/extract-inner-constraint arg-const) .inner)
                         :when-not (= c/top-type inner-const)]
                     [args (c/ItemsConstraint [c/top-type ;; TODO: update this when KeyConstraint is done
                                               inner-const]
                                              empty-list
                                              nothing
                                              "")])
                   (for [_ (= (.call-target ast) 'extract)
                         inner-const (get (c/extract-inner-constraint arg-const) .inner)
                         :when-not (= c/top-type inner-const)]
                     [args inner-const])
                   (and (= (.call-target ast) 'first)
                        (or (map (first (c/extract-items-constraints arg-const))
                                 (fn [const]
                                   [args (c/InferredInner const
                                                            (list [(ast/file-name ast) (ast/line-number ast)])
                                                            nothing "")]))
                            (maybe [args (c/extract-inner-constraint arg-const)]))))]
    result))

(extend-type c-protocol-fn
  CallSite
  (emit-call-site [target args ast]
    (let [[args result-c] (either (or (add-inner-constraint ast args)
                                      (propogate-inner-constraint ast args))
                                  [args c/top-type])]
      (map (either (for [dispatch-val (first args)
                         :let [disp-type (expr-type-num dispatch-val)]
                         :when-not (= UnknownType disp-type)]
                     (comp (call-proto-impl (.call-target ast) disp-type args ast)
                           (static-call-site target args ast)))
                   (static-call-site target args ast))
           (fn [r]
             (let [file-name (ast/file-name ast)
                   line-number (ast/line-number ast)
                   result-c (either (and (= (.call-target ast) 'wrap)
                                         (let [[_ wrapped] args]
                                           (-> wrapped
                                               expr-constraints
                                               (c/InferredInner empty-list nothing "")
                                               (c/update-path file-name line-number)
                                               maybe)))
                                    result-c)
                   result-c (either (c/compose-constraints file-name line-number
                                                           (c/update-var result-c (.c-var r))
                                                           (-> r
                                                               expr-constraints
                                                               (c/update-path file-name line-number)))
                                    (abort))]
               (.constraints r (assoc (.constraints r)
                                 (.c-var r) result-c))))))))

(defn define-sum-type [fn-val defined-sym]
  (either (map (= (.call-target fn-val) 'comp*)
               (fn [_]
                 (let [[type-sym type-syms] (.args fn-val)
                       type-syms (cons type-sym (seq (.args type-syms)))
                       file-name (ast/file-name defined-sym)
                       line-number (ast/line-number defined-sym)]
                   (for [types-info (ev/traverse type-syms get-type-sym-info)
                         :when-not (empty? (remove types-info empty?))
                         :let [_ (map (zip-lists type-syms types-info)
                                      (fn [[sym info]]
                                        (and (empty? info)
                                             (do
                                               (print-err "Unknown type" (str "'" sym "'") "at"
                                                          (str file-name ":") line-number)
                                               (maybe (abort))))))
                               types-info (reduce types-info {} comp)
                               reified-type-num (extract rdr/type-counter)
                               x* (rdr/tag "#x")
                               y* (rdr/tag "#y")]
                         _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                                            reified-type-num)
                         _ (sm/assoc-in-val [.type-maps reified-type-num] (TypeInfo defined-sym types-info))
                         exprs (emit-defined-value
                                (ast/reified
                                 reified-type-num
                                 {Type-sym
                                  [[instance?-sym
                                    [(ast/fn-arity-ast
                                      (str defined-sym "_instance_QMARK_") (FnValPtr "")
                                      (ast/params [x* y*]) ""
                                      [(ast/and-ast
                                        [(ast/call-ast (rdr/tag 'some)
                                                       [(ast/call-ast list-sym (vec (keys types-info)))
                                                        (ast/call-ast (rdr/tag 'partial)
                                                                      [=*-sym
                                                                       (ast/call-ast get-type-sym [y*])])])
                                         (ast/call-ast maybe-sym [y*])])]
                                      [] c/top-type)]]

                                   [type-mapping-sym
                                    [(ast/fn-arity-ast
                                      (str defined-sym "_type_mapping") (FnValPtr "")
                                      (ast/params [x*]) ""
                                      [(map-vals types-info (fn [field-set]
                                                              (map field-set ast/quoted-ast)))]
                                      [] c/top-type)]]]

                                  Stringable-sym
                                  [[string-list-sym
                                    [(ast/fn-arity (ast/params [x*]) ""
                                                   [(ast/call-ast list-sym ["<SumType " (str defined-sym) ">"])])]]]})
                                defined-sym)]
                     exprs))))
          sm/zero-sm))

(defn define-enum-type [fn-val defined-sym]
  (for [_ (sm/when (= (.call-target fn-val) 'enum))
        type-maps (comp (ev/traverse (.args fn-val)
                                     (fn [sym]
                                       (comp (flat-map (sm/get-in-val [.modules (ast/file-name sym) .types sym])
                                                       (fn [_]
                                                         (compilation-error "Invalid enum value " (str "'" sym "'")
                                                                            " at:" (ast/file-name defined-sym)
                                                                            (ast/line-number defined-sym))))
                                             (for [expr (comp (find-global-sym sym)
                                                              (compilation-error "Invalid enum value " (str "'" sym "'")
                                                                                 " at:" (ast/file-name defined-sym)
                                                                                 (ast/line-number defined-sym)))
                                                   :when (instance? c-static-reified expr)
                                                   type-map (sm/when (-> expr
                                                                         expr-constraints
                                                                         c/extract-type-map))]
                                               type-map))))
                        (compilation-error "Invalid enum values at:"
                                           (ast/file-name defined-sym) (ast/line-number defined-sym)))
        :let [type-map (comp* {} type-maps)
              reified-type-num (extract rdr/type-counter)
              x* (rdr/tag "#x")
              y* (rdr/tag "#y")]
        _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                           reified-type-num)
        _ (sm/assoc-in-val [.type-maps reified-type-num]
                           (TypeInfo defined-sym type-map))
        exprs (emit-defined-value
               (ast/reified
                reified-type-num
                {Type-sym
                 [[instance?-sym
                   [(ast/fn-arity-ast
                     (str defined-sym "_instance_QMARK_") (FnValPtr "")
                     (ast/params [x* y*]) ""
                     [(ast/and-ast
                       [(ast/call-ast (rdr/tag 'some)
                                      [(ast/call-ast list-sym (vec (keys type-map)))
                                       (ast/call-ast (rdr/tag 'partial)
                                                     [=*-sym (ast/call-ast get-type-sym [y*])])])
                        (ast/call-ast maybe-sym [y*])])]
                     [] c/top-type)]]

                  [type-mapping-sym
                   [(ast/fn-arity-ast
                     (str defined-sym "_type_mapping") (FnValPtr "")
                     (ast/params [x*]) ""
                     [(map-vals type-map (fn [field-set]
                                           (map field-set ast/quoted-ast)))]
                     [] c/top-type)]]]

                 Stringable-sym
                 [[string-list-sym
                   [(ast/fn-arity (ast/params ['z]) ""
                                  [(ast/call-ast list-sym
                                                 ["<SumType " (str defined-sym) ">"])])]]]})
               defined-sym)]
    exprs))

(extend-type ast/call-ast
  Emitter
  (emit-defined-value [fn-val defined-sym]
    (comp (define-sum-type fn-val defined-sym)
          (define-enum-type fn-val defined-sym)
          (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
                fn-context (reset-fn-context init-fn-context)
                value (emit fn-val)
                var (comp (map (lookup-declaration defined-sym) .c-var)
                          (global-var defined-sym "var"))
                init-fn-context (reset-fn-context fn-context)
                _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
                _ (new-module-def defined-sym (c-code var [] [] {}
                                                      {var (c/update-var (expr-constraints value) var)}))]
            [(c-init var [(.init value)
                          var " = " (.c-var value) ";" line-sep
                          var "->refs = -1;" line-sep "\n#\n"]
                     [(.decl value) "Value *" var ";\n"]
                     (.refs-map value)
                     (assoc (.constraints value)
                       var (c/update-var (expr-constraints value) var))
                     (ast/file-name fn-val) (ast/line-number fn-val))])))

  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    (either (and (instance? Symbol target-ast)
                                                 (maybe (rdr/tag target-ast)))
                                            target-ast))))]
      ;; TODO: re-enable inlining
      (comp (for [_ sm/zero-sm
                  new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.refs-map call-site)
                      (.constraints call-site)
                      (ast/file-name ast) (ast/line-number ast)))
            (flat-map (-> (.args ast)
                          (remove (partial instance? ast/NoCode))
                          (ev/traverse emit))
                      (fn [args]
                        (comp (for [target (emit (.call-target ast))
                                    call-site (emit-call-site target args ast)]
                                (comp* target (comp args [call-site])))
                              (compilation-error "Could not compile call site at:"
                                                 file-name line-number)))))))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (ev/traverse (.args ast) (fn [ast]
                                          (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= (.call-target ast) 'new-sm))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))

  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? Vector l))
    [ast]))

(extend-type C-expr
  C-Code
  (expr-constraints [expr]
    (either (map (get (.constraints expr) (.c-var expr))
                 (fn [const]
                   (either (map (instance? c/ResultConstraint const) .assertion)
                           const)))
            c/top-type))

  (constrain-expr [expr constraint]
    (let [new-constraint (either (c/compose-constraints "" 0
                                                        constraint
                                                        (expr-constraints expr))
                                 (abort))
          new-constraints (-> (.constraints expr)
                              (dissoc (.c-var expr))
                              (assoc (.c-var expr) new-constraint))]
      (.constraints expr new-constraints)))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x))

  (bind-list [list-var params]
    (let [file-name (ast/file-name params)
          line-num (ast/line-number params)
          list-constraint (c/update-path list-constraint file-name line-num)
          fixed-count (count (.fixed params))
          tail-sym (either (.variadic params)
                           (rdr/tag "#tail"))
          items-constraints (-> (expr-constraints list-var)
                                c/extract-items-constraints
                                (comp (repeat fixed-count c/top-type))
                                (take fixed-count))
          list-var (.refs-map list-var (dissoc (.refs-map list-var) (.c-var list-var)))]
      (for [tail-binding (bind tail-sym)
            _ (comp (sm/when (empty? (.init list-var)))
                    (set-sym (.c-var list-var) list-var))
            _ (constrain-sym tail-sym list-constraint)
            :let [tail-var (-> tail-binding .vars first extract)]
            r (comp (sm/when (and (= 0 fixed-count)
                                  (maybe (ParamBinding [(.c-var list-var)]
                                                       [list-var
                                                        (c-init tail-var ["Value *" tail-var " = seq(empty_list, "
                                                                          (.c-var list-var) ");" line-sep]
                                                                [] {(.c-var list-var) 1}
                                                                {tail-var list-constraint}
                                                                file-name line-num)]))))
                    (for [dest-args (genlocal "destArgs")
                          fixed-bindings (ev/traverse (.fixed params) bind)
                          _ (ev/traverse (zip-lists (.fixed params)
                                                    (seq items-constraints))
                                         (fn [[sym expr]]
                                           (constrain-sym sym expr)))
                          :let [fixed-vars (flat-map fixed-bindings .vars)
                                fixed-exprs (map (zip-lists fixed-vars
                                                            (seq items-constraints))
                                                 (fn [[var const]]
                                                   (c-init var [] [] {} {var const}
                                                           file-name line-num)))
                                tail-expr (c-init tail-var [] [] {} {tail-var list-constraint}
                                                  file-name line-num)]
                          _ (ev/traverse fixed-exprs
                                         (fn [expr]
                                           (set-sym (.c-var expr) expr)))
                          _ (set-sym tail-var tail-expr)]
                      (ParamBinding [(.c-var list-var)]
                                    (comp [list-var
                                           (c-code ""
                                                   ;; TODO: remove call to 'str' for the c-var
                                                   (destruct-seq (str (.c-var list-var))
                                                                 (conj fixed-vars tail-var)
                                                                 (str dest-args) file-name line-num)
                                                   [] {(.c-var list-var) 1} {})]
                                          (conj fixed-exprs tail-expr)
                                          (flat-map fixed-bindings .destruct)
                                          (.destruct tail-binding)))))]
        r))))

(extend-type ast/params-ast
  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  Emitter
  (get-param-constraints [params constraint-map]
    (map (ev/traverse (.fixed params) (fn [param]
                                        (get-param-constraints param constraint-map)))
         (fn [items-constraints]
           (-> (c/ItemsConstraint [] empty-list nothing "")
               (c/update-path (ast/file-name params) (ast/line-number params))
               (.items-constraints items-constraints)))))

  (bind [params]
    (for [param-var (genlocal "arg")
          destruct (bind-list (c-code param-var [] [] {} {})
                              params)]
      destruct))

  (bind [params evalled]
    (bind-list evalled params))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (for [val-var (emit (.val ast))
          bound-var (bind (.binding ast) val-var)]
      bound-var)))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals get-syms
          bindings (ev/traverse (.bindings ast) emit)
          body-exprs (ev/traverse (.body ast) emit)
          :let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
          result-var (either (map (= "" (.c-var code)) sm/state-maybe)
                             (genlocal "let_rslt"))
          moar-constraints (ev/traverse (zip-lists (.bindings ast) bindings)
                                        (fn [[binding-ast param-binding]]
                                          (for [binding-constraint (get-param-constraints (.binding binding-ast)
                                                                                          (.constraints code))]
                                            (either (and (instance? c/ItemsConstraint binding-constraint)
                                                         (let [[var] (.vars param-binding)]
                                                           (maybe {var binding-constraint})))
                                                    {}))))
          even-moar (ev/traverse (.bindings ast)
                                 (fn [binding]
                                   (either (and (instance? Tagged (.val binding))
                                                (instance? Tagged (.binding binding))
                                                (maybe (for [val (lookup-sym (.val binding))
                                                             bound (lookup-sym (.binding binding))]
                                                         (either (map (get (.constraints code) (.c-var bound))
                                                                      (fn [const]
                                                                        {(.c-var val) const}))
                                                                 {}))))
                                           (wrap sm/zero-sm {}))))
          _ (set-syms locals)]
      (let [constraints (reduce (comp moar-constraints even-moar)
                                (.constraints code)
                                (fn [m1 m2]
                                  (merge-constraint-maps (ast/file-name ast) (ast/line-number ast)
                                                         m1 m2)))]
        (c-init result-var
                [(.init code)
                 (either (= "" result-var)
                         [line-sep "Value *" result-var " = " (.c-var code) ";" line-sep])]
                (.decl code) (.refs-map code)
                (assoc constraints result-var (expr-constraints code))
                (ast/file-name ast) (ast/line-number ast)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] {}
                                                {var (expr-constraints value)}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               [(.decl value) "Value *" var ";\n"]
               (.refs-map value)
               {var (expr-constraints value)}
               (ast/file-name ast) (ast/line-number ast))]))

  (tail-call [ast params result-constraint]
    (.body ast (-> ast
                   .body
                   (remove (partial instance? ast/NoCode))
                   (tail-call params result-constraint))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (wrap sm/zero-sm new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (wrap sm/zero-sm))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (rdr/tag (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body))))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns file-name line-number]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = " (count impl-fns) ";" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (map impl-fns .decl)
              (apply merge-with (list* + (map impl-fns .refs-map)))
              {reified-sym (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>") nothing
                                           reified-sym)}
              file-name line-number))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-static-reified reified-ptr
                      []
                      [(map impl-fns .decl)
                       "ReifiedVal " reified-sym " = {"
                       type-num ", -1, "
                       ;; TODO: this should be the impl-fns's .c-structs
                       "0, {}};" line-sep
                       "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
                      {} {reified-ptr (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>")
                                                      nothing (str reified-ptr))}
                      reified-sym)))

(defprotocol ArityType
  (closure-arity? [_]
    (assert-result x (instance? Maybe x))
    nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (assert-result x (instance? sm/new-sm x))))

(defn new-static-arity
  ([fn-ptr num-params arity-var result-constraint]
   (assert (instance? FnValPtr fn-ptr))
   (assert (instance? c/ValueConstraint result-constraint))
   (assert (instance? CFnPtr arity-var))

   (new-static-arity fn-ptr num-params arity-var result-constraint c/empty-items-constraint))

  ([fn-ptr num-params arity-var result-constraint param-constraints]
   (assert (instance? FnValPtr fn-ptr))
   (assert (instance? c/ValueConstraint result-constraint))
   (assert (instance? CFnPtr arity-var))

   (sm/assoc-in-val [.fns fn-ptr num-params]
                    (StaticArityInfo arity-var param-constraints result-constraint))))

(deftype StaticArity [arity-fn-var c-fn param-count var-info param-constraints result-constraint]
  (assert (instance? FnValPtr arity-fn-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))

  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info) " " (str result-constraint) ">"))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (for [_ (new-proto-impl proto-sym fn-name param-count dispatch-type-num (.c-var var-info) arity-ast
                            param-constraints result-constraint c-fn)]
      var-info)))

(deftype ClosureArity [arity-fn-var params param-count var-info param-constraints result-constraint]
  (assert (instance? CFnPtr arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ValueConstraint result-constraint))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))

  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (ev/traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num
                              (ArityValPtr (str "&" fn-arity-sym) fn-arity-sym) arity-ast
                              c/empty-items-constraint result-constraint
                              (StaticFnPtr (str impl-fn-sym)))
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                                  ")->impls[" reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym ", (Value *)0, (Value *)0};" line-sep]
                                 {} {})]
          (comp reified-fn var-info))))))

(defn checking-fn [fn-sym params param-vars arity-fn-var constraints]
  (let [file-name (ast/file-name params)
        line-number (ast/line-number params)
        constraints-list (.items-constraints constraints)]
    (for [dest-args (genlocal "destArgs")
          checking-fn-var (global-var fn-sym "paramChecker")
          line (line-macro fn-sym "// paramChecker")]
      (either (or (and (.variadic params)
                       (maybe (c-code checking-fn-var
                                      ["Value *" checking-fn-var
                                       "(List *closures, Value *args) {\n"
                                       line
                                       (destruct-seq "args" (.vars param-vars)
                                                     (str dest-args) file-name line-number)
                                       "return(" arity-fn-var
                                       "(closures, args));\n};\n"]
                                      [] {} {})))
                  (and (every constraints-list (partial = c/top-type))
                       (maybe (c-code arity-fn-var [] [] {} {}))))
              (c-code checking-fn-var
                      ["Value *" checking-fn-var "("
                       (-> (.vars param-vars)
                           (map (fn [param] (str "Value *" param)))
                           (seq)
                           (conj "List *closures")
                           (interpose ", "))
                       ") {\n"
                       (for [[constraint var] (zip-lists constraints-list
                                                         (.vars param-vars))]
                         (-> constraint
                             (c/update-var var)
                             (runtime-check c/top-type file-name line-number)))
                       "return(" arity-fn-var "("
                       (-> (.vars param-vars)
                           (seq)
                           (conj "closures")
                           (interpose ", "))
                       "));\n};\n"]
                      [] {} {})))))

(defn destruct-closures [closure-info]
  (for [destArgs (genlocal "destArgs")]
    (let [closures (-> closure-info
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)]
      (cons (c-code ""
                    [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                     "incRef((Value *)closures, 1);" line-sep
                     "Value **" destArgs "[" closure-count "] = {"
                     (interpose (map closures (fn [arg] ["&" arg])) ", ")
                     "};" line-sep
                     "destructValue(\"\", \"\", (Value *)closures"
                     ", " closure-count ", " destArgs ");" line-sep]
                    [] {} {})
            (map (seq closure-info)
                 (fn [[arg _ constraint]]
                   (c-init arg [] [] {} {arg constraint} "" 0)))))))

(defn emit-closure-arity [fn-sym fn-context c-fn params param-vars body-exprs]
  (assert (instance? CFnPtr c-fn))

  (for [closures (sm/new-sm (fn [s]
                              (assert (instance? GlobalContext s))
                              (let [closures (-> s .fn-context .closed-over .closures)]
                                (and (first closures)
                                     (maybe [closures s])))))
        closures-destruct (destruct-closures closures)
        :let [body (collapse-expressions (comp (.destruct param-vars)
                                               closures-destruct
                                               body-exprs))
              closure-constraints (.constraints body)]
        param-constraints (get-param-constraints params closure-constraints)
        _ (reset-fn-context fn-context)
        arity-var (genlocal fn-sym "dynArity")
        closure-vars (ev/traverse closures (fn [[closed-over sym]]
                                             (for [closure (lookup-sym sym)]
                                               (let [new-constraint (either (get closure-constraints closed-over)
                                                                            c/top-type)]
                                                 (c-code ""
                                                         [arity-var "->closures = listCons((Value *)"
                                                          (.c-var closure) ", (List *)" arity-var
                                                          "->closures);" line-sep]
                                                         [] {(.c-var closure) 1}
                                                         {arity-var (c/update-var list-constraint (str (.c-var closure)))
                                                          (.c-var closure) new-constraint})))))]
    (let [file-name (ast/file-name fn-sym)
          line-number (ast/line-number fn-sym)
          param-constraints (c/update-path param-constraints file-name line-number)
          result-constraint (expr-constraints body)
          arity-decl [(.decl body)
                      "Value *" c-fn "("
                      (-> (.vars param-vars)
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\n"
                      "\nwhile (1) {\n"
                      (for [[constraint var] (zip-lists (.items-constraints param-constraints)
                                                        (.vars param-vars))]
                        (-> constraint
                            (c/update-var var)
                            (runtime-check c/top-type file-name line-number)))
                      (.init body)
                      line-sep "};};\n"]
          arity-init ["FnArity *" arity-var
                      " = malloc_fnArity();" line-sep
                      arity-var "->count = " (count (.vars param-vars))
                      ";" line-sep
                      arity-var "->variadic = "
                      (either (and (.variadic params)
                                   (maybe "1"))
                              "0")
                      ";" line-sep
                      arity-var "->fn = " c-fn ";" line-sep
                      arity-var "->closures = empty_list;" line-sep]]
      (ClosureArity c-fn params (either (and (.variadic params)
                                             (maybe'variadic))
                                        (count params))
                    (.constraints (comp* (c-code arity-var arity-init arity-decl {} {})
                                         (comp closure-vars
                                               [(c-init arity-var [] [] {} {}
                                                        file-name line-number)]))
                                  {})
                    param-constraints
                    (either (map (instance? c/ResultConstraint result-constraint) .assertion)
                            result-constraint)))))

(defn emit-static-arity [fn-sym fn-context fn-var c-fn params param-vars result-constraint body-exprs]
  (assert (instance? FnValPtr fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? ParamBinding param-vars))
  (assert (instance? CFnPtr c-fn))

  (let [body (collapse-expressions (comp (.destruct param-vars) body-exprs))
        result-constraint (expr-constraints body)]
    (for [arity-var (global-var fn-sym "staticArity")
          param-constraints (get-param-constraints params (.constraints body))
          checker-fn (checking-fn fn-sym params param-vars c-fn param-constraints)
          _ (reset-fn-context fn-context)]
      (let [expr (c-static-arity (ArityValPtr (str "&" arity-var) arity-var) []
                                 [(.decl body)
                                  "Value *" c-fn "("
                                  (-> (.vars param-vars)
                                      (map (fn [param] (str "Value *" param)))
                                      (seq)
                                      (conj "List *closures")
                                      (interpose ", "))
                                  ") {\nwhile (1) {\n"
                                  (.init body)
                                  line-sep "};};\n"
                                  (.init checker-fn)
                                  "FnArity " arity-var " = {FnArityType, -1, "
                                  (count (.vars param-vars))
                                  ", (List *)0, " (either (and (.variadic params)
                                                               (maybe "1"))
                                                          "0")
                                  ", " (.c-var checker-fn) ", (Value *)0, (Value *)0};" line-sep]
                                 {} {} arity-var)]
        ;; TODO: use this to eliminate unknown return type values
        ;; (and (= UnknownType result-type)
        ;;      (maybe (print-err 'unknown-return-type fn-sym
        ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
        (StaticArity fn-var c-fn (either (and (.variadic params)
                                              (maybe'variadic))
                                         (count params))
                     expr
                     param-constraints
                     (either (map (instance? c/ResultConstraint result-constraint) .assertion)
                             result-constraint))))))

(defn bind-params [params fn-var]
  (assert (instance? ast/params-ast params))

  (comp (for [_ (sm/when (.variadic params))
              param-var (genlocal "arg")
              destruct (bind-list (c-code param-var [] [] {} {}) params)]
          destruct)
        (for [vars (ev/traverse (.fixed params) bind)
              :when-not (empty? vars)
              _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] '_)]
          (let [[var & vars] vars
                param-vars (comp* var vars)]
            (ParamBinding (.vars param-vars)
                          (comp (map (.vars param-vars)
                                     (fn [var]
                                       (c-param var [] [] {} {}
                                                (ast/file-name params) (ast/line-number params))))
                                (.destruct param-vars)))))
        (for [_ (sm/assoc-in-val [.fn-context .recurse fn-var 0] '_)]
          (ParamBinding [] []))))

(defn emit-fn-arity
  ([fn-sym fn-var params body]
   (assert (instance? FnValPtr fn-var))

   (flat-map (global-var fn-sym "arityImpl")
             (fn [c-fn]
               (emit-fn-arity fn-sym fn-var params body (StaticFnPtr c-fn)))))

  ([fn-sym fn-var params body c-fn]
   (assert (instance? FnValPtr fn-var))
   (assert (instance? CFnPtr c-fn))
   (assert (min-count body 1))

   (either (and (empty? (remove body (partial instance? ast/NoCode)))
                (maybe sm/zero-sm))
           (let [file-name (ast/file-name body)
                 line-number (ast/line-number body)
                 param-asserts (filter body (partial instance? c/SymbolConstraints))
                 fn-sym (rdr/tag fn-sym file-name line-number)]
             (for [fn-context (reset-fn-context)
                   ;; _ (debug (ast/file-name fn-sym) (ast/line-number fn-sym) 'fn-arity fn-sym)
                   result-constraints (-> body
                                          (filter (partial instance? c/ResultConstraint))
                                          (map .assertion)
                                          (ev/traverse to-constraint))
                   :let [result-constraint (let [result-type (c/update-sym
                                                              (reduce result-constraints c/top-type c/intersect)
                                                              "<result value>")]
                                             (and (= c/bottom-type result-type)
                                                  (do
                                                    (apply print-err
                                                           (list* "Conflicting result assertions"
                                                                  (either (= "" file-name)
                                                                          (str " at " file-name ": "
                                                                               line-number))
                                                                  "\n"
                                                                  (c/format-path result-type 0)))
                                                    (maybe (abort))))
                                             result-type)]
                   syms get-syms
                   _ (either (map (get syms fn-sym) sm/state-maybe)
                             (set-sym fn-sym (c-code fn-var [] [] {}
                                                     {fn-var fn-constraint})))
                   param-vars (bind-params params fn-var)
                   :let [param-vars (either (and (some body (partial instance? ast/inline-ast))
                                                 (maybe (.destruct param-vars [])))
                                            param-vars)]
                   body-exprs (-> body
                                  (remove (partial instance? ast/NoCode))
                                  ((fn [body] (comp param-asserts body)))
                                  (tail-call (.vars param-vars) result-constraint)
                                  (ev/traverse emit))
                   arity-info (comp (emit-closure-arity fn-sym fn-context c-fn params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context fn-var c-fn params
                                                       param-vars result-constraint body-exprs))
                   ;; _ (debug "============")
                   ]
               arity-info)))))

(deftype ProtoImplDeclaration [proto-sym fn-name arity-ast arity-var c-fn c-decl]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-name))
  (assert (instance? ArityValPtr arity-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/fn-arity-ast arity-ast))
  (assert (instance? Vector c-decl))

  Stringable
  (string-list [_]
    (list "<ProtoImplDeclaration " (str proto-sym) " " (str fn-name) ">")))

(defn declare-impl [type-str type-num [proto-sym fn-name arity-ast]]
  (assert (instance? Integer type-num))

  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (global-var (str type-str fn-name) "arityImpl")
          c-fn (global-var (str type-str fn-name) "arityFn")
          :let [impl-fn-var (FnValPtr impl-fn-var)
                arity-impl-var (ArityValPtr arity-impl-var "")
                c-fn (ProtoDispFnPtr c-fn)]
          dispatcher-info (get-proto-impl proto-sym fn-name num-args 0)
          :let [sym-map (reduce (zip-lists (-> dispatcher-info .ast .params .fixed)
                                           (-> arity-ast .params .fixed))
                                {} (fn [m [old-sym new-sym]]
                                     (assoc m old-sym new-sym)))
                result-assertions (-> dispatcher-info
                                      .ast
                                      .body
                                      (filter (partial instance? c/ResultConstraint)))]
          param-assertions (-> dispatcher-info
                               .ast
                               .body
                               (filter (partial instance? c/SymbolConstraints))
                               (ev/traverse (fn [ast]
                                              (replace-syms ast sym-map))))
          :let [arity-ast (.body arity-ast (comp [] param-assertions result-assertions (.body arity-ast)))]
          _ (new-static-arity impl-fn-var num-args c-fn
                              (.result-constraint dispatcher-info))
          _ (new-proto-impl proto-sym fn-name num-args type-num arity-impl-var arity-ast
                            c/empty-items-constraint
                            (.result-constraint dispatcher-info) c-fn)]
      (ProtoImplDeclaration proto-sym fn-name
                            arity-ast
                            arity-impl-var c-fn
                            ["Value *" c-fn "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"
                             "FnArity *" arity-impl-var ";\n"]))))

(defn update-param-constraint [constraint sym]
  ;; (assert (instance? c/Constraints constraint))
  (-> constraint
      (c/update-path (ast/file-name sym) (ast/line-number sym))
      (c/update-sym sym)))

(defn emit-impl [type-str type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))

  ;; TODO: use function pointers for impl fns.
  ;; this allows for redefining the impl if some extends a type and overwrites a
  ;; previvously defined impl
  (let [[proto-sym fn-sym arity-ast arity-var c-fn] (type-args impl-decl)
        params (.params arity-ast)
        [disp-param] (.fixed params)
        num-args (count params)
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [
          ;; _ (debug 'impl file-name line-number type-str fn-sym num-args)
          default-impl (get-proto-impl fn-sym num-args 0)
          disp-constraint (comp (for [_ (sm/get-in-val [.constants .type-names type-num])
                                      ;; TODO: this needs to be factored out
                                      ;; also, this should not be a type-constraint, it should only set
                                      ;; the type of the first parameter
                                      constraint (type-constraint type-num file-name line-number)]
                                  (update-param-constraint constraint disp-param))
                                (wrap sm/zero-sm c/top-type))
          ext-fn (comp (emit-fn-arity (rdr/tag (str type-str fn-sym))
                                      (.fn-var arity-ast)
                                      params
                                      (comp [disp-constraint
                                             (c/ResultConstraint (.result-constraint default-impl))]
                                            (.body arity-ast))
                                      c-fn)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-sym "' in")
                                          (str file-name ",") line-number))
          reified (reify-arity ext-fn type-num arity-ast fn-sym proto-sym)
          ;; _ (debug "---------")
          ]
      (-> reified
          (.c-var arity-var)
          (.init (either (or (empty? (.init reified))
                             (and (instance? StaticArity ext-fn)
                                  (maybe (.init reified))))
                         [(.init reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))
          (.decl (either (or (empty? (.decl reified))
                             (and (instance? ClosureArity ext-fn)
                                  (maybe (.decl reified))))
                         [(.decl reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))))))

(defn extend-type* [ast type-num]
  (assert (instance? Integer type-num))
  (let [impl-arities (for [[proto-sym impl-fns] (seq (.impls ast))
                           [fn-name arities] (seq impl-fns)
                           impl-arity arities]
                       [proto-sym fn-name (.fn-var impl-arity (FnValPtr (str (.fn-var impl-arity))))])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (wrap sm/zero-sm (str "_" type-num "_")))
                _ (ev/traverse (keys (.impls ast))
                               (fn [protocol-name]
                                 (comp (get-protocol protocol-name)
                                       (compilation-error "Invalid protocol:" protocol-name "in"
                                                          (str (ast/file-name ast) ",")
                                                          (ast/line-number protocol-name)))))
                ;; TODO: make sure the proto-name/fn-name exists
                ;; especially that the fn-name doesn't exist in a different proto-name
                impl-arities (ev/traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (ev/traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (either (map (every impl-fns (partial instance? c-static-arity))
                                        (fn [_]
                                          (static-reified-value reified-type-num impl-fns)))
                                 (closure-reified-value reified-type-num impl-fns
                                                        (ast/file-name ast) (ast/line-number ast)))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-static-reified (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                               (.c-var value) ";" line-sep]
                                               (.decl value) (.refs-map value)
                                               {(.c-var value) (expr-constraints value)}
                                               (.c-struct value))))
                      (wrap sm/zero-sm value))
          _ (new-module-def defined-sym (c-static-reified (.c-var value) [] [] {}
                                                          {(.c-var value) (expr-constraints value)}
                                                          (.c-struct value)))]
      [value]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(deftype constraint-ast [constraint ast]
   (assert (instance? c/SymbolConstraints constraint))

  Stringable
  (string-list [_]
    (list "(ExprConstraint " (str constraint) " " (str ast) ")"))

  Emitter
  (replace-syms [_ subs]
    (for [new-ast (replace-syms ast subs)]
      (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (c/update-sym constraint new-sym))
                                   constraint)]
        (constraint-ast new-constraint new-ast))))

  (replace-bound-vars [_ subs]
    (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (c/update-sym constraint new-sym))
                                 constraint)
          new-ast (replace-bound-vars ast subs)]
      (constraint-ast new-constraint new-ast)))

  (tail-call [_ params return-constraints]
    (constraint-ast constraint (tail-call ast params return-constraints)))

  (emit [_]
    (for [expr (emit ast)]
      (constrain-expr expr (c/update-path constraint (ast/file-name ast) (ast/line-number ast))))))

(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          line-number (ast/line-number clause)]
      (for [syms get-syms
            expr (-> maybe-constraint
                     (c/update-path file-name line-number)
                     (constraint-ast clause)
                     emit)
            _ (set-syms syms)]
        expr))))

(extend-type Tagged
  EmitCond
  (emit-cond-clause [sym]
    (for [expr (emit sym)]
      (constrain-expr expr (c/update-path maybe-constraint
                                          (ast/file-name sym) (ast/line-number sym))))))

(defn cond-clause-init [cond-test result-var [init refs-map constraints] clause]
  (assert (instance? Vector init))
  (assert (instance? C-expr clause))

  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs))]
    [(conj init
           [(.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            cond-test result-var ",\"\",0)) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  (either (and (= 0 remaining)
                                               (maybe ""))
                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))])
     refs-map
     (comp constraints (.constraints clause))]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits _ constraints] (reduce (butlast evalled-clauses)
                                             [[] refs-map {}]
                                             (partial cond-clause-init cond-test result-var))
        last-clause (either (last evalled-clauses)
                            (do
                              (print-err "Booom!!!")
                              (abort)))
        last-init [(.init last-clause)
                   (either (= "" (.c-var last-clause))
                           [result-var " = " (.c-var last-clause) ";" line-sep])]]
    (conj clause-inits last-init)))

(defn clause-refs [exprs result-var]
  (dissoc (apply merge-with (list* + (map exprs .refs-map)))
          result-var))

(defn clause-checks [[first-clause & evalled-clauses]]
  (reduce evalled-clauses [[first-clause] (.constraints first-clause)]
          (fn [[clauses constraints] clause]
            ;; TODO: only check values that are necesasry
            (let [checks (map (seq (.constraints clause))
                              (fn [[var constraint]]
                                (either (for [refs (get (.refs-map clause) var)
                                              :when (< 0 refs)]
                                          (runtime-check (c/update-var constraint var)
                                                         (either (get constraints var)
                                                                 c/top-type)
                                                         "" 0))
                                        "")))]
              [(conj clauses (.init clause (comp checks (.init clause))))
               (comp constraints (.constraints clause))]))))

(defn emit-cond-expr [cond-test result-var clauses tail-return]
  (for [evalled-clauses (ev/traverse clauses emit-cond-clause)]
    (let [[first-clause] evalled-clauses
          refs-map (clause-refs evalled-clauses result-var)
          [exprs] (clause-checks evalled-clauses)]
      (c-init result-var
              ["Value *" result-var ";" line-sep
               (-> exprs
                   (clause-inits cond-test refs-map result-var)
                   (interpose [tail-return "} else {" line-sep
                               "dec_and_free(" result-var ", 1);" line-sep]))
               (-> (count evalled-clauses)
                   dec
                   (repeat (str "}" line-sep)))]
              (map evalled-clauses .decl)
              refs-map
              (assoc (.constraints first-clause)
                result-var (.var maybe-constraint result-var))
              (ast/file-name clauses) (ast/line-number clauses)))))

(defn emit-and-expr [cond-test result-var clauses tail-return]
  (for [evalled-clauses (ev/traverse clauses emit-cond-clause)]
    (let [[first-clause] evalled-clauses
          last-clause (extract (last evalled-clauses))
          refs-map (clause-refs evalled-clauses result-var)
          [exprs] (clause-checks evalled-clauses)]
      (c-init result-var
              ["Value *" result-var ";" line-sep
               (-> exprs
                   (clause-inits cond-test refs-map result-var)
                   (interpose [tail-return "} else {" line-sep
                               "dec_and_free(" result-var ", 1);" line-sep]))
               (-> (count evalled-clauses)
                   dec
                   (repeat (str "}" line-sep)))]
              (map evalled-clauses .decl)
              refs-map
              (assoc (.constraints first-clause)
                result-var (expr-constraints last-clause))
              (ast/file-name clauses) (ast/line-number clauses)))))

(deftype TailAnd [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ")
          (flat-map (seq clauses) string-list)
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    ;; TODO: make sure this gernates good code
    (for [result-var (genlocal "andRslt")
          expr (emit-and-expr "if (isNothing(" result-var
                              (remove (.clauses ast) (partial instance? ast/NoCode))
                              (str "return(nothing);" line-sep))]
      expr)))

(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (and (empty? clauses)
                   (maybe (wrap sm/zero-sm empty-c-code)))
              (for [result-var (genlocal "andRslt")
                    expr (emit-and-expr "if (isNothing(" result-var clauses "")]
                expr))))

  (tail-call [ast params result-constraint]
    (let [clauses (-> (.clauses ast)
                      (remove (partial instance? ast/NoCode))
                      seq
                      reverse)
          file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          result-constraint (either (c/compose-constraints file-name line-number
                                                           result-constraint
                                                           (c/update-path maybe-constraint file-name line-number))
                                    (abort))]
      (either (map (first clauses)
                   (fn [last-clause]
                     (TailAnd (-> (tail-call last-clause params result-constraint)
                                  (vector)
                                  (comp (rest clauses))
                                  reverse))))
              (TailAnd []))))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast (vec new-clauses))))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ")
          (flat-map (seq clauses) string-list)
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    ;; TODO: make sure this gernates good code
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr "if (!isNothing(" result-var
                               (remove (.clauses ast) (partial instance? ast/NoCode))
                               (str "return(" result-var ");" line-sep))]
      expr)))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (and (empty? clauses)
                   (maybe (wrap sm/zero-sm empty-c-code)))
              (flat-map (genlocal "orRslt")
                        (fn [result-var]
                          (emit-cond-expr "if (!isNothing(" result-var clauses
                                          line-sep))))))

  (tail-call [ast params result-constraint]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (TailOr (either (flat-map (last clauses)
                                (fn [last-clause]
                                  (store clauses (dec (count clauses))
                                         (tail-call last-clause params result-constraint))))
                      []))))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs))))))

(deftype TailEither [clause alt result-constraint]

  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    ;; TODO: make sure this gernates good code
    (for [cond-val (emit clause)
          alt-val (map (emit alt)
                       (fn [expr]
                         (let [expr (either (and (instance? Tagged alt)
                                                 (maybe (.refs-map expr {})))
                                            expr)]
                           (emit-tail-expr alt result-constraint expr))))
          result-var (genlocal "rslt")]
      (let [cond-rslt (.c-var cond-val)
            refs-map (merge-with + (.refs-map cond-val) (.refs-map alt-val))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                refs-map
                {result-var result-constraint
                 (.c-var cond-val) (.var maybe-constraint (.c-var cond-val))})))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          cond-val (emit-cond-clause (.clause ast))
          syms get-syms
          alt-val (emit (.alt ast))
          _ (set-syms syms)]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val)) refs-map
                {(.c-var cond-val) (.var maybe-constraint (.c-var cond-val))}
                (ast/file-name ast) (ast/line-number ast)))))

  (tail-call [ast params result-constraint]
    (TailEither (.clause ast) (.alt ast) result-constraint))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs))))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [
          ;; _ (debug "=======\n*** " 'main-fn)
          fn-arity (emit-fn-arity (rdr/tag 'main) (FnValPtr "") (.params ast) (.body ast))
          ;; _ (debug "=======")
          result-constraint (type-constraint IntegerType "" 0)
          _ (new-static-arity (FnValPtr 'main) 1 (.c-fn fn-arity) result-constraint)]
      [(c-code "" [] (.decl (.var-info fn-arity)) {} {})])))


(defn static-fn [fn-sym fn-var arities]
  (assert (instance? FnValPtr fn-var))
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (ev/traverse arities
                                     (fn [static-arity]
                                       (for [_ (new-static-arity fn-var
                                                                 (.param-count static-arity)
                                                                 (.c-fn static-arity)
                                                                 (.result-constraint static-arity)
                                                                 (.param-constraints static-arity))]
                                         (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)
          decl ["\n// --------- " fn-sym " -------------\n"
                "Value *" fn-var ";\n"
                (map emitted-arities .decl)
                "Function " struct-var " = {FunctionType, -1, \""
                fn-sym "\", " arity-count ", "
                "{" (to-str (interpose (map emitted-arities .c-var)
                                       ", "))
                "}};\n"
                "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]]
      (either (or (and (= fn-sym 'list)
                       (maybe (c-list-fn fn-var [] decl {} {} struct-var)))
                  (and (= fn-sym 'maybe)
                       (maybe (c-maybe-fn fn-var [] decl {} {} struct-var)))
                  (and (= fn-sym 'vector)
                       (maybe (c-vector-fn fn-var [] decl {} {} struct-var))))
              (c-static-fn fn-var [] decl
                           {} {fn-var fn-constraint} struct-var
                           (reduce arities {}
                                   (fn [m arity]
                                     (assoc m (.param-count arity) arity))))))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-closure-fn (str fn-var)
                    [(map emitted-arities .init)
                     line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
                     struct-var "->name = \"" fn-sym "\";" line-sep
                     struct-var "->arityCount = " arity-count ";" line-sep
                     (map (zip-lists (map emitted-arities .c-var)
                                     (range arity-count))
                          (fn [[sym index]]
                            (str struct-var "->arities[" index "] = " sym ";" line-sep)))
                     "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
                    [(map emitted-arities .decl)] (apply merge-with (list* + (map emitted-arities .refs-map)))
                    (assoc (.constraints (collapse-expressions emitted-arities))
                      (str fn-var) fn-constraint)
                    (reduce arities {}
                            (fn [m arity]
                              (assoc m (.param-count arity) arity)))
                    (ast/file-name fn-sym) (ast/line-number fn-sym)))))

(defn call-universal-proto-fn [fn-sym disp-arg args]
  (let [args (cons disp-arg args)]
    (str "if (universalProtoFn != 0){\n"
         "  incRef(" disp-arg ", 1);\n"
         "  List *args = empty_list;\n"
         (to-str (flat-map (reverse args)
                           (fn [arg]
                             (list "  args = listCons(" "(Value *)" arg ", args);\n"))))
         "  args = listCons(symbol(stringValue(\"" fn-sym "\")), args);\n"
         "  args = listCons(stringValue(\"" (ast/file-name fn-sym) "\"), args);\n"
         "  Value *result = fnApply(universalProtoFn, (Value *)args);\n"
         "  Value *inner = ((Maybe *)result)->value;\n"
         "  if (inner != (Value *)0) {\n"
         "    incRef(inner, 1);\n"
         "    dec_and_free(result, 1);\n"
         "    dec_and_free(" disp-arg ", 1);\n"
         "    return(inner);\n"
         "  }\n"
         "}\n")))

(deftype InsertCode [fn-sym prototype]
  Emitter
  (emit [_]
    (let [num-args (-> prototype .params .fixed count)
          [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                            (range num-args))
                                 (fn [[arg idx]]
                                   (either (check-C-var (str arg "_" idx))
                                           (str "arg" idx))))]
      (wrap sm/zero-sm (c-code ""
                               [(call-universal-proto-fn fn-sym disp-arg args)]
                               []
                               (reduce args {disp-arg 1}
                                       (fn [m arg]
                                         (assoc m arg 1)))
                               {})))))

(defn missing-impl-body [proto-sym fn-sym prototype]
  (let [num-args (-> prototype .params .fixed count)
        [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                          (range num-args))
                               (fn [[arg idx]]
                                 (either (check-C-var (str arg "_" idx))
                                         (str "arg" idx))))]
    (comp (filter (.default-body prototype) (partial instance? c/SymbolConstraints))
          (filter (.default-body prototype) (partial instance? c/ResultConstraint))
          [(ast/inline-ast
            'C nothing
            (str (call-universal-proto-fn fn-sym disp-arg args)
                 "if (closures != (List *)0) {"
                 "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                 "' for type '%s' with %d arguments at %s\\n\", "
                 "((String *)type_name(empty_list, " disp-arg "))->buffer, " num-args
                 ", ((String *)closures)->buffer);\nabort();\n"
                 "} else {"
                 "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                 "' for type '%s' with %d arguments.\\n\", "
                 "((String *)type_name(empty_list, " disp-arg "))->buffer, " num-args ");\nabort();\n"
                 "}")
            (ast/file-name fn-sym) (ast/line-number fn-sym))])))

(defn emit-proto-default [protocol-sym fn-sym disp-fn-var prototype]
  (let [body (remove (.default-body prototype) (partial instance? ast/NoCode))
        default-body (missing-impl-body protocol-sym fn-sym prototype)]
    (for [arity-impl-var (global-var (str "Default_" fn-sym) "arityImpl")
          :let [arity-impl-var (ProtoDispFnPtr arity-impl-var)]
          default-arity (emit-fn-arity (rdr/tag (str "Default_" fn-sym)) disp-fn-var
                                      (.params prototype)
                                      (-> (.default-body prototype)
                                          (filter (partial instance? ast/NoCode))
                                          (comp default-body))
                                      arity-impl-var)
          static-arity (either (and (empty? body)
                                    (maybe (wrap sm/zero-sm default-arity)))
                               (emit-fn-arity (rdr/tag (str "Default_" fn-sym)) disp-fn-var
                                              (.params prototype)
                                              (-> (.default-body prototype)
                                                  (filter (partial instance? ast/NoCode))
                                                  (comp [(InsertCode fn-sym prototype)] body))
                                              arity-impl-var))
          result-constraints (-> (.default-body prototype)
                                 (filter (partial instance? c/ResultConstraint))
                                 (map .assertion)
                                 (ev/traverse to-constraint))
          :let [result-constraint (reduce result-constraints c/top-type c/intersect)]
          _ (sm/assoc-in-val [.modules (ast/file-name protocol-sym) .protocols
                              (rdr/untag protocol-sym) (rdr/untag fn-sym)
                              (.param-count static-arity) 0]
                             (ProtoImpl 0 (.c-var (.var-info static-arity))
                                        (ast/fn-arity (.params prototype) ""
                                                      (either (and (empty? body)
                                                                   (maybe default-body))
                                                              body))
                                        (.param-constraints default-arity)
                                        result-constraint
                                        arity-impl-var))
          _ (sm/assoc-in-val [.fns (.arity-fn-var static-arity) (.param-count static-arity) .param-constraints]
                             (.param-constraints default-arity))]
      (.result-constraint static-arity result-constraint))))

(defn create-dispatcher [proto-sym [fn-sym arities]]
  (for [proto-sym-expr (emit (ast/quoted-ast proto-sym))
        fn-sym-expr (emit (ast/quoted-ast fn-sym))

        fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                     (global-var (str "dispFn_" fn-sym) "fn"))
        :let [fn-var (FnValPtr fn-var)]
        arities-info (ev/traverse arities
                                  (fn [arity]
                                    (let [arg-count (count (.params arity))]
                                      (for [c-fn (global-var (str "disp_" fn-sym) "dispatcher")
                                            result-constraints (-> arity
                                                                   .default-body
                                                                   (filter (partial instance? c/ResultConstraint))
                                                                   (ev/traverse to-constraint))
                                            _ (new-static-arity fn-var arg-count (ProtoDispFnPtr c-fn)
                                                                (reduce result-constraints c/top-type
                                                                        c/intersect)
                                                                c/empty-items-constraint)]
                                        ["Value *" c-fn "("
                                         (-> (map (range arg-count) (fn [n] (str "Value *arg" n)))
                                             (conj "List *closures")
                                             (interpose ", "))
                                         ");\n"]))))
        _ (new-module-def fn-sym (c-protocol-fn fn-var [] [] {} {fn-var fn-constraint} "" {}))
        default-fns (ev/traverse arities (partial emit-proto-default proto-sym fn-sym fn-var))
        :let [default-arities (reduce default-fns {}
                                      (fn [m arity]
                                        (assoc m (.param-count arity) arity)))]
        _ (sm/assoc-in-val [.modules (ast/file-name fn-sym) .values fn-sym .arities]
                           default-arities)]
    [(.decl proto-sym-expr)
     (.decl fn-sym-expr)
     "\n// proto fn for " proto-sym "/" fn-sym "\n"
     "\n// --------- " fn-sym " -------------\n"
     "Value *" fn-var ";\n"
     arities-info
     (map default-fns (fn [arity]
                        (.decl (.var-info arity))))]))

(defn check-protocol-name [proto-sym]
  ;; Ensure all protocol symbols are unique
  (comp (for [proto-info (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols (rdr/untag proto-sym)])]
          (do
            (print-err  "Duplicate protocol"
                        (str "'" proto-sym "'") "at"
                        (str (ast/file-name proto-sym) ":")
                        (ast/line-number proto-sym))
            (abort)))
        (wrap sm/zero-sm '_)))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (check-protocol-name proto-name)
            decl (ev/traverse (seq prototype-map)
                              (partial create-dispatcher proto-name))]
        [(c-code "" [] decl {} {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (either (and (= "" (.fn-sym ast))
                                (maybe 'anon))
                           (.fn-sym ast))
                   (FnValPtr (str (.fn-var ast))) (.params ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (wrap sm/zero-sm (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (rdr/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug "=========")
                ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                :let [fn-var (FnValPtr fn-var)]
                arities (ev/traverse (map (.arities ast) (fn [arity]
                                                           (-> arity
                                                               (.fn-sym fn-sym)
                                                               (.fn-var fn-var))))
                                     emit)
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                :let [fn-var (FnValPtr fn-var)]
                arities (ev/traverse (.arities ast) emit)
                fn-expr (comp (closure-fn (str "anonymous function at "
                                               (ast/file-name ast) ": " (ast/line-number ast))
                                          fn-var arities)
                              (static-fn (str "anonymous function at "
                                              (ast/file-name ast) ": " (ast/line-number ast))
                                         fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.decl [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (ev/traverse (.arities ast)
                                   (fn [arity]
                                     (replace-syms arity subs)))]
      (.arities ast (vec new-arities))))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (get-type-numbers (maybe type-sym))
                  fns (map (ev/traverse (seq type-nums) (partial extend-type* ast))
                           flatten)]
              fns)
            (compilation-error "Trying to extend unknown type: "
                               (str "'" type-sym "'") "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(defn constructor-expr [new-type-name type-num new-type-constraint type-val-sym fields assertions]
  (assert (instance? c/TypeConstraint new-type-constraint))
  (assert (instance? Vector fields))

  (let [reified-type-num (extract rdr/type-counter)
        x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field-count (count fields)]
    (ast/definition new-type-name
      [(ast/reified reified-type-num
                    {Type-sym
                     [[type-name-sym
                       [(ast/fn-arity-ast (str new-type-name "_const_type_name") (FnValPtr "")
                                          (ast/params ['_]) ""
                                          [(str "*" new-type-name " constructor*")]
                                          [] c/top-type)]]
                      [type-mapping-sym
                       [(ast/fn-arity-ast (str new-type-name "_const_type_map") (FnValPtr "")
                                          (ast/params ['_]) ""
                                          [(map-vals (.type-maps new-type-constraint)
                                                     (fn [field-set]
                                                       (map field-set ast/quoted-ast)))]
                                          [] c/top-type)]]
                      [instance?-sym
                       [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") (FnValPtr "")
                                          (ast/params [x* y*]) ""
                                          [(ast/and-ast
                                            [(ast/call-ast =*-sym
                                                            [(ast/call-ast get-type-sym [type-val-sym])
                                                             (ast/call-ast get-type-sym [y*])])
                                             (ast/call-ast maybe-sym [y*])])]
                                          [] c/top-type)]]]

                     Function-sym
                     [[invoke-sym
                       [(ast/fn-arity-ast (str new-type-name "_invoke") (FnValPtr "")
                                          ;; TODO: can't use 'arg, have to use "fields"
                                          (ast/params (comp ['_] (repeat field-count 'arg))) ""
                                          ;; TODO: put assertions back in
                                          [(ast/inline-ast 'C nothing
                                                           (str "ReifiedVal *rv = malloc_reified("
                                                                field-count ");\n"
                                                                "#ifdef SINGLE_THREADED\n"
                                                                "rv->refs = refsInit;\n#else\n"
                                                                " __atomic_store(&rv->refs,"
                                                                " &refsInit, __ATOMIC_RELAXED);\n"
                                                                "#endif\n"
                                                                "rv->type = " type-num ";\n"
                                                                (to-str (map (range field-count)
                                                                             (fn [idx]
                                                                               (str "rv->impls[" idx "] = arg_"
                                                                                    (inc idx) ";\n"))))
                                                                "return((Value *)rv);\n")
                                                           "" 0)]
                                          [] c/top-type)]]]

                     Container-sym
                     [[apply-sym
                       [(ast/fn-arity-ast (str new-type-name "_apply_ST_") (FnValPtr "")
                                          (ast/params ['_ 'fields]) ""
                                          ;; TODO: need field constraints here
                                          [(ast/inline-ast 'C nothing
                                                           (str "return(newTypeValue(" type-num
                                                                ", listVec(fields_1)));")
                                                           "" 0)]
                                          [] c/top-type)]]]

                     Stringable-sym
                     [[string-list-sym
                       [(ast/fn-arity (ast/params ['z]) ""
                                      [(ast/call-ast list-sym
                                                     ["<ValueConstructor " (str new-type-name) " ["
                                                      (to-str (interpose fields ", ")) "]>"])])]]]})])))

(defn type-val-expr [type-sym type-num type-val-sym fields impls]
  (let [x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field* (rdr/tag "#field")
        ctxt* (rdr/tag "#ctxt")]
    (ast/definition type-val-sym
      [(ast/reified type-num
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") (FnValPtr "")
                                                      (ast/params [x*]) ""
                                                      [(str type-sym)]
                                                      [] c/top-type)]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") (FnValPtr "")
                                     (ast/params [x* field*]) ""
                                     [(ast/or-ast
                                       (conj (map fields
                                                  (fn [field]
                                                    (ast/call-ast identical-sym
                                                                  [(rdr/tag (str "." field))
                                                                   field*])))
                                             (rdr/tag 'nothing)))]
                                     [] c/top-type)]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") (FnValPtr "")
                                     (ast/params [x* y*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast
                                         =*-sym [(ast/call-ast get-type-sym [x*])
                                                 (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast
                                         =*-sym [(ast/call-ast reified-type-args-sym [x*])
                                                 (ast/call-ast reified-type-args-sym [y*])])
                                        (ast/call-ast maybe-sym [x*])])]
                                     [] c/top-type)]]]

                                 Associative-sym
                                 [[get-symb
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") (FnValPtr "")
                                     (ast/params [x* field*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym
                                                      [(ast/call-ast field* [x*])])])]
                                     [] c/top-type)]]

                                  [assoc-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_") (FnValPtr "")
                                     (ast/params [x* field* 'new-value]) ""
                                     [(ast/either-ast
                                       (ast/and-ast
                                        [(ast/call-ast has-field-sym [x* field*])
                                         (ast/call-ast maybe-sym
                                                       [(ast/call-ast field* [x* 'new-value])])])
                                       x*)]
                                     [] c/top-type)]]]

                                 Hashable-sym
                                 [[sha1-update-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1_update") (FnValPtr "")
                                     (ast/params [x* ctxt*]) ""
                                     [(ast/call-ast sha1-update-type-sym [x* ctxt*])
                                      (ast/call-ast
                                       sha1-update-sym
                                       [(ast/call-ast reified-type-args-sym [x*]) ctxt*])]
                                     [] c/top-type)]]
                                  [sha1-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1") (FnValPtr "")
                                     (ast/params [x*]) ""
                                     [(ast/call-ast
                                       sha1-finalize-sym
                                       [(ast/call-ast
                                         sha1-update-sym
                                         [x* (ast/call-ast sha1-init-sym [])])])]
                                     [] c/top-type)]]]}
                                impls))])))

(defn declare-getters [new-type-name fields]
  (ev/traverse fields
               (fn [field]
                 (let [getter-sym (rdr/tag (str "." field) 'core 0)]
                   (comp (map (sm/get-in-val [.modules 'core .protocols (rdr/untag Type-sym) (rdr/untag getter-sym)])
                              (fn [_] []))
                         (create-dispatcher Type-sym
                                            [getter-sym
                                             [(ast/prototype getter-sym
                                                             (ast/params [(symbol "#x")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint getter-sym
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])
                                              (ast/prototype getter-sym
                                                             (ast/params [(symbol "#x") (symbol "#y")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint getter-sym
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])]]))))))

(defn create-getters [sym constraint fields field-constraints]
  (let [type-value (rdr/tag "#value")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            (let [new-value (rdr/tag "#field")
                  extract-field [(ast/inline-ast 'C nothing (str "return(getField(value_0, " field-index "));\n")
                                                  "" 0)]
                  ;; TODO: add back in
                  ;; extract-field (either (or (map (= c/top-type field-constraint)
                  ;;                                (fn [_]
                  ;;                                  [extract-field]))
                  ;;                           (map (instance? c/MultiConstraint field-constraint)
                  ;;                                (fn [mc]
                  ;;                                  (map (.constraints mc)
                  ;;                                       (fn [c]
                  ;;                                         (constraint-ast c extract-field))))))
                  ;;                       [(constraint-ast field-constraint extract-field)])
                  set-field [;; TODO: add back in
                             ;; (c/update-sym field-constraint field)
                             (ast/inline-ast 'C nothing
                                             (str "return(updateField(value_0, field_1, "
                                                  field-index "));\n")
                                             "" 0)
                             ]]
              [(rdr/tag (str "." field))
               [(ast/fn-arity-ast (str sym "_" field) (FnValPtr "")
                                  (ast/params [type-value new-value]) ""
                                  set-field
                                  [] c/top-type)
                (ast/fn-arity-ast (str sym "_" field) (FnValPtr "")
                                  (ast/params [type-value]) ""
                                  extract-field
                                  [] c/top-type)]])))}))

(defn destruct-impl-fields [sym ast field-types arity]
  (let [[type-value-parameter] (.fixed (.params arity))
        fields (.fixed (.fields ast))
        field-count (count fields)
        return-assertions (filter (.body arity) (partial instance? c/ResultConstraint))
        field-constraints (-> field-types
                              c/extract-items-constraints
                              (comp (repeat field-count c/top-type))
                              (take field-count))
        new-body (comp return-assertions
                       [(ast/assert-type (.sym ast) type-value-parameter)]
                       (filter (.body arity) (partial instance? c/SymbolConstraints))
                       [(-> (zip-lists fields
                                       field-constraints
                                       (range field-count))
                            (map (fn [[field-sym field-constraint index]]
                                   ;; TODO: add field-constraint
                                   (ast/binding field-sym
                                     (ast/call-ast get-field-sym
                                                   [type-value-parameter index]))))
                            vec
                            (ast/let-ast 
                             (remove (.body arity) (partial instance? c/SymbolConstraints))))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str sym "_" fn-name)))))

(defn destructure-fields [sym ast field-types]
  (let [impls (comp* {} (filter (.impls ast)
                                (partial instance? HashMap)))]
    (map-vals impls
              (fn [impl-arities]
                (map impl-arities
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields sym ast field-types))]))))))

(def pre-defed-types {'TypeConstraint TypeConstraintType
                      'NoValues NoValuesType
                      'AllValues AllValuesType
                      'MultiConstraint MultiConstraintType
                      'ResultConstraint ResultConstraintType
                      'ItemsConstraint ItemsConstraintType
                      'FieldConstraint FieldConstraintType
                      'StaticIntConstraint StaticIntConstraintType
                      'MinValue MinValueType
                      'MaxValue MaxValueType
                      'InferredInner InferredInnerType
                      'StaticLengthConstraint StaticLengthConstraintType
                      'StaticStrConstraint StaticStrConstraintType
                      'ContentsConstraint ContentsConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? Tagged type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract rdr/type-counter)))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))
          field-assertions (filter (.impls ast) (partial instance? c/SymbolConstraints))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            (either (and (= file-name 'core)
                                                         (maybe "$TOCCATA_DIR/core.toc"))
                                                    file-name)
                                            ", " line-number))]
              "")

            ;; TODO: 'type-val-sym' ends up looking like "g_g__HASH_type_val_2882_2883'
            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym file-name line-number)
                        type-num (new-type-number sym)
                        type-map {type-num (-> fields
                                               (map (fn [name]
                                                      (symbol (str "." name))))
                                               set)}
                        new-type-constraint (c/TypeConstraint type-map (list [file-name line-number])
                                                            sym nothing "")]
                  _ (sm/assoc-in-val [.type-maps type-num] (TypeInfo sym type-map))
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)
                  _ (sm/assoc-in-val [.constants .type-names type-num] (str sym))
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  field-assertions (ev/traverse field-assertions to-constraint)
                  :let [field-map (reduce field-assertions
                                          {} (fn [m c]
                                               (either (or (map (= c c/top-type) (fn [_] m))
                                                           (map (.sym c)
                                                                (fn [c-sym]
                                                                  (either (some fields (partial = c-sym))
                                                                          (do
                                                                            (print-err "Invalid field"
                                                                                       (str "'" c-sym "'")
                                                                                       "at:" (str file-name ":")
                                                                                       line-number)
                                                                            (abort)))
                                                                  (merge-constraint-maps file-name line-number
                                                                                         m {c-sym c}))))
                                                       m)))
                        field-constraints (c/ItemsConstraint
                                           (map fields (fn [field]
                                                         (either (get field-map field)
                                                                 c/top-type)))
                                           empty-list (maybe (symbol (str sym "-field-constraints"))) "")
                        impls (merge-with comp
                                          (create-getters sym new-type-constraint fields
                                                          (.items-constraints field-constraints))
                                          (destructure-fields sym ast field-constraints))]
                  type-constructor (emit-definition
                                    (constructor-expr sym type-num new-type-constraint type-val-sym
                                                      fields field-assertions))
                  type-val-def (emit-definition (type-val-expr sym type-num type-val-sym
                                                               fields impls))

                  const-type-num (map (sm/get-in-val [.modules file-name .values sym])
                                      expr-type-num)
                  _ (sm/assoc-in-val [.modules 'core .protocols (rdr/untag Function-sym) (rdr/untag invoke-sym)
                                      const-arity-index const-type-num .result-constraint]
                                     new-type-constraint)]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) {} {})]
                    type-constructor
                    type-val-def))))))

;; (defn js-callable-arity [[num-args expr]]
;;   (for [c-fn-name (global-var (str (.sym ast) "_" num-args))
;;         :let [c-fn-name (either (check-C-var c-fn-name)
;;                                 c-fn-name)
;;               js-wrapper (c-code ""
;;                                  ["\nEM_ASM(\n" (str (.sym ast)) " = function("
;;                                   (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
;;                                   "_" c-fn-name "("
;;                                   (interpose (map (range num-args)
;;                                                   (fn [idx]
;;                                                     ["sendValue(arg" idx ")"]))
;;                                              ", ")
;;                                   ");\n return; \n};);\n"]
;;                                  [] {} {})]
;;         _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
;;                                                 (conj exprs js-wrapper)))]
;;     [c-fn-name num-args]
;;     [(c-code "" []
;;              ["EMSCRIPTEN_KEEPALIVE\n void " c-fn-name "("
;;               (interpose (map (range num-args) (partial str "int64_t arg")) ", ")
;;               ") {\ndec_and_free("
;;               (.c-var expr) "("
;;               (interpose (cons "empty_list"
;;                                (map (range num-args)
;;                                     (fn [idx]
;;                                       ["(Value *)arg" idx])))
;;                          ", ")
;;               "), 1);\n return; \n};\n"]
;;              {} {})]))

(extend-type ast/JS-callable
  Emitter
  (emit-definition [ast]
    (let [num-args (.num-args ast)]
      (comp (for [fn-var (map (lookup-sym (.sym ast)) .c-var)
                  expr (lookup-static-arity-info fn-var num-args)
                  c-fn-name (global-var (str (.sym ast)))
                  :let [c-fn-name (either (check-C-var c-fn-name)
                                          c-fn-name)
                        js-wrapper (c-code ""
                                           ["\n#ifdef TOCCATA_WASM\n"
                                            "EM_ASM(\n" (str (.sym ast)) " = function("
                                            (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
                                            "_" c-fn-name "("
                                            (interpose (map (range num-args)
                                                            (fn [idx]
                                                              ["sendValue(arg" idx ")"]))
                                                       ", ")
                                            ");\n return; \n};);\n"
                                            "#endif\n"]
                                           [] {} {})]
                  _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                          (conj exprs js-wrapper)))]
              [(c-code "" []
                       ["\n#ifdef TOCCATA_WASM\n"
                        "EMSCRIPTEN_KEEPALIVE\n void " c-fn-name "("
                        (interpose (map (range num-args) (partial str "int arg")) ", ")
                        ") {\ndec_and_free("
                        (.c-var expr) "("
                        (interpose (cons "empty_list"
                                         (map (range num-args)
                                              (fn [idx]
                                                ["(Value *)arg" idx])))
                                   ", ")
                        "), 1);\n return; \n};\n"
                        "#endif\n"]
                       {} {})])
            (compilation-error "Could not find function" (.sym ast) "or an arity with" num-args "arguments.")))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {} empty-closures)
                                   (RuntimeInit (FunctionArityContext {} 0 {} {} empty-closures)
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names {})
                                   0                        ;; reify-fn-index
                                   core-types               ;; type-maps
                                   ))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");\n"]))

(defn gather-protocols [file-name]
  (comp (for [protocols (sm/get-in-val [.modules file-name .protocols])
              expr (encode-static protocols)
              _ (ev/traverse
                 (for [[_ proto-fns] (seq protocols)
                       [fn-sym arities] (seq proto-fns)]
                   [fn-sym arities])
                 (fn [[fn-sym arities]]
                   (for [disp-fn (sm/get-in-val [.modules file-name .values (rdr/tag fn-sym)])
                         :let [fn-var (.c-var disp-fn)]
                         c-fns (ev/traverse (keys arities)
                                            (fn [arg-count]
                                              (for [disp-arity (lookup-static-arity-info fn-var arg-count)
                                                    arity-var (global-var "arity")]
                                                [arg-count arity-var (.c-var disp-arity)])))
                         struct-var (global-var "dispFnStruct")
                         _ (sm/assoc-in-val [.modules file-name .values fn-sym]
                                            (c-static-val fn-var [] [] {} {} struct-var))]
                     (write-strings
                      [(map c-fns
                            (fn [[arg-count arity-var c-fn]]
                              (let [impls (extract (get arities arg-count))]
                                ["Value *" c-fn "(List *"
                                 (interpose (cons "closures" (map (range arg-count)
                                                                  (partial str "Value *arg")))
                                            ",")
                                 ") {\nFnArity *arity;\n#\n"
                                 "FnType" arg-count " *_fn;\n"
                                 "switch (arg0->type) {\n"
                                 (map (seq (dissoc impls 0))
                                      (fn [[type-num arity-info]]
                                        (assert (instance? ProtoImpl arity-info))

                                        ["case " (str type-num) ": arity = "
                                         (.c-var arity-info) ";\n_fn = (FnType"
                                         arg-count " *)" (.c-fn arity-info) ";\n"
                                         (for [[constraint var] (-> (.param-constraints arity-info)
                                                                    (.items-constraints)
                                                                    (zip-lists (map (range arg-count)
                                                                                    (partial str "arg"))))]
                                           (-> constraint
                                               (c/update-var var)
                                               (runtime-check c/top-type
                                                              (str "(closures == (List *)0 ? \"\" : "
                                                                   "((String *)closures)->buffer)"))))
                                         "\nbreak;\n"]))
                                 (let [arity-info (extract (get impls 0))]
                                   ["default: arity = " (.c-var arity-info) ";_fn = (FnType" arg-count
                                    " *)" (.c-fn arity-info) ";\nbreak;\n"])
                                 "}\n"
                                 ;; "FnType" arg-count " *_fn = (FnType" arg-count " *)arity->fn;\n" 
                                 "return(_fn(arity->closures, " (-> (range arg-count)
                                                                    (map (partial str "arg"))
                                                                    (interpose ", "))
                                 "));\n}\n"
                                 "FnArity " arity-var " = {FnArityType, -1, "
                                 arg-count
                                 ", (List *)0, 0, " c-fn ", (Value *)0, (Value *)0};\n"])))
                       "Function " struct-var " = {FunctionType, -1, \""
                       fn-sym "\", " (count c-fns) ", "
                       "{" (interpose (map c-fns (fn [[_ arity-var]] (str "&" arity-var))) ", ")
                       "}};\n"
                       "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]))))
              protos-var (sm/get-in-val [.modules file-name .values protocols-sym])]
          (comp expr
                (c-code (.c-var protos-var)
                        [(.c-var protos-var) " = " (.c-var expr) ";\n"]
                        [] {} {})))
        (compilation-error "Could not gather the protocols for" (str "'" file-name "'"))))

(defn gather-symbols [file-name]
  (for [symbols (sm/get-in-val [.modules file-name .values])
        expr (-> symbols
                 (dissoc symbols-sym protocols-sym)
                 (assoc 'filename (either (instance? String file-name)
                                          ""))
                 (encode "symbols_"))
        sym-var (sm/get-in-val [.modules file-name .values symbols-sym])]
    (comp expr
          (c-code (.c-var sym-var)
                  [(.c-var sym-var) " = " (.c-var expr) ";\n"]
                  [] {} {}))))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity-info (FnValPtr 'main) 1)
                      (compilation-error "'main' function is missing"))
        modules (sm/get-in-val [.modules])
        ;; TODO: only gather symbols/prototypes if interpreter is compiled
        protos (ev/traverse (keys modules) gather-protocols)
        symbols (ev/traverse (keys modules) gather-symbols)
        values (sm/get-in-val [.rt-init .exprs])]
    (write-strings ["\n#\n"
                    (map protos .decl)
                    (map symbols .decl)
                    "\nint main (int argc, char **argv) {\n"
                    "#ifdef SINGLE_THREADED\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    "fprintf(stderr, \"Cannot use SINGLE_THREADED (or TOCCATA_WASM) and CHECK_MEM_LEAK "
                    "at same time.\");\n "
                    "abort();\n"
                    "#endif\n"
                    "#endif\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map protos .init)
                    (map values .init) "\n"
                    (map symbols (fn [sym-map]
                                   [(.init sym-map) (.c-var sym-map) "->refs = -1;\n"]))
                    "\n#\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    "cleaningUp = 1;\n"
                    "mainThreadDone = 1;\n"
                    "waitForWorkers();\n"
                    (map (vals modules) (fn [module]
                                          (either (map (get-in module [.values symbols-sym])
                                                       (fn [expr]
                                                         (free-global (c-init (.c-var expr)
                                                                              [] [] {} {} "" 0))))
                                                  "")))
                    (map values free-global)
                    "\n#\n"
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif"
                    "\n#\n"
                    "  return(0);\n};\n"])))

(defn get-proto-dispatch-sym [fn-sym num-args]
  (for [fn-var (lookup-sym fn-sym)
        arity-var (sm/get-in-val [.fns (.c-var fn-var) num-args])]
    (.c-var arity-var)))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (for [protos-var (global-var "protos_")
                              symbols-var (global-var "symbols_")
                              _ (sm/assoc-in-val [.modules module-name]
                                                 (Module module-name
                                                         {protocols-sym (c-code protos-var [] [] {} {})
                                                          symbols-sym (c-code symbols-var [] [] {} {})}
                                                         {} core-type-nums {}))]
                          (write-strings ["Value *" protos-var " = (Value *)&emptyBMI;\n"
                                          "Value *" symbols-var " = (Value *)&emptyBMI;\n"]))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [emitted (map emitted (fn [expr]
                                                           (write-strings (.decl expr))
                                                           (.decl expr [])))]
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))


(def fixup-native-symbols*
  (apply (wrap sm/zero-sm (fn [& decl]
                            (write-strings decl)))
          (list (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                     (fn [arity-sym]
                       ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                     (fn [arity-sym]
                       ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                     (fn [arity-sym]
                       ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                     (fn [arity-sym]
                       ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                     (fn [arity-sym]
                       ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                     (fn [arity-sym]
                       ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                     (fn [arity-sym]
                       ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'vals) 1)
                     (fn [arity-sym]
                       ["Value *(*vals)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'rest) 1)
                     (fn [arity-sym]
                       ["Value *(*rest)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'seq) 1)
                     (fn [arity-sym]
                       ["Value *(*seq)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                     (fn [arity-sym]
                       ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                     (fn [arity-sym]
                       ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'has-field) 2)
                     (fn [arity-sym]
                       ["Value *(*hasField)(List *, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                     (fn [arity-ptr]
                       ["Value *(*showFn)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'new-hash-set) 1)
                     (fn [arity-ptr]
                       ["Value *(*newHashSet)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'apply) 2)
                     (fn [arity-ptr]
                       ["Value *(*fn_apply)(List *, Value*, Value*) = " arity-ptr ";\n"]))
                )))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ev/Evaluator
  (ev/eval [x]
    (let [file (.file-path x)]
      (comp (for [curr-file-name (sm/get-val .file-name)
                  curr-file-path (sm/when (sys/file-directory curr-file-name))
                  :let [file (str curr-file-path file)]
                  mod-syms (comp (sm/get-in-val [.ns file .syms])
                                 (for [asts (sm/when (for [file-in (fio/file-in file)
                                                           asts (ev/parse {'file-name file
                                                                           'line-number 1}
                                                                          (lazy-list file-in))]
                                                       asts))
                                       _ (sm/set-val .file-name file)
                                       base-imports (sm/get-val .base-imports)
                                       _ (sm/assoc-in-val [.ns file] (ev/EvalNamespace file base-imports
                                                                                       {} {} {}))
                                       _ (ev/eval asts)
                                       mod-syms (sm/get-in-val [.ns file .syms])]
                                   mod-syms))
                  _ (sm/assoc-in-val [.ns curr-file-name .imports file] mod-syms)]
              mod-syms)
            (ev/abort-interp "Could not import module" (str "'" file "'") "at"
                             (ev/ast-location-str x))))) 

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def repo-cloner (agent {}))

(defn clone-repo* [ast proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sh/command "/usr/bin/git" (list "clone" "--branch" branch
                                                  (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sh/command "/usr/bin/git"
                                            (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ev/Evaluator
  (ev/eval [ast]
    ;; Only called when interpreting a file (I think)
    (let [file (.file ast)]
      (either (and (-> file
                      seq
                      (some (partial = "/")))
                   (maybe (ev/abort-interp "For git dependencies,"
                                           "files may only be imported from root of repository,"
                                           file "is invalid.")))
              (comp (for [script-dir (sm/get-val .script-dir)
                          :let [clone-waiter (promise)
                                dep-path (do
                                           (clone-repo {} ast clone-waiter script-dir)
                                           (extract clone-waiter))
                                module-path (str dep-path "/" file)
                                _ (or (sys/access module-path)
                                      (do
                                        (print-err "Dependency file" file "missing from cloned repository"
                                                   (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                                        (abort)))]
                          curr-file-name (sm/get-val .file-name)
                          _ (sm/set-val .file-name module-path)
                          r (ev/eval (ast/module-ast file))
                          _ (sm/set-val .file-name curr-file-name)]
                      r)
                    (ev/abort-interp "Could not import module" (str "'" file "'") "from git repo at"
                                     (ev/ast-location-str ast))))))

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn fixup-generated-symbols [context file-name protocols-sym symbols-sym]
  (update-context context
                  (for [protocols-var (sm/get-in-val [.modules file-name .values protocols-sym])
                        _ (sm/assoc-in-val [.modules file-name .values 'protocols]
                                           protocols-var)
                        symbols-var (sm/get-in-val [.modules file-name .values symbols-sym])
                        _ (sm/assoc-in-val [.modules file-name .values 'symbols]
                                           symbols-var)]
                    '_)))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (do
                  (send ast-emitter
                        fixup-generated-symbols 'core protocols-sym symbols-sym)
                  (assoc modules 'core 'loaded))))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? HashMap loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (let [r (analyze-forms {'file-name file-name
                                                                         'root-directory root-dir
                                                                         'project-directory proj-dir
                                                                         'line-number 1}
                                                                        (lazy-list file-in))]
                                                   (send ast-emitter
                                                         fixup-generated-symbols file-name
                                                         protocols-sym symbols-sym)
                                                   r)))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(extend-type ev/Thunk
  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (wrap sm/zero-sm (fn [& rules]
                      (apply (wrap sm/zero-sm (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type ev/ProtoDispatcher
  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (wrap sm/zero-sm (fn [& rules]
                      (apply (wrap sm/zero-sm (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type sm/new-sm
  ev/Evaluator
  (ev/apply-fn [mv [state]]
    (wrap sm/zero-sm (mv state))))

(main [params]
  (either (or (and (< (count params) 2)
                   (do
                     (print-err "A filename to compile must be provided.")
                     (maybe -1)))
              (and (< 2 (count params))
                   (let [[_ option file-name & args] params]
                     (or (and (= "--script" option)
                              (flat-map (sys/file-directory file-name)
                                        (fn [script-dir]
                                          (interp/interp-file
                                           file-name script-dir
                                           [(interp/CompiledNs 'file (either (get fio/symbols 'filename)
                                                                             "")
                                                               fio/symbols fio/protocols)
                                            (interp/CompiledNs 'reader (either (get rdr/symbols 'filename)
                                                                               "")
                                                               rdr/symbols rdr/protocols)
                                            (interp/CompiledNs 'grammar  (either (get grmr/symbols 'filename)
                                                                                 "")
                                                               grmr/symbols grmr/protocols)
                                            (interp/CompiledNs 'parse  (either (get rd/symbols 'filename)
                                                                               "")
                                                               rd/symbols rd/protocols)
                                            (interp/CompiledNs 'ast  (either (get ast/symbols 'filename)
                                                                             "")
                                                               ast/symbols ast/protocols)
                                            (interp/CompiledNs 'sys  (either (get sys/symbols 'filename)
                                                                             "")
                                                               sys/symbols sys/protocols)
                                            (interp/CompiledNs 'state-maybe  (either (get sm/symbols 'filename)
                                                                                     "")
                                                               sm/symbols sm/protocols)
                                            (interp/CompiledNs 'const  (either (get c/symbols 'filename)
                                                                               "")
                                                               c/symbols c/protocols)
                                            (interp/CompiledNs 'strm  (either (get strm/symbols 'filename)
                                                                              "")
                                                               strm/symbols strm/protocols)]
                                           args))))
                         (do
                           (print-err "The only option for the compiler is '--script'")
                           (maybe -1))))))
          (let [[_ file-name] params
                waiter (promise)]
            (or (map (sys/file-directory file-name)
                     (fn [root-dir]
                       (write-strings ["\n#define _XOPEN_SOURCE 600"
                                       "\n#include <stdlib.h>"
                                       "\n#include \"core.h\"\n"])
                       (send module-compiler compile-module file-name waiter root-dir root-dir)))
                (do
                  (print-err "Could not find " (str "'" file-name "'"))
                  (abort)))
            (extract waiter)
            (send ast-emitter emit-main)
            (send ast-emitter fixup-native-symbols)
            (send ast-emitter (fn [ctxt]
                                (map (get-in ctxt ['_ .constants .other])
                                     (fn [counts]
                                       (apply print-err (list* "\n" (interpose (map (seq counts)
                                                                                     (fn [[k v]]
                                                                                       (str k ": " v)))
                                                                               "\n")))
                                       (print-err "number of types" (extract rdr/type-counter))))))
            ;; wait for agents to clear their queues
            (let [waiter (promise)]
              (send ast-emitter (fn [_]
                                  (send string-writer (fn [_]
                                                        (deliver waiter 'x)))))
              (extract waiter)))))
