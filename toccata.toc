
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, NumberType};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, StringType};"))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang              ;; language to compile to
                        fn-context               ;; context for the fn currently being compiled
                        modules                  ;; info for each module compiled
                        numbers
                        strings
                        ])

;; information that must be tracked for each module
(deftype Module [path values]
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

;; Every function has some information that's local to it
(deftype FunctionContext [sym-count]
  Stringable
  (string-list [_]
    (list "<FunctionContext " (str sym-count) ">")))

(defn new-module [path]
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {}))))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))

;; useful for debugging the compiler
(def sm-space (sm/state-maybe ""))
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (map (apply debug msg)
       (fn [_] (abort))))

;; information about a compiled expression or expressions
(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (str type-num) ", "
          (str (count init)) " ," (str refs-map) ">")))

;; All AST nodes will implement this protocol
(defprotocol Emitter
  ;; 'emit-c' actually returns a function that will take a global context and
  ;; emit the C code to stdout
  (emit-c [ast]))

(defn get-type [type-symbol]
  (sm/state-maybe 0))

(defprotocol DefinitionProto
  (emit-definition [_ defined-sym]))

(extend-type ast/block-comment-ast
  Emitter
  (emit-c [ast]
    (sm/state-maybe [(c-code "" (comp ["\n"]
                                      (map (.lines ast) (fn [line]
                                                          (str "//" line "\n"))))
                             [] 0 {})]))

  DefinitionProto
  (emit-definition [_ _]
    (sm/state-maybe [])))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (.file-name sym) .values sym]))

(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-val .strings) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.strings str-val]
                             (c-code str-ptr [] [] StringType {}))]
      [(c-code str-ptr
                []
                ["struct {\nint64_t type;\n int32_t refs;\n   int64_t len;\n   Integer *hash;\n   char buffer["
                 (inc str-len)
                 "];\n} " str-sym " = {StringType, -1, "
                 str-len ", 0, \"" (escape-chars str-val) "\"};\n"
                 "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
                StringType {})])))

(extend-type String
  Emitter
  (emit-c [str-val]
    (comp (map (sm/get-in-val [.strings str-val]) vector)
          (make-static-string str-val)))

  DefinitionProto
  (emit-definition [str-val defined-sym]
    (for [[value] (emit-c str-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [value])))

(defn make-static-num [num]
  (for [num-idx (map (sm/get-val .numbers) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    [(c-code num-ptr
              []
              ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
               "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
              IntegerType {})]))

(extend-type Number
  Emitter
  (emit-c [num]
    (comp (map (sm/get-in-val [.numbers num]) list)
          (make-static-num num)))

  DefinitionProto
  (emit-definition [num defined-sym]
    (for [[value] (emit-c num)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [value])))

(extend-type ast/inline-ast
  Emitter
  (emit-c [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      [(c-code "" [(.txt ast)] [] type-num {})]))

  DefinitionProto
  (emit-definition [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (lookup-module-def defined-sym)
                      (global-var "var_"))
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] c-var)]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})])))

(extend-type ast/definition-ast
  Emitter
  (emit-c [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-definition ast defined-sym)))]
        (apply comp evalled)))))

(extend-type ast/main-ast
  Emitter
  (emit-c [ast]
    (for [exprs (traverse (.body ast) sm/state-maybe emit-c)]
      (let [exprs (apply comp exprs)]
        [(c-code "" (comp ["\nint main (int argc, char **argv) {\n"]
                          (apply comp (map exprs .init))
                          ["\nreturn(0);\n}\n"])
                 [] 0 {})]))))

(def global-context (GlobalContext 'C
                                   (FunctionContext 0)
                                   {}                       ;; map for module info
                                   {}                       ;; map for const numbers
                                   {}                       ;; map for const strings
                                   ))

(main [args]
      (let [[_ file-name] args]
        (for [in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (for [_ (new-module "")
                                    emitted (traverse asts sm/state-maybe emit-c)]
                                (flatten emitted))]
              [emitted-exprs] (emit-code global-context)]
          (map emitted-exprs
               (fn [emitted]
                 (map (.decl emitted) print)
                 (map (.init emitted) print))))))
