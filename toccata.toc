
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def UnknownType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, NumberType};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, StringType};"))
(def SubStringType (inline-C Number "(Value *)&(Number){NumberType, -1, SubStringType};"))
(def FnArityType (inline-C Number "(Value *)&(Number){NumberType, -1, FnArityType};"))
(def FunctionType (inline-C Number "(Value *)&(Number){NumberType, -1, FunctionType};"))
(def ListType (inline-C Number "(Value *)&(Number){NumberType, -1, ListType};"))
(def MaybeType (inline-C Number "(Value *)&(Number){NumberType, -1, MaybeType};"))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang              ;; language to compile to
                        fn-context               ;; context for the fn currently being compiled
                        init-fn-context          ;; context for the initialization code
                        modules                  ;; info for each module compiled
                        numbers                  ;; static numbers
                        strings                  ;; static strings
                        fns                      ;; static functions
                        ])

;; information that must be tracked for each module
(deftype Module [path values]
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [var-count syms]
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn reset-fn-context
  ([] (reset-fn-context (FunctionArityContext 0 {})))
  ([new-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-context)]
     curr-fn-context)))

(defn new-module [path]
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {}))))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))

;; useful for debugging the compiler
(def sm-space (sm/state-maybe ""))
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (map (apply debug msg)
       (fn [_] (abort))))

;; information about a compiled expression or expressions
(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (str type-num) ", "
          (str (count init)) " ," (str refs-map) ">"))

  Composition
  (zero [_] (c-code "" [] [] UnknownType {}))
  (comp* [c cs]
    (let [[c & cs] (reverse (cons c cs))]
      (reduce cs c
              (fn [result expr]
                (c-code (.c-var result)
                        (list (.init expr) (.init result))
                        (list (.decl expr) (.decl result))
                        (.type-num result)
                        (extract (or (and (empty? (.init expr))
                                          (maybe (merge-with + (.refs-map result) (.refs-map expr))))
                                     (maybe (assoc (merge-with + (.refs-map expr) (.refs-map result))
                                                   (.c-var expr) 0))))))))))

(def empty-c-code (c-code "" [] [] UnknownType {}))

(defn collapse-exprs [exprs]
  (let [[c & cs] (reverse (seq exprs))
        c (assoc-in c [.refs-map (.c-var c)] 1)
        cs (remove cs (fn [c] (and (empty? (.init c))
                                   (empty? (.decl c)))))]
    (reduce cs c
            (fn [result expr]
              (let [init (extract (or (and (or (= 'inline (.c-var result))
                                               (= "" (.c-var expr)))
                                           (maybe [(.init expr) (.init result)]))
                                      (and (empty? (.init expr))
                                           (maybe (.init result)))
                                      (for [ref (get (.refs-map result) (.c-var expr))]
                                        (list (.init expr)
                                              "\nincRef(" (.c-var expr) ", " (str (dec ref)) ");\n"
                                              (.init result)))
                                      (maybe (list (.init expr)
                                                   "\ndec_and_free(" (.c-var expr) ", 1);\n"
                                                   (.init result)))))]

                (c-code (.c-var result)
                        init
                        (comp (.decl expr) (.decl result))
                        (.type-num result)
                        (extract (or (and (empty? (.init expr))
                                          (maybe (merge-with + (.refs-map expr) (.refs-map result))))
                                     (maybe (assoc (merge-with + (.refs-map expr) (.refs-map result))
                                                   (.c-var expr) 0))))))))))



(defprotocol Emitter
  ;; All AST nodes will implement this fn
  (emit [_])

  ;; All AST nodes produce a value that can be assigned to a symbol
  (emit-defined-value [ast defined-sym])

  ;; All top-level AST nodes implement this
  (emit-definition [_]))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(defn genlocal [pre]
  (for [sym-count (sm/get-in-val [.fn-context .var-count])
        _ (sm/assoc-in-val [.fn-context .var-count] (inc sym-count))]
    (symbol (str pre sym-count))))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (.file-name sym) .values sym]))

(defn lookup-sym [sym]
  (comp (sm/get-in-val [.fn-context .syms sym])
        (lookup-module-def sym)))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn new-static-arity [fn-var num-params arity-var type-num]
  (sm/assoc-in-val [.fns fn-var num-params]
                   (c-code arity-var [] [] type-num {})))


(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))
  (emit-defined-value [_ _]
    (sm/state-maybe []))
  (emit-definition  [_]
    (sm/state-maybe [])))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-val .strings) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.strings str-val]
                             (c-code str-ptr [] [] StringType {}))]
      (c-code str-ptr
              []
              ["struct {\nint64_t type;\n int32_t refs;\n   int64_t len;\n   Integer *hash;\n   char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code (.c-var value) [] [] (.type-num value) {}))]
      [(assoc value .c-var "")])))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-val .numbers) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-code num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Number
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.numbers num])
          (make-static-num num)))
  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [(assoc value .c-var "")])))


(extend-type rdr/tagged-symbol
  Emitter
  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] value)]
      [(assoc value .c-var "")])))


(defn get-type [type-symbol]
  (sm/state-maybe 0))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (lookup-module-def defined-sym)
                      (global-var "var"))
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] c-var)]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [] [(.txt ast)] type-num {}))))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))


;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        result-sym (genlocal "rslt")]
    (c-code result-sym
            ["\n// static-fixed\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq arg-vars)) ", ") ");\n"]
            [] (.type-num arity-info) {})))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [target (emit (.call-target ast))
            args (emit (.args ast))
            call-site (call-static-fixed target (map args .c-var) file-name line-number)]
        (comp* target (comp args [call-site])))))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (global-var "var")
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code var [] [] (.type-num value) (.refs-map value)))]
      [(c-code var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(defprotocol GenBinding
  (gen-binding-syms [param]
    ;; generate bindings for symbols and tagged-symbols
    (for [param-var (genlocal "arg")
          :let [var-info (c-code param-var ["//" (str param) " " (str param-var) "\n"] []
                                 UnknownType {param-var 1})]
          _ (sm/assoc-in-val [.fn-context .syms param] var-info)]
      var-info)))

(deftype StaticArity [arity-fn-var param-count var-info])

(defn emit-static-arity [params body]
  (let [param-count (count params)]
    (for [arity-fn-var (global-var "arityImpl")
          arity-var (global-var "fnArity")
          fn-context (reset-fn-context)
          param-syms (traverse params sm/state-maybe gen-binding-syms)
          body-exprs (emit body)
          _ (sm/set-val .fn-context fn-context)]
      (let [body (collapse-exprs body-exprs)
            param-decls (map param-syms (fn [param]
                                          (str "Value *" (.c-var param))))
            fn-expr (comp* (c-code "" []
                                   ["Value *" arity-fn-var "("
                                    (interpose (cons "List *closures" param-decls) ", ")
                                    ") {\n"]
                                   FnArityType {})
                           param-syms)
            fn-result (extract (or (and (= "" (.c-var body))
                                        (maybe "nothing"))
                                   (maybe (.c-var body))))]
        (StaticArity arity-fn-var param-count
                     (c-code (str "&" arity-var)
                             []
                             [(.decl body)
                              (.decl fn-expr)
                              (.init fn-expr)
                              (.init body)
                              "\nreturn(" fn-result ");\n};\n\n"
                              "FnArity " arity-var " = {FnArityType, -1, " param-count
                              ", (List *)0, " "0" ", " arity-fn-var "};\n"]
                             FnArityType {}))))))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [fn-arity (emit-static-arity (.fixed (.params ast)) (.body ast))
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-static-arity (.fixed (.params ast)) (.body ast))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (let [fn-name (.fn-sym ast)]
      (for [struct-var (global-var "fnStruct")
            fn-var (global-var "fn")
            arities-info (emit (.arities ast))
            emitted-arities (traverse arities-info sm/state-maybe
                                      (fn [static-arity]
                                        (for [_ (new-static-arity fn-var
                                                                  (.param-count static-arity)
                                                                  (.arity-fn-var static-arity)
                                                                  (.type-num (.var-info static-arity)))]
                                          (.var-info static-arity))))]
        (let [arity-count (count emitted-arities)
              arity-vars (map emitted-arities .c-var)]
          (c-code fn-var []
                  ["\n// --------- " fn-name " --------------\n"
                   "Value *" fn-var ";\n"
                   (map emitted-arities .decl)
                   "\n// --------- " fn-name " declaration --------------\n"
                   "Function " struct-var " = {FunctionType, -1, \""
                   fn-name "\", " arity-count ", "
                   "{" (to-str (interpose arity-vars ", ")) "}};\n"
                   "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
                  FunctionType {})))))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code (.c-var value) [] [] (.type-num value) (.refs-map value)))]
      [(assoc value .c-var "")])))


(def global-context (GlobalContext 'C
                                   (FunctionArityContext 0 {})
                                   (FunctionArityContext 0 {})
                                   {}                       ;; map for module info
                                   {}                       ;; map for const numbers
                                   {}                       ;; map for const strings
                                   {}                       ;; map for static fns
                                   ))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defn emit-main [vals]
  (for [main-fn (lookup-static-arity 'main 1)]
    [(c-code "" []
             ["\nint main (int argc, char **argv) {\n"
              "outstream = stdout;\n"
              (map vals .init) "\n"
              "Value *the_final_answer = " (.c-var main-fn) "((List *)0, (Value *)0);\n\n"
              "#ifdef CHECK_MEM_LEAK\n"
              (map vals (fn [val]
                          [(.c-var val) "->refs = 1;\n"
                           "freeGlobal(" (.c-var val) ");\n"]))
              "  dec_and_free(the_final_answer, 1);\n"
              "  freeAll();\n"
              "  if (malloc_count - free_count != 0)\n"
              "     return(1);\n"
              "#endif\n"
              "    return(0);\n};\n"]
             0 {})]))

(main [params]
      (let [[_ file-name] params]
        (println)
        (for [core-file (fio/file-in "core.toc")
              core-asts (analyze-forms (cache core-file))
              in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (for [_ (new-module "")
                                    emitted-core (traverse core-asts sm/state-maybe emit-definition)
                                    emitted (traverse asts sm/state-maybe emit-definition)
                                    main-fn (emit-main (remove (flatten emitted)
                                                               (fn [val] (= "" (.c-var val)))))]
                                (flatten (comp emitted-core emitted [main-fn])))]
              [emitted-exprs] (emit-code global-context)]
          (let [_ (write-str "\n#include \"core.h\"\n")]
            (map emitted-exprs
                 (fn [emitted]
                   (write-str (.decl emitted))))))))
