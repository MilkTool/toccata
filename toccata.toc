
(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "3435b1b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ffd6095"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "3602513"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "f655efc"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "2978872"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "1e280ff"))
(add-ns ev (git-dependency "https://github.com/Toccata-Lang/eval.git"
                           "eval.toc"
                           :sha "d861de8"))
(add-ns interp (git-dependency "https://github.com/Toccata-Lang/eval.git"
                               "interpreter.toc"
                               :sha "d861de8"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "6673103"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "1c09660"))
(add-ns strm (git-dependency "https://github.com/Toccata-Lang/stream.git"
                             "stream.toc"
                             :sha "c778079"))
(add-ns sh (git-dependency "https://github.com/Toccata-Lang/shell-proc.git"
                           "shell-proc.toc"
                           :sha "576fc1c"))
(add-ns typ (module "type-checker.toc"))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(def string-writer (agent ""))
(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def Tagged (comp Symbol
                  rdr/tagged-symbol))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "")

(defn line-marker [file-name line-number marker]
  (either (and (or (= "" file-name)
                   (and (= 'core file-name)
                        (= 0 line-number)))
               (maybe "\n#\n"))
          ["\n" marker "\n#line "
           (str line-number) " " "\""
           (either (and (= 'core file-name)
                        (maybe path-to-core))
                   file-name)
           "\"\n"]))

(defn line-macro [ast marker]
  (wrap sm/zero-sm (line-marker (ast/file-name ast) (ast/line-number ast) marker)))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def TypeConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeConstraintType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def MultiConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MultiConstraintType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
(def ItemsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ItemsConstraintType};"))
(def FieldConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FieldConstraintType};"))
(def StaticIntConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticIntConstraintType};"))
(def MinValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MinValueType};"))
(def MaxValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaxValueType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def StaticLengthConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2,
    StaticLengthConstraintType};"))
(def StaticStrConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticStrConstraintType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringBufferType "String"
                 SubStringType "String"
                 FnArityType "FnArity"
                 FunctionType "Fn"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 HashSetType "Set"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"
                 UnknownType "UnknownType"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-type-nums {'Integer IntegerType
                     'StringBuffer StringBufferType
                     'SubString SubStringType
                     'FnArity FnArityType
                     'Function FunctionType
                     'Fn FunctionType
                     'List ListType
                     'Maybe MaybeType
                     'Vector VectorType
                     'Symbol SymbolType
                     'BitmapIndexedNode BitmapIndexedType
                     'ArrayNode ArrayNodeType
                     'HashCollisionNode HashCollisionNodeType
                     'Promise PromiseType
                     'Future FutureType
                     'Agent AgentType
                     'Opaque OpaqueType
                     'TypeCount TypeCount})

(deftype TypeInfo [sym type-map]
  (assert (instance? (map-of Integer HashSet) type-map))

  Stringable
  (string-list [_]
    (list "<TypeInfo " (str sym) ">"))

  Type
  (type-mapping [_]
    type-map))

(def core-types {IntegerType (TypeInfo 'Integer {IntegerType #{}})
                 StringBufferType (TypeInfo 'String {StringBufferType #{}})
                 SubStringType (TypeInfo 'String {SubStringType #{}})
                 FnArityType (TypeInfo 'FnArity {FnArityType #{}})
                 FunctionType (TypeInfo 'Fn {FunctionType #{}})
                 ListType (TypeInfo 'List {ListType #{}})
                 MaybeType (TypeInfo 'Maybe {MaybeType #{}})
                 VectorType (TypeInfo 'Vector {VectorType #{}})
                 SymbolType (TypeInfo 'Symbol {SymbolType #{}})
                 BitmapIndexedType (TypeInfo 'BitmapIndexedNode {BitmapIndexedType #{}})
                 ArrayNodeType (TypeInfo 'ArrayNode {ArrayNodeType #{}})
                 HashCollisionNodeType (TypeInfo 'HashCollisionNode {HashCollisionNodeType #{}})
                 PromiseType (TypeInfo 'Promise {PromiseType #{}})
                 FutureType (TypeInfo 'Future {FutureType #{}})
                 AgentType (TypeInfo 'Agent {AgentType #{}})
                 OpaqueType (TypeInfo 'Opaque {OpaqueType #{}})})

(def fn-constraint (c/TypeConstraint {FunctionType #{}} empty-list 'Fn nothing ""))
(def sym-constraint (c/TypeConstraint {SymbolType #{}} empty-list 'Symbol nothing ""))
(def vect-constraint (c/TypeConstraint {VectorType #{}} empty-list 'Vector nothing ""))
(def list-constraint (c/TypeConstraint {ListType #{}} empty-list 'List nothing ""))
(def string-constraint (c/TypeConstraint {StringBufferType #{} SubStringType #{}}
                                         empty-list 'String nothing ""))
(def hashmap-constraint (c/TypeConstraint {BitmapIndexedType #{}
                                           ArrayNodeType #{}
                                           HashCollisionNodeType #{}}
                                          empty-list 'HashMap nothing ""))
(def int-constraint (c/TypeConstraint {IntegerType #{}} empty-list 'Integer nothing ""))
(def maybe-constraint  (c/TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map (wrap sm/zero-sm "") (fn [_]
                           (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params])

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; produce a constraint from an assertion ast
  (to-constraint [ast]
    (wrap sm/zero-sm ast))

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    sm/zero-sm)

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x)))

  ;; unpack the 'list-var' and bind the items to the 'elem-vars'
  (bind-list [list-var params bind-fn]
    (assert (instance? ast/params-ast params)))

  ;; bind fn parameters
  (bind-param [binding]
    (assert-result x (instance? sm/new-sm x)))
  (bind-param [binding expr]
    (assert-result x (instance? sm/new-sm x)))

  ;; get the constraints for a symbol or params-ast
  (get-param-constraints [_ subs]
    (assert-result x (instance? sm/new-sm x)))

  (update-call-site-count [_]
    (assert-result x (instance? sm/new-sm x)))

  (call-site-meta-data [c-var file-name line-number]
    (assert-result x (instance? sm/new-sm x)))

  ;; encode a static representation of a core data structure
  (encode [m]
    (emit m))

  (encode [m var-prefix])

  (validate-field [c m fields file-name line-number]
    m)

  ;; encode a statically initialized representation of a core data structure
  ;; TODO: make sure every impl is needed and constrains the var properly
  (encode-static [m]
    (do
      (print-err 'could-not-encode m)
      sm/zero-sm))

  (runtime-check [constraint value-info file-name line-number]
     (assert (instance? ast/SymbolOrString file-name))
     (assert (instance? Integer line-number))

    ;; generated code must preserve ref counts
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            (runtime-check constraint value-info
                           (either (and (= "" file-name)
                                        (maybe "\"\""))
                                   (str "\"at " file-name ": " line-number "\"")))))

  (runtime-check [constraint value-info sym-location]))

(defn destruct-seq [seq-c-var elem-c-vars dest-args file-name line-num]
  (assert (instance? String seq-c-var))
  (assert (instance? String dest-args))

  (let [elem-count (count elem-c-vars)]
    [(map elem-c-vars (fn [var]
                        ["Value *" var ";" line-sep]))
     "Value **" dest-args "[" elem-count "] = {"
     (interpose (map elem-c-vars (fn [var] ["&" var])) ", ")
     "};" line-sep "destructValue(\"" file-name "\", \"" line-num
     "\", (Value *)" seq-c-var ", " elem-count ", "
     dest-args ");" line-sep]))

(deftype FnValPtr [var]
  ;; pointer to a Fn struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ArityValPtr [var struct]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype StaticFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ProtoDispFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(def CFnPtr (comp StaticFnPtr
                  ProtoDispFnPtr))

(def PointerVar (comp FnValPtr
                      ArityValPtr
                      CFnPtr))

(extend-type PointerVar
  Emitter
  (encode-static [x]
    (emit (.var x)))

  Stringable
  (string-list [x]
    (list (str (.var x))))

  Eq
  (=* [x y]
    (and (=* y (str (.var x)))
         (maybe x)))

  Hashable
  (sha1 [x]
    (sha1 (.var x)))

  (sha1-update [x context]
    (sha1-update (.var x) context)))

(defprotocol C-Code
  (expr-constraints [expr]
    (assert-result x (instance? c/Constraints x)))

  (collapse-expressions* [x y]
    (assert-result r (instance? sm/new-sm r))))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; refs-map: map of C variables that are used in 'init' and how many times

(deftype empty-code [c-var init refs-map]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

(def empty-c-code (empty-code "" [] {}))

(defn collapse-expressions [cs]
  (assert-result r (instance? sm/new-sm r))

  (either (or (and (empty? cs)
                   (maybe (sm/state-maybe empty-c-code)))
              (and (empty? (rest cs))
                   (map (first cs) sm/state-maybe)))
          (let [[c & cs] cs]
            (flat-map (collapse-expressions cs)
                      (fn [expr]
                        (collapse-expressions* c expr))))))

(deftype c-code [c-var init refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-reified [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Reified " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-constructor [c-var init refs-map constraints c-struct type-num fields]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Type-Constructor " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ", " (str type-num) ">")))

(deftype c-static-str [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-String " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-int [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Int " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-sym [c-var init refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Symbol " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-vector-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-Vector-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-maybe-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-Maybe-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-list-fn [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  C-Code
  (expr-constraints [_]
    fn-constraint)

  Stringable
  (string-list [_]
    (list "<C-List-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-protocol-fn [c-var init refs-map constraints c-struct arities]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Protocol-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-arity [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Static-Arity " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(deftype c-static-fn [c-var init refs-map constraints c-struct arities]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? c/Constraints constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Function " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ", "
          (str constraints) " " (str arities) ">")))

(deftype c-static-val [c-var init refs-map c-struct]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Static-Value " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">")))

(extend-type c-code
  Emitter
  (encode-static [m]
    (do
      (print-err 'could-not-encode m)
      sm/zero-sm)))

(def C-Static-Value (comp c-static-int
                          c-static-str
                          c-static-sym
                          c-static-reified
                          c-constructor
                          c-list-fn
                          c-maybe-fn
                          c-vector-fn
                          c-static-fn
                          c-static-arity
                          c-protocol-fn
                          c-static-val))

(extend-type C-Static-Value
  Emitter
  (encode-static [x]
    (wrap sm/zero-sm x)))

;; same as 'c-code', but defines a function parameter
(deftype c-param [c-var init refs-map constraints file-name line-number]
  (assert (instance? String c-var))
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Param " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing))

(def C-Value (comp c-code
                   c-param
                   C-Static-Value))

(extend-type C-Value
  Collection
  (empty? [c]
    (empty? (.init c)))

  Emitter
  (emit [x]
    (wrap sm/zero-sm x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init refs-map file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", "
          (str (count init)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing))

;; same as 'c-init', but specifically for anon closure functions
(deftype c-closure-fn [c-var init refs-map arities file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? (map-of String Integer) refs-map))
  (assert (instance? HashMap arities))

  Stringable
  (string-list [_]
    (list "<C-Closure " (str c-var) ", "
          (str (count init)) ", " (str refs-map) " " (str arities) ">"))

  Collection
  (empty? [c] nothing))


(def C-expr (comp empty-code
                  C-Value
                  c-param
                  c-closure-fn
                  c-init))

(extend-type empty-code
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (comp* y (rest xs))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (sm/state-maybe y)))

(extend-type c-init
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))
                         c-var (.c-var x)
                         file-name (.file-name x)
                         line-number (.line-number x)
                         init [(.init x)
                               (either (or (for [refs (get-in y [.refs-map c-var])]
                                             [(either (and (< refs 2)
                                                           (maybe ""))
                                                      ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                                           (= "" c-var))
                                       [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                               (.init y)]
                         refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                                          c-var)]
                     (-> y
                         (.init init)
                         (.refs-map refs-map)))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          init [(.init x)
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(either (and (< refs 2)
                                            (maybe ""))
                                       ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]]
      (-> (either (and (instance? empty-code y)
                       (maybe (c-code "" [] {} c/top-type)))
                  y)
          (.init init)
          (.refs-map refs-map)
          sm/state-maybe))))

(extend-type c-closure-fn
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))
                         c-var (.c-var x)
                         file-name (.file-name x)
                         line-number (.line-number x)
                         init [(.init x)
                               (either (or (for [refs (get-in y [.refs-map c-var])]
                                             [(either (and (< refs 2)
                                                           (maybe ""))
                                                      ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                                           (= "" c-var))
                                       [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                               (.init y)]
                         refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                                          c-var)]
                     (-> y
                         (.init init)
                         (.refs-map refs-map)))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          init [(.init x)
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(either (and (< refs 2)
                                            (maybe ""))
                                       ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)]
      (-> (either (and (instance? empty-code y)
                       (maybe (c-code "" [] {} c/top-type)))
                  y)
          (.init init)
          (.refs-map refs-map)
          sm/state-maybe))))

(extend-type C-Value
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (-> (either (and (instance? empty-code y)
                                      (maybe x))
                                 y)
                         (.init [(.init x) (.init y)])
                         (.refs-map (merge-with + (.refs-map x) (.refs-map y)))))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    (let [x (either (and (empty? (.init x))
                         (maybe (.refs-map x {})))
                    x)]
      (-> (either (and (instance? empty-code y)
                       (maybe (c-code "" [] {} c/top-type)))
                  y)
          (.init [(.init x) (.init y)])
          (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
          sm/state-maybe))))

(deftype Closures [closures refs-map]
  (assert (instance? (vector-of Vector) closures))
  (assert (instance? (map-of String Integer) refs-map)))

(def empty-closures (Closures [] {}))

(deftype ConstantValues [numbers strings symbols type-names other]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names)))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count syms context-syms closed-over decl subs]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))
  ;; C code to declare stuff needed for fn arity
  (assert (instance? Vector decl))
  ;; Substitutions for checking types
  (assert (instance? Vector subs))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols types declarations ns-syms]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; types            map of type symbols to type definitions
  (assert (instance? HashMap types))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))
  ;; imported namespaces
  (assert (instance? HashMap ns-syms))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
;; TODO: might be able to remove the 'fns' field
(deftype GlobalContext [fn-context rt-init modules fns namespaces constants reify-fn-index type-maps]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit rt-init))
  ;; modules                info for each module compiled
  (assert (instance? HashMap modules))
  ;; fns                    static functions
  (assert (instance? HashMap fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))

  Stringable
  (string-list [_] (list "<GlobalContext>")))

(defn var-type-num [var]
  (map (sm/get-in-val [.fn-context .subs])
       (fn [subs]
         (let [type-nums (-> subs
                             (reduce {} (fn [m sub]
                                          (let [c (either (get sub var)
                                                          c/top-type)
                                                tm (either (c/extract-type-map c)
                                                           {})]
                                            (comp m tm))))
                             keys)]
           (either (and (= 1 (count type-nums))
                        (first type-nums))
                   UnknownType)))))

(defn declare [new-decl]
  (sm/update-in-val [.fn-context .decl] (fn [decl]
                                          (conj decl new-decl))))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      new-context (comp (-> curr-fn-context .context-syms)
                                        (-> curr-fn-context .syms))]
                  (maybe [(.decl curr-fn-context [])
                          (.fn-context s (FunctionArityContext {} 0 {} new-context empty-closures
                                                               (.decl curr-fn-context) [{}]))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.decl (.fn-context s) [])
                        (.fn-context s (.decl new-fn-context (comp (.decl (.fn-context s))
                                                                   (.decl new-fn-context))))])))))

(defn extract-sym-path [s sym]
  (let [file-name (ast/file-name sym)]
    (flat-map (rdr/namespace sym)
              (fn [ns-sym]
                (or (get-in (.namespaces s) [file-name ns-sym])
                    (get-in (.namespaces s) [file-name (rdr/tag ns-sym)]))))))

(defn sym-ns-path [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (map (extract-sym-path s sym) (fn [path]
                                                   [path s]))
                   (maybe [(ast/file-name sym) s])))))

(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str (list* start (seq remaining))))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (either (check-C-var (str sym "_"))
                                       arg-name)
                               sym-count)
                          new-ctxt]))))))

(defprotocol ConstrainParams
  (constrain-params [pb]))

(deftype ParamBinding [bound vars tail-var destruct]
  (assert (instance? Vector destruct))

  ConstrainParams
  (constrain-params [pb]
    (either (or (and (empty? vars)
                     (= tail-var "")
                     (maybe (typ/get-constraint bound))))
            (for [tail-const (typ/get-constraint tail-var)
                  items-const (typ/traverse vars constrain-params)
                  :let [constraint (c/ItemsConstraint items-const tail-const empty-list nothing tail-var)]
                  _ (typ/append-constraint bound constraint "" 0)]
              constraint)))

  Stringable
  (string-list [_]
    (either (or (and (empty? vars)
                     (= tail-var "")
                     (maybe (list bound)))
                (and (empty? vars)
                     (maybe (list "[|" tail-var "]"))))
            (list (str (comp vars [(str "| " tail-var)]))))))


;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name]
   (wrap sm/zero-sm (str (gensym (str "g_" arg-name)))))
  ([sym arg-name]
   (wrap sm/zero-sm (str (gensym (str "g_" (either (check-C-var (str sym "_"))
                                                  arg-name)))))))


(deftype ProtoImpl [dispatch-type c-var ast param-constraints result-constraint c-fn]
  (assert (instance? ArityValPtr c-var))
  (assert (instance? Integer dispatch-type))
  (assert (instance? CFnPtr c-fn))

  ;; TODO: remove these eventually
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))

  Stringable
  (string-list [_] (list "<ProtoImpl type: " (target-type-name dispatch-type) " " (str c-var) " "
                         (str c-fn) ">"))

  Emitter
  (encode [x]
    (encode-static x))

  (encode-static [_]
    (either (and (= "" (.var c-var))
                 (do
                   (print-err 'could-not-encode 'ProtoImpl)
                   (maybe sm/zero-sm)))
            (wrap sm/zero-sm (c-static-val (str "(Value *)" c-var) [] {} (.struct c-var))))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in m(odule at 'path'
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [protos (get-in s [.modules path .protocols])
                     _ (some (vals protos) (fn [proto] (get proto (rdr/untag fn-sym))))]
                 [path s]))))

(defn find-protocol-path [fn-sym]
  (comp (for [path (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym path)]
          path)
        (lookup-protocol-path fn-sym 'core)))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(defn new-proto-impl [proto-sym fn-sym arg-count dispatch-type var ast param-constraints result-constraint c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-sym))
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/fn-arity-ast ast))
  (assert (instance? ArityValPtr var))
  (assert (instance? CFnPtr c-fn))

  (for [protocol-path (find-protocol-path fn-sym)
        _ (sm/assoc-in-val [.modules protocol-path .protocols (rdr/untag proto-sym) (rdr/untag fn-sym)
                            arg-count dispatch-type]
                           (ProtoImpl dispatch-type var ast param-constraints result-constraint c-fn))]
    ""))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [path (either (extract-sym-path s proto-sym)
                                      (ast/file-name proto-sym))]
                     (for [proto-info (-> (.modules s)
                                          (get path)
                                          (flat-map (fn [module]
                                                      (get (.protocols module) (rdr/untag proto-sym)))))]
                       [proto-info s]))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.protocols module) (rdr/untag proto-sym)))))]
                     [proto-info s])))))

;; TODO: it feels like these 2 arities are too different
(defn get-proto-impl
  ([fn-sym arg-count type-num]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (or (let [proto-path (either (extract-sym-path s fn-sym)
                                             (ast/file-name fn-sym))]
                      (for [protocols (get-in s [.modules proto-path .protocols])
                            impl-info (some (vals protocols)
                                            (fn [dispatchers]
                                              (get-in dispatchers [(rdr/untag fn-sym) arg-count type-num])))]
                        [impl-info s]))
                    (for [protocols (get-in s [.modules 'core .protocols])
                          impl-info (some (seq protocols)
                                          (fn [[proto-name dispatchers]]
                                            (get-in dispatchers [(rdr/untag fn-sym) arg-count type-num])))]
                      [impl-info s])))))
  ([proto-sym fn-sym arg-count type-num]
   (flat-map (sm/new-sm (fn [s]
                          (maybe [(either (extract-sym-path s proto-sym)
                                          (ast/file-name proto-sym))
                                  s])))
             (fn [proto-path]
               (comp (sm/get-in-val [.modules proto-path .protocols (rdr/untag proto-sym) (rdr/untag fn-sym)
                                     arg-count type-num])
                     (sm/get-in-val [.modules 'core .protocols (rdr/untag proto-sym) (rdr/untag fn-sym)
                                     arg-count type-num])
                     ;; (compilation-error "Invalid protocol fn:"
                     ;;                    (str "'" fn-sym "' in")
                     ;;                    (str (ast/file-name fn-sym) ",")
                     ;;                    (ast/line-number fn-sym))
                     )))))

(def DefExprs (comp c-code
                    c-static-reified
                    c-constructor
                    c-static-str
                    c-static-int
                    c-static-fn
                    c-static-sym
                    c-maybe-fn
                    c-list-fn
                    c-vector-fn
                    c-protocol-fn))

(defn new-module-def [sym value]
  (assert (instance? DefExprs value))
  
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.modules s)
                   (get (ast/file-name sym))
                   (flat-map (fn [module]
                               (map (get-in (.declarations module) [sym '_])
                                    (fn [expr]
                                      [expr s]))))))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  ;; (sm/assoc-in-val [.fn-context .syms sym] expr)
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

(defn find-global-sym [sym]
  ;; Attempt to look up the global (ie. not closed over) value given a symbol.
  (for [ns-path (sym-ns-path sym)
        expr (sm/get-in-val [.modules ns-path .values sym])]
    expr))

(defn update-subs [f]
  (for [subs (sm/get-in-val [.fn-context .subs] [])
        :let [_ (and (empty? subs)
                     (maybe (do
                              (print-err "Compiler error, no constraints found")
                              (abort))))
              new-subs (map (flat-map subs f) (fn [[_ s]] s))
              new-subs (either (and (empty? new-subs)
                                    (maybe (do
                                             (print-err "Compiler error, no new constraints found")
                                             (abort))))
                               new-subs)]
        _ (sm/assoc-in-val [.fn-context .subs] new-subs)]
    '_))

;; This is so hideous on purpose. It's called *A LOT* so I unwound it for performance's sake
(defn lookup-sym [sym]
  ;; Look up a value given a symbol. Will abort if the symbol cannot be found.
  (assert (instance? rdr/tagged-symbol sym))
  (let [file-name (ast/file-name sym)
        line-number (ast/line-number sym)]
    (sm/new-sm
     (fn [s]
       (assert (instance? GlobalContext s))
       (let [ctxt (.fn-context s)
             syms (.syms ctxt)
             modules (.modules s)
             closed-over (.closed-over ctxt)
             closures (.closures closed-over)
             refs-map (.refs-map closed-over)]
         (map (or (map (or
                        ;; lookup namespace-qual sym
                        (flat-map (rdr/namespace sym)
                                  (fn [ns-sym]
                                    (or (get-in modules [file-name .ns-syms
                                                         (rdr/tag ns-sym)
                                                         (rdr/tag (.base sym))])
                                        (do
                                          (print-err "Undefined symbol" (str "'" sym "'") "at"
                                                     (str file-name ":")
                                                     (ast/line-number sym))
                                          (maybe (abort))))))
                        ;; lookup sym in local fn context
                        (get syms sym))
                       (fn [expr]
                         [expr s]))
                  ;; lookup symbol in enclosing context of fn
                  (map (-> ctxt .context-syms (get sym))
                       (fn [sym-info]
                         (let [constraint (expr-constraints sym-info)]
                           (either (some closures
                                         (fn [[closure-var sym-literal]]
                                           (and (= sym sym-literal)
                                                (map (get refs-map closure-var)
                                                     (fn [refs-count]
                                                       (let [new-refs-map (assoc refs-map
                                                                            closure-var (inc refs-count))
                                                             new-closed-over (.refs-map closed-over new-refs-map)
                                                             new-ctxt (.closed-over ctxt new-closed-over)]
                                                         [(c-code closure-var [] {closure-var 1} constraint)
                                                          (.fn-context s new-ctxt)]))))))
                                   (let [sym-count (.sym-count ctxt)
                                         closure-var (str "val" sym-count)
                                         new-sym-count (inc sym-count)
                                         new-closures (conj closures [closure-var sym constraint])
                                         new-refs-map (assoc refs-map closure-var 1)
                                         new-closed-over (-> closed-over
                                                             (.closures new-closures)
                                                             (.refs-map new-refs-map))
                                         new-ctxt (-> ctxt
                                                      (.sym-count new-sym-count)
                                                      (.closed-over new-closed-over))]
                                     [(c-code closure-var [] {closure-var 1} constraint)
                                      (.fn-context s new-ctxt)])))))
                  (map (or (flat-map (get modules file-name)
                                     (fn [module]
                                       (or (get (.values module) sym)
                                           (get-in (.declarations module) [sym '_]))))
                           (flat-map (and (map (first (str sym)) (partial =* "."))
                                          (get modules 'core))
                                     (fn [module]
                                       (get (.values module) sym))))
                       (fn [expr] [expr s]))
                  (do
                    (print-err "Undefined symbol" (str "'" sym "'") "at"
                               (str file-name ":")
                               (ast/line-number sym))
                    (abort)))
              (fn [[expr s]]
                [expr (either (update-in s [.fn-context .subs]
                                         (fn [subs]
                                           (map subs (fn [sub]
                                                       (let [var (.c-var expr)
                                                             constraint (expr-constraints expr)
                                                             new-c (either (map (get sub var)
                                                                                (fn [c2]
                                                                                  (either (c/compose-constraints
                                                                                           file-name line-number
                                                                                           constraint c2)
                                                                                          (abort))))
                                                                           constraint)]
                                                         (-> sub
                                                             (dissoc var)
                                                             (assoc var new-c)))))))
                              s)])))))))

(extend-type c/Constraints
  Emitter
  (encode-static [x]
    ;; TODO: for some reason, encoding the sym doesn't alwys work,
    ;; fortunately, it's not needed
    (let [x (either (map (instance? c/Constraints x)
                         (fn [x]
                           (-> x
                               (.var "")
                               (.sym nothing))))
                    x)]
      (comp (for [args (encode-static (type-args x))
                  struct (global-var "reified_")
                  var (global-var "reified_")
                  _ (declare ["ReifiedVal " struct " = {" (str (get-type x)) ", -2, "
                              (str (count args)) "," (interpose (map args .c-struct) ",")
                              "};" line-sep
                              "Value *" var "= (Value *)&" struct ";" line-sep])
                  r (collapse-expressions [args (c-static-val var [] {} struct)])]
              r)
            ;; TODO remove
            (for [_ (debug 'missing x)
                  :when nothing]
              '_)))))

(extend-type c/StaticConstraints
  Emitter
  (runtime-check [constraint value-info sym-location]
    []))

(extend-type c/ItemsConstraint
  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (or (c/satisfied-by constraint value-info)
                     (empty? (c/extract-items-constraints constraint)))
                 (maybe ""))
            [(-> (c/TypeConstraint {ListType #{} VectorType #{}} (.path constraint) 'Sequence
                                   (.sym constraint) (.var constraint))
                 (runtime-check value-info sym-location))
             (let [min-count (str (count (c/extract-items-constraints constraint)))]
               ["if (countSeq(incRef(" (.var constraint) ", 1)) < " min-count ") {"
                ;; "\n#ifndef EMBEDDED\n"
                "fprintf(stderr, \"Insufficient values for '"
                (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
                "fprintf(stderr, \"Needed " min-count
                ", got %\" PRId64 \"\\n\", ((Integer *)count((List *)0, "
                (.var constraint) "))->numVal);" line-sep
                "fprintf(stderr, \"" (interpose (c/format-path constraint (inc (count (.path constraint))))
                                                "\\n")
                "\\n\");"
                ;; "\n#endif\n"
                "abort();" line-sep "}"])
             "if (1) {" line-sep
             "incRef(" (.var constraint) ", 1);" line-sep
             (let [items (map (range (inc (count (c/extract-items-constraints constraint))))
                              (partial str (.var constraint) "_"))]
               [(destruct-seq (.var constraint) items (str (.var constraint) "_args") "" 9999)
                (for [[constraints item] (zip-lists (c/extract-items-constraints constraint) items)]
                  (let [constraints (either (map (.sym constraint) (fn [sym]
                                                                     (c/update-sym constraints sym)))
                                            constraints)]
                    (-> constraints
                        (c/update-var item)
                        (runtime-check value-info sym-location))))
                (map items (fn [item]
                             (str "dec_and_free(" item ", 1);" line-sep)))])
             "}" line-sep])))

(extend-type c/NoValues
  Emitter
  (runtime-check [constraint value-info sym-location]
    ["abort();\n#\n"]))

(extend-type c/AllValues
  Emitter
  (emit [constraint]
    (wrap sm/zero-sm empty-c-code))

  (replace-syms [constraint _]
     (wrap sm/zero-sm constraint))

  (runtime-check [constraint value-info sym-location]
    []))

(defn get-type-info [path type-symbol]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [modules (.modules s)]
                 (for [type-num (or (flat-map (get modules path)
                                              (fn [module]
                                                (get (.types module) type-symbol)))
                                    (flat-map (get modules 'core)
                                              (fn [module]
                                                (get (.types module) type-symbol))))
                       type-map (get-in s [.type-maps type-num .type-map])]
                   [type-map s])))))

(defn get-type-sym-info [type-symbol]
  (comp (for [ns-path (sym-ns-path type-symbol)
              type-info (get-type-info ns-path type-symbol)]
          type-info)
        (wrap sm/zero-sm {})))

(defn constrain-var [file-name line-number var constraint]
  (either (and (instance? c/AllValues constraint)
               (maybe (wrap sm/zero-sm '_)))
          (update-subs
           (typ/append-constraint var constraint file-name line-number))))

(defn emit-sym-constraint [constraint]
  (let [file-name (ast/file-name constraint)
        line-number (ast/line-number constraint)]
    (either (for [_ (= "" (.var constraint))
                  sym (.sym constraint)]
              (for [expr (lookup-sym sym)
                    _ (constrain-var file-name line-number (.c-var expr) constraint)]
                (either (and (instance? c-param expr)
                             (maybe empty-c-code))
                        (c-code (.c-var expr)
                                (runtime-check (c/update-var constraint (.c-var expr))
                                               c/top-type file-name line-number)
                                {} c/top-type))))
            (map (constrain-var file-name line-number
                                (.var constraint) constraint)
                 (fn [_]
                   empty-c-code)))))

(extend-type c/SymbolConstraints
  Emitter
  (validate-field [c m fields file-name line-number]
    (either (map (.sym c)
                 (fn [c-sym]
                   (either (some fields (partial = c-sym))
                           (do
                             (print-err "Invalid field"
                                        (str "'" c-sym "'")
                                        "at:" (str file-name ":")
                                        line-number)
                             (abort)))
                   (-> m
                       (dissoc c-sym)
                       (assoc c-sym (either (c/compose-constraints file-name line-number
                                                                   c
                                                                   (either (get m c-sym)
                                                                           c/top-type))
                                            (abort))))))
            m))

  (tail-call [constraint _]
    constraint)

  (replace-bound-vars [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs old-sym)]
              (c/update-sym constraint new-sym))
            constraint))

  (replace-syms [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs old-sym)]
              (wrap sm/zero-sm (c/update-sym constraint new-sym)))
            (wrap sm/zero-sm constraint)))

  (emit [constraint]
    (emit-sym-constraint constraint)))

(extend-type c/InferredInner
  Emitter
  (runtime-check [constraint value-info sym-location]
    ;; Not worth the cost to check this at runtime
    []))

(extend-type c/CollectionOf
  Emitter
  (emit [constraint]
    (either (and (= (.var constraint) "")
                 (map (.sym constraint)
                      (fn [sym]
                        (for [sym-info (lookup-sym sym)
                              inner-c (to-constraint (.constraints constraint))
                              _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                                               (.c-var sym-info)
                                               (.constraints constraint inner-c))]
                          empty-c-code))))
            (for [inner-c (to-constraint (.constraints constraint))
                  _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                                   (.var constraint)
                                   (.constraints constraint inner-c))]
              empty-c-code)))

  (runtime-check [constraint value-info sym-location]
    ;; Not worth the cost to check this at runtime
    []))

(extend-type c/TypeConstraint
  Emitter
  (replace-syms [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs old-sym)]
              (wrap sm/zero-sm (c/update-sym constraint new-sym)))
            (wrap sm/zero-sm constraint)))

  (to-constraint [ast]
    (map (get-type-sym-info (.type-sym ast))
         (fn [type-info]
           (either (and (empty? type-info)
                        (maybe c/top-type))
                   (.type-maps ast type-info)))))

  (emit [ast]
    ;; TODO: throw an error when the type symbol isn't defined
    (comp (for [type-map (get-type-sym-info (.type-sym ast))
                :when-not (empty? type-map)
                expr (emit-sym-constraint (.type-maps ast type-map))]
            expr)
          (sm/state-maybe empty-c-code)))

  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["switch (" (.var constraint) "->type) {" 
             (map (keys (.type-maps constraint)) (fn [type-num]
                                                   ["case " type-num ": " ]))
             "break; default:"
             ;; "\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Invalid type of value for '"
             (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");" line-sep
             "fprintf(stderr, \"Needed " (str (.type-sym constraint))
             ", got %s\\n\", extractStr(type_name((List *)0, " (.var constraint) ")));" 
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             ;; "\n#endif\n"
             "abort();}"])))

(extend-type c/MaxValue
  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["if (" (str (.max constraint)) " < ((Integer *)" (.var constraint) ")->numVal) {"
             ;; "\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Value of '" (either (.sym constraint) "<unknown>")
             "' is too large %s\\n\", " sym-location ");" line-sep
             "fprintf(stderr, \"Maximum allowed value is " (str (.max constraint))
             ", got %\" PRId64 \"\\n\", ((Integer *)" (.var constraint) ")->numVal);" line-sep
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             ;; "\n#endif\n"
             "abort();}"])))

(extend-type c/MinValue
  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["if (" (str (.min constraint)) " > ((Integer *)" (.var constraint) ")->numVal) {"
             ;; "\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Value of '" (either (.sym constraint) "<unknown>")
             "' is too small %s\\n\", " sym-location ");" line-sep
             "fprintf(stderr, \"Minimum allowed value is " (str (.min constraint))
             ", got %\" PRId64 \"\\n\", ((Integer *)" (.var constraint) ")->numVal);" line-sep
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             ;; "\n#endif\n"
             "abort();}"])))

(extend-type c/FieldConstraint
  Emitter
  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (let [sym (rdr/tag sym)]
                     (for [sym-info (lookup-sym sym)
                           field-var (lookup-sym (rdr/tag (.field constraint)))
                           _ (constrain-var (ast/file-name constraint) (ast/line-number constraint)
                                            (.c-var sym-info) (.field-var constraint (.c-var field-var)))]
                       (.refs-map sym-info (dissoc (.refs-map sym-info) (.c-var sym-info)))))))
            (wrap sm/zero-sm empty-c-code)))

  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["if(1) {\n"
             "Value *dork = hasField((List *)0, incRef(" (.var constraint) ", 1), "
             (.field-var constraint) ");\n" "if (isNothing(dork,\"\",0)) {"
             ;; "\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Value '" (either (.sym constraint) "<unknown>")
             "' of type '%s' does not have field '"
             (.field constraint) "' %s\\n\", extractStr(type_name((List *)0, "
             (.var constraint) ")), " sym-location ");" line-sep 
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             ;; "\n#endif\n"
             "abort();" 
             "} dec_and_free(dork, 1);}"])))

(extend-type c/MultiConstraint
  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (or (some (.constraints constraint)
                           (partial instance? c/StaticConstraints))
                     (c/satisfied-by constraint value-info))
                 (maybe ""))
            (map (.constraints constraint)
                 (fn [c]
                   (runtime-check c value-info sym-location)))))

  (emit [constraint]
    (map (ev/traverse (.constraints constraint) emit)
         (fn [[expr & exprs]]
           (comp* expr exprs)))))

(extend-type c/ResultConstraint
  Emitter
  (replace-bound-vars [constraint subs]
    (replace-bound-vars (.assertion constraint) subs))

  (replace-syms [constraint subs]
    (replace-syms (.assertion constraint) subs))

  (tail-call [constraint _]
    constraint)

  (emit [ast]
    (-> ast .assertion (c/update-var "#result") emit))

  (runtime-check [constraint value-info sym-location]
    ;; Handled other places
    [])

  (to-constraint [ast]
    (to-constraint (.assertion ast))))

(extend-type Maybe
  Emitter
  (encode-static [v]
    (either (map v (fn [v]
                     (for [expr (encode-static v)
                           struct (global-var "maybe_")
                           var (global-var "maybe_")
                           _ (declare ["Maybe " struct " = (Maybe){MaybeType, -2, (Value *)&" (.c-struct expr)
                                       "};" line-sep "Maybe *" var " = &" struct ";" line-sep])]
                       (do
                         ;; TODO: we need to encode the constraints on 'var' as well
                         (comp expr
                               (c-static-val var [] {} struct))))))
            (wrap sm/zero-sm
                  (c-static-val "nothing" [] {} "nothing_struct")))))

(extend-type List
  Emitter
  (encode-static [l]
    (either (map (first l)
                 (fn [head]
                   (for [tail-expr (encode-static (rest l))
                         head-expr (encode-static head)
                         struct (global-var "list_")
                         var (global-var "list_")
                         _ (declare ["List " struct " = {ListType, -2, " (str (count l))
                                     ", (Value *)&" (.c-struct head-expr)
                                     ", &" (.c-struct tail-expr) "};" line-sep])]
                     (comp tail-expr
                           head-expr
                           (c-static-val var [] {} struct)))))
            (wrap sm/zero-sm
                  (c-static-val "empty_list" [] {} "empty_list_struct"))))

  (tail-call [asts args]
    (let [asts (reverse asts)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args)
                    (cons init)
                    reverse))))))

(defn encodeVectorInfo [v]
  (inline C Vector "
  Vector *v = (Vector *)v_0;

  Vector *array = empty_vect;
  for (int i = 0; i < v->count; i++) {
    Value *val = v->tail[i];
    incRef(val, 1);
    array = mutateVectConj(array, val);
  }

  Vector *result = empty_vect;
  result = mutateVectConj(result, integerValue(v->shift));
  result = mutateVectConj(result, integerValue(v->tailOffset));
  if (v->root != (VectorNode *)0) {
    fprintf(stderr, \"Encode Vector root\\n\");
    abort();
  } else {
    result = mutateVectConj(result, nothing);
  }
  result = mutateVectConj(result, (Value *)array);

  dec_and_free(v_0, 1);
  return((Value *)result);
  "))

(def vector-array-len (inline C Integer "(Value *)&(Integer){IntegerType,-2,VECTOR_ARRAY_LEN}"))

(extend-type Vector
  Emitter
  (encode-static [v]
    (let [[shift offset root array] (encodeVectorInfo v)]
      (for [items (ev/traverse array encode-static)
            root (either (map root encode-static)
                         (wrap sm/zero-sm (c-static-val "NULL" [] {} "NULL")))
            struct (global-var "vect_")
            var (global-var "vect_")
            :let [new-items (either (and (empty? items)
                                         (maybe "0"))
                                    (interpose (map items
                                                    (fn [expr]
                                                      (str "(Value *)&" (.c-struct expr))))
                                               ", "))]
            _ (declare ["Vector " struct " = {VectorType, -2, "
                        (str (count array))
                        ", " (str shift) ", " (str offset) ", "
                        (.c-struct root) ", " new-items
                        (map (range (- vector-array-len (count array))) (fn [_] ", 0"))
                        "};" line-sep
                        "Value *" var "= (Value *)&" struct ";" line-sep])
            r (collapse-expressions (comp items [(c-static-val var [] {} struct)]))]
        r)))

  (tail-call [asts params]
    (either (flat-map (last asts)
                  (fn [tail]
                    (store asts (dec (count asts))
                           (tail-call tail params))))
            asts)))

(deftype TailHashMap [m]
  Stringable
  (string-list [_]
    (list (str m)))

  Emitter
  (emit [_]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context (.subs init-fn-context [{}]))
          value (encode m)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (constrain-var "" 0 (.c-var value) hashmap-constraint)]
      (c-code (.c-var value) ["return(" (.c-var value) ");" line-sep]
              {} hashmap-constraint))))

(defn collisionArray [m]
  (inline C Vector "
  HashCollisionNode *node = (HashCollisionNode *)m_0;
  int cnt = node->count;
  Vector *v = empty_vect;
  for (int i = 0; i < cnt; i++) {
    Value *val = node->array[i];
    incRef(val, 1);
    v = mutateVectConj(v, val);
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiArray [m]
  (inline C Vector "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  int cnt = __builtin_popcount(node->bitmap);
  Vector *v = empty_vect;
  for (int i = 0; i < cnt * 2; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe((List *)0, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiBitmap [m]
  (inline C Integer "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  Value *result = integerValue(node->bitmap);
  dec_and_free(m_0, 1);
  return((Value *)result);
  "))

(extend-type BitmapIndexedNode
  Emitter
  (encode-static [m]
    (for [items (ev/traverse (bmiArray m) (fn [v]
                                            (either (map v (fn [v]
                                                             (map (encode-static v) maybe)))
                                                    (wrap sm/zero-sm nothing))))
          struct (global-var "bmi_")
          var (global-var "bmi_")
          :let [new-items (either (and (empty? items)
                                       (maybe "0"))
                                  (interpose (map items
                                                  (fn [v]
                                                    (either (map v (fn [expr]
                                                                     (and (instance? String (.c-struct expr))
                                                                          (empty? (.c-struct expr))
                                                                          (do
                                                                            (print-err 'booom expr)
                                                                            (abort)))
                                                                     (str "(Value *)&"
                                                                          (.c-struct expr))))
                                                            "NULL")))
                                             ", "))]
          _ (constrain-var "" 0 var (c/TypeConstraint {BitmapIndexedType #{}}
                                                      empty-list 'HashMap nothing ""))
          _ (declare ["BitmapIndexedNode " struct " = {BitmapIndexedType, -2, "
                      (str (bmiBitmap m)) ", " new-items "};\n"
                      "Value *" var "= (Value *)&" struct ";\n"])
          r (collapse-expressions (comp (map items (fn [v] (either v empty-c-code)))
                                        [(c-static-val var [] {} struct)]))]
      r)))

(extend-type HashCollisionNode
  Emitter
  (encode-static [m]
    (for [items (ev/traverse (collisionArray m) encode-static)
          struct (global-var "collision_")
          var (global-var "collision_")
          :let [new-items (interpose (map items
                                          (fn [expr]
                                            (str "(Value *)&" (.c-struct expr))))
                                     ", ")]
          _ (constrain-var "" 0 var (c/TypeConstraint {HashCollisionNodeType #{}}
                                                      empty-list 'HashMap nothing ""))
          _ (declare ["HashCollisionNode " struct " = {HashCollisionNodeType, -2, "
                      (str (count items)) ", " new-items "};\n"
                      "Value *" var "= (Value *)&" struct ";\n"])
          r (collapse-expressions (comp items [(c-static-val var [] {} struct)]))]
      r)))

(defn arrayNodeArray [m]
  (inline C Vector "
  ArrayNode *node = (ArrayNode *)m_0;
  Vector *v = empty_vect;
  for (int i = 0; i < ARRAY_NODE_LEN; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe((List *)0, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(extend-type ArrayNode
  Emitter
  (encode-static [m]
    (for [items (ev/traverse (arrayNodeArray m) (fn [v]
                                                  (either (map v (fn [v]
                                                                   (map (encode-static v) maybe)))
                                                          (wrap sm/zero-sm nothing))))
          struct (global-var "arrayNode_")
          var (global-var "arrayNode_")
          :let [new-items (either (and (empty? items)
                                       (maybe "0"))
                                  (interpose (map items
                                                  (fn [v]
                                                    (either (map v (fn [expr]
                                                                     (str "(Value *)&"
                                                                          (.c-struct expr))))
                                                            "NULL")))
                                             ", "))]
          _ (constrain-var "" 0 var (c/TypeConstraint {ArrayNodeType #{}}
                                                      empty-list 'HashMap nothing ""))
          _ (declare ["ArrayNode " struct " = {ArrayNodeType, -2, " new-items "};"
                      line-sep "Value *" var "= (Value *)&" struct ";" line-sep])
          r (collapse-expressions (comp (map items (fn [v] (either v empty-c-code)))
                                        [(c-static-val var [] {} struct)]))]
      r)))

(extend-type HashMap
  Emitter
  (emit [m]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context (.subs init-fn-context [{}]))
          value (comp (encode-static m)
                      (encode m))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (constrain-var "" 0 (.c-var value) hashmap-constraint)]
      (c-code (.c-var value) ["return(" (.c-var value) ");" line-sep]
              {} hashmap-constraint)))

  (tail-call [m params]
    (TailHashMap m))

  (encode [m] (encode m "var_"))

  (encode [m var-prefix]
    (comp (encode-static m)
          (for [map-var (global-var var-prefix)
                _ (declare ["Value *" map-var " = (Value *)&emptyBMI;\n"])
                assocs (ev/traverse (seq m)
                                    (fn [[sym var]]
                                      (for [sym-var (either (and (instance? Tagged sym)
                                                                 (maybe (emit (ast/quoted-ast sym))))
                                                            (emit sym))
                                            expr (comp (encode-static var)
                                                       (encode var))]
                                        [(.init sym-var) (.init expr)
                                         map-var " = hashMapAssoc((Value *)" map-var
                                         ", incRef(" (.c-var sym-var) ", 1), " (.c-var expr) ");\n"])))
                _ (constrain-var "" 0 map-var hashmap-constraint)]
            (c-code map-var (comp* [] assocs) {} hashmap-constraint)))))


(deftype StaticArityInfo [c-var param-constraints result-constraint]
  (assert (instance? CFnPtr c-var))

  Stringable
  (string-list [_]
    (list "(StaticArityInfo " (str c-var) " " (str param-constraints) " "
          (str result-constraint)  ")")))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity-info [fn-var num-params]
  (assert (instance? FnPTr fn-var))
  
  (sm/get-in-val [.fns fn-var num-params]))

(defn lookup-core-fn-arity [sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [module (get (.modules s) 'core)
                     fn-sym (get (.values module) sym)
                     expr (get-in (.fns s) [(.c-var fn-sym) num-args .c-var])]
                 [expr s]))))

(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (wrap sm/zero-sm (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            {} c/top-type)))

  (emit-defined-value [_ x] (wrap sm/zero-sm []))
  (emit-definition [_] (wrap sm/zero-sm []))

  (tail-call [ast params]
    ast))

(defn type-constraint [type-num file-name line-number]
  (comp (for [type-info (sm/get-in-val [.type-maps type-num])]
          (either (and (empty? (.type-map type-info))
                       (maybe c/top-type))
                  (-> (.type-map type-info)
                      (c/TypeConstraint empty-list (.sym type-info) nothing "")
                      (c/update-path file-name line-number))))
        (wrap sm/zero-sm c/top-type)))

(defn get-type-numbers [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              type-nums (get-type-sym-info type-symbol)]
          (set (keys type-nums)))
        (wrap sm/zero-sm #{})))

(defn get-type-number [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              type-nums (get-type-sym-info type-symbol)]
          (either (and (= 1 (count type-nums))
                       (first (keys type-nums)))
                  UnknownType))
        (wrap sm/zero-sm UnknownType)))


(extend-type HashSet
  Emitter
  (encode-static [hs]
    (for [m (encode-static [(.set-map hs)])
          struct (global-var "set_")
          var (global-var "set_")
          _ (constrain-var "" 0 var (c/TypeConstraint {(get-type hs) #{}}
                                                      empty-list 'HashSet nothing ""))
          _ (declare ["ReifiedVal " struct " = {" (str (get-type hs))
                      ", -2, 1, (Value *)&" (.c-struct m) "};\n"
                      "Value *" var " = (Value *)&" struct ";" line-sep])]
      (c-static-val var [] {} struct)))

  (emit [hs]
    (for [expr (encode (.set-map hs))
          var (genlocal "set_")]
      (-> expr
          (.c-var var)
          (.init (comp (.init expr) ["Value *" var " = newHashSet((List *)0, " (.c-var expr) ");" line-sep]))))))

(defn emit-tail-expr [ast expr]
  ;; TODO: periodically enable this to check on things
  ;; (print-err 'check (some return-assertions assert-return-type) return-type
  ;;            (ast/file-name ast) (ast/line-number ast))
  (collapse-expressions [expr
                         (c-code (.c-var expr)
                                 ["return(" (.c-var expr) ");" line-sep]
                                 {(.c-var expr) 1}
                                 c/top-type)]))

(deftype TailCall [ast params]
  (assert (instance? Vector params))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))

  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                  (instance? Tagged (.call-target ast))))
                  target (emit (.call-target ast))
                  _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                  args (ev/traverse (.args ast) emit)
                  line (line-macro ast "// recursive-fixed")]
              (do
                ;; TODO: was comp*
                ;; (collapse-expressions (comp args
                ;;                             [(c-code ""
                ;;                                      [line
                ;;                                       (map (zip-lists params (map args .c-var))
                ;;                                            (fn [[param arg]]
                ;;                                              [param " = " arg ";" line-sep]))]
                ;;                                      {} c/top-type)]))
                (comp* empty-c-code (comp args
                                          [(c-code ""
                                                   [line
                                                    (map (zip-lists params (map args .c-var))
                                                         (fn [[param arg]]
                                                           [param " = " arg ";" line-sep]))]
                                                   {} c/top-type)]))))
            (for [expr (emit ast)
                  curr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
                  result-const (sm/get-in-val [.fn-context .subs 0 "#result"] c/top-type)
                  :let [expr (either (and (instance? Tagged ast)
                                          (maybe (.refs-map expr {})))
                                     expr)
                        check-result (either (and (instance? c-param expr)
                                                  (maybe ""))
                                             (runtime-check (c/update-var result-const (.c-var expr))
                                                            curr-const
                                                            file-name line-number))]
                  _ (constrain-var file-name line-number (.c-var expr) result-const)
                  final-expr (emit-tail-expr ast (.init expr [(.init expr) check-result]))]
              final-expr)))))

(defn make-static-string [str-val]
  ;; TODO: when adding meta data, make sure to update this as well
  (let [str-len (count str-val)]
    (for [expr (comp (sm/get-in-val [.constants .strings str-val])
                     (for [str-idx (sm/new-sm (fn [s]
                                                (assert (instance? GlobalContext s))
                                                (-> s
                                                    .constants
                                                    .strings
                                                    count
                                                    (vector s)
                                                    maybe)))
                           :let [str-sym (str "str" str-idx)
                                 str-ptr (str "strPtr" str-idx)
                                 constraint (c/TypeConstraint {StringBufferType #{}}
                                                              empty-list 'String nothing str-ptr)]
                           _ (sm/assoc-in-val [.constants .strings str-val]
                                              (c-static-str str-ptr [] {} constraint str-sym))
                           _ (declare ["struct {TYPE_SIZE type;
        REFS_SIZE refs;
        int64_t len;
        Integer *hash;
        char buffer["
                                       (inc str-len)
                                       "];\n} " str-sym " = {StringBufferType, -1, "
                                       str-len ", 0, \"" (escape-chars str-val) "\"};\n"
                                       "Value *" str-ptr " = (Value *)&" str-sym ";\n"])]
                       (c-static-str str-ptr [] {} constraint str-sym)))
          _ (constrain-var "" 0 (.c-var expr) (.constraints expr))]
      expr)))

(extend-type String
  Emitter
  (emit [str-val]
    (make-static-string str-val)))

(defn make-static-num [num]
  (for [expr (comp (sm/get-in-val [.constants .numbers num])
                   (for [num-idx (sm/new-sm (fn [s]
                                              (assert (instance? GlobalContext s))
                                              (-> s
                                                  .constants
                                                  .numbers
                                                  count
                                                  (vector s)
                                                  maybe)))
                         :let [num-sym (str "num" num-idx)
                               num-ptr (str "numPtr" num-idx)
                               constraint (c/StaticIntConstraint num empty-list nothing num-ptr)
                               var (c-static-int num-ptr [] {} constraint num-sym)]
                         _ (sm/assoc-in-val [.constants .numbers num] var)
                         _ (declare ["Integer " num-sym " = {IntegerType, -2, " num "};\n"
                                     "Value *" num-ptr " = (Value *)&" num-sym ";\n"])]
                     var))
        _ (constrain-var "" 0 (.c-var expr) (.constraints expr))]
    expr))

(extend-type Integer
  Emitter
  (emit [num]
    (make-static-num num)))

(extend-type ast/quoted-ast
  Emitter
  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)
                        constraint (c/update-path sym-constraint
                                                (ast/file-name ast) (ast/line-number ast))]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-static-sym sym-ptr [] {} constraint sym-var))
                  _ (constrain-var (ast/file-name ast) (ast/line-number ast)
                                   sym-ptr constraint)
                  _ (declare ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                              ", 0, 0, \"" sym "\"};\n"
                              "Value *" sym-ptr " = (Value *)&" sym-var ";\n"])]
              (c-static-sym sym-ptr [] {} constraint sym-var))))))


(def LiteralValues (comp ast/quoted-ast
                         ast/string-ast
                         ast/integer-ast
                         Integer
                         String))

(extend-type LiteralValues
  Emitter
  (encode-static [n]
    (emit n))

  (replace-syms [ast _]
    (wrap sm/zero-sm ast))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params]
    (TailCall x params)))

(defn update-constraint [var f]
  (update-subs (flat-map (typ/get-constraint var)
                          (fn [c]
                            (typ/set-constraint var (f c))))))

(extend-type ast/string-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-string (.string ast))
          _ (update-constraint (.c-var expr)
                               (fn [c]
                                 (c/update-path c (ast/file-name ast) (ast/line-number ast))))]
      expr)))

(extend-type ast/integer-ast
  Emitter
  (emit [ast]
    (for [expr (make-static-num (.int ast))
          _ (update-constraint (.c-var expr)
                               (fn [c]
                                 (c/update-path c (ast/file-name ast) (ast/line-number ast))))]
      expr)))

(defn call-vector [target args]
  (assert (instance? Vector args))

  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [vect-sym (genlocal "newVect")
          result-sym (genlocal "vect")
          line (line-macro target "// call-vector")
          _ (update-subs
             (typ/constrain-contents result-sym vect-constraint (map args .c-var) file-name line-number))]
      (c-init result-sym
              [line
               "Vector *" vect-sym " = empty_vect;" line-sep
               (map args
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [vect-sym " = mutateVectConj(" vect-sym ", "
                         arg-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
              {} file-name line-number))))

(defn call-list [target args]
  (assert (instance? Vector args))

  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [line (line-macro target "// call-list")
          list-sym (genlocal "newList")
          result-sym (genlocal "list")
          _ (update-subs
             (typ/constrain-contents result-sym list-constraint (map args .c-var) file-name line-number))]
      (c-init result-sym
              [line "List *" list-sym " = empty_list;" line-sep
               (map (reverse args)
                    (fn [arg]
                      (let [arg-sym (.c-var arg)]
                        [list-sym " = listCons(" "(Value *)" arg-sym
                         ", " list-sym ");" line-sep])))
               "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
              {} file-name line-number))))

(defn call-maybe [target arg]
  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [line (line-macro target "// call-maybe")
          result-sym (genlocal "maybe")
          _ (update-subs
             (typ/propogate-constraint (.c-var arg) result-sym
                                       (fn [inner]
                                         (either (= inner c/top-type)
                                                 (c/intersect maybe-constraint
                                                              (c/InferredInner inner empty-list
                                                                               nothing result-sym))))
                                       file-name line-number))]
      (c-init result-sym
              [line "Value *" result-sym " = (Value *)maybe((List *)0, (Value *)0, " (.c-var arg) ");" line-sep]
              {} file-name line-number))))

(def conj-like #{'conj 'store 'mutate-vect-conj})

(defn add-contents-constraint [ast result args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)
        target (.call-target ast)]
    (either (or (for [_ (= target 'cons)
                      v (first args)
                      coll (second args)]
                  (let [v-var (.c-var v)
                        coll-var (.c-var coll)]
                    (update-subs (for [v-const (typ/get-constraint v-var)
                                       coll-const (typ/get-constraint coll-var)
                                       :let [coll-type (c/extract-coll-type coll-const)]
                                       _ (typ/append-constraint v-var (either (get coll-type .constraints)
                                                                              c/top-type)
                                                                file-name line-number)
                                       _ (typ/append-constraint result
                                                                (c/ItemsConstraint [v-const] coll-const
                                                                                   empty-list nothing result)
                                                                file-name line-number)
                                       _ (typ/append-constraint result
                                                                (c/extract-coll-type coll-const)
                                                                file-name line-number)]
                                   '_))))
                (map (or (for [_ (conj-like target)
                               coll (first args)
                               v (second args)]
                           [coll v])
                         (for [_ (= target 'assoc)
                               coll (first args)
                               v (nth args 2)]
                           [coll v]))
                     (fn [[coll v]]
                       (let [v-var (.c-var v)
                             coll-var (.c-var coll)]
                         (update-subs (for [v-const (typ/get-constraint v-var)
                                            coll-const (typ/get-constraint coll-var)
                                            :let [coll-type (c/extract-coll-type coll-const)
                                                  _ (either (c/compose-constraints file-name line-number
                                                                                   (c/update-path
                                                                                    (c/ItemsConstraint [v-const]
                                                                                                       c/top-type
                                                                                                       empty-list
                                                                                                       nothing result)
                                                                                    file-name line-number)
                                                                                   (c/update-path coll-type
                                                                                                  file-name line-number))
                                                            (abort))]
                                            _ (typ/append-constraint
                                               v-var
                                               (either (map (instance? c/CollectionOf coll-type) .constraints)
                                                       c/top-type)
                                               file-name line-number)
                                            _ (typ/append-constraint result coll-type file-name line-number)]
                                        '_))))))
            (wrap sm/zero-sm '_))))

(defn inner-constraint-for-reduce [result-var ast args]
  (and (= (.call-target ast) 'reduce)
       (= 3 (count args))
       (let [[v initial-val f] (take args 3)
             file-name (ast/file-name ast)
             line-number (ast/line-number ast)]
         (for [arity-info (or (get-in f [.arities 2])
                              (get-in f [.arities 'variadic]))]
           (let [inner-const (either (map (-> arity-info .param-constraints c/extract-items-constraints second)
                                          (fn [c]
                                            (c/InferredInner c (list [file-name line-number])
                                                             nothing (.c-var v))))
                                     c/top-type)
                 init-const (either (-> arity-info .param-constraints c/extract-items-constraints first)
                                    c/top-type)
                 result-c (.result-constraint arity-info)]
             (for [_ (constrain-var file-name line-number (.c-var v) inner-const)
                   _ (constrain-var file-name line-number (.c-var initial-val) init-const)
                   _ (constrain-var file-name line-number result-var result-c)]
               '_))))))

(def ignore-result-type #{'split-with 'filter 'drop-while 'take-while})
(def map-fns #{'map 'map-vals 'list-map 'maybe-map 'add-promise-action 'add-future-action})

(defn add-inner-constraint [result-var ast args]
  (or (inner-constraint-for-reduce result-var ast args)
      (let [file-name (ast/file-name ast)
            line-number (ast/line-number ast)]
        (and (or (map-fns (.call-target ast))
                 (= (.call-target ast) 'flat-map)
                 (ignore-result-type (.call-target ast)))
             (< 1 (count args))
             (let [[v f] (take args 2)]
               (for [arity-info (or (get-in f [.arities 1])
                                    (get-in f [.arities 'variadic]))]
                 (let [inner-const (either (map (-> arity-info .param-constraints c/extract-items-constraints first)
                                                (fn [c]
                                                  (c/InferredInner c (list [file-name line-number])
                                                                   nothing (.c-var v))))
                                           c/top-type)
                       result-c (either (or (and (map-fns (.call-target ast))
                                                 (maybe (-> (c/InferredInner (.result-constraint arity-info)
                                                                             empty-list nothing "")
                                                            (c/update-path file-name line-number))))
                                       (and (= (.call-target ast) 'flat-map)
                                            (maybe (c/update-path (.result-constraint arity-info)
                                                                  file-name line-number))))
                                   c/top-type)]
                   (for [_ (constrain-var file-name line-number (.c-var v) inner-const)
                         _ (constrain-var file-name line-number result-var result-c)]
                     '_))))))))

(defn constrain-args [arg-vars param-constraints file-name line-number]
  (ev/traverse (zip-lists arg-vars
                          (c/extract-items-constraints param-constraints))
               (fn [[expr constraint]]
                 (let [var (.c-var expr)]
                   (for [curr-const (sm/get-in-val [.fn-context .subs 0 var] c/top-type)
                         _ (constrain-var file-name line-number var constraint)]
                     (either (and (instance? c-param expr)
                                  (maybe ""))
                             (-> constraint
                                 (c/update-var var)
                                 (runtime-check curr-const file-name line-number))))))))

(defn call-proto-impl [arg-vars ast]
  (let [target (.call-target ast)
        num-args (count arg-vars)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [dispatch-var (map (sm/when (first arg-vars)) .c-var)
          disp-type  (var-type-num dispatch-var)
          ;; _ (debug 'cpi file-name line-number (.call-target ast) (first arg-vars) dispatch-var disp-type)
          :when-not (= UnknownType disp-type)
          result-sym (genlocal "rslt")
          impl-info (get-proto-impl target num-args disp-type)
          ;; _ (debug 'cpi file-name line-number target disp-type "\n"
          ;;          (.param-constraints impl-info) "\n"
          ;;          result-sym (.result-constraint impl-info))
          ;; _ (debug 'arg-vars arg-vars)
          _ (comp (sm/update-in-val [.constants .other 'type-known-sites] inc)
                  (sm/assoc-in-val [.constants .other 'type-known-sites] 1))
          check-args (constrain-args arg-vars (.param-constraints impl-info)
                                     file-name line-number)
          _ (constrain-var file-name line-number result-sym (.result-constraint impl-info))
          _ (ev/traverse (zip-lists (map arg-vars .c-var)
                                    (c/extract-items-constraints (.param-constraints impl-info)))
                         (fn [[var constraint]]
                           (constrain-var file-name line-number var constraint)))
          line (line-macro target (str "// call proto fn " target))
          _ (either (add-inner-constraint result-sym ast arg-vars)
                    (wrap sm/zero-sm '_))
          _ (add-contents-constraint ast result-sym  arg-vars)]
      (c-init result-sym
              [line
               check-args
               "Value *" result-sym " = " (.c-fn impl-info) "("
               (interpose (list* "(List *)0" (map arg-vars .c-var)) ", ")
               ");" line-sep]
              {} file-name line-number))))

(defn inline-wrap-and-apply [name args]
  (for [dispatch-ast (first args)
        wrapped (second args)]
    (for [;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          dispatch-val (emit dispatch-ast)
          dispatch-type (var-type-num (.c-var dispatch-val))
          :when-not (= UnknownType dispatch-type)
          impl-ast (map (get-proto-impl name (count args) dispatch-type)
                        .ast)
          :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))
          new-ast (-> impl-ast
                      (replace-bound-vars {})
                      (inline-expr (list dispatch-val wrapped)))]
      new-ast)))

(defn inline-flat-map [name args]
  (for [dispatch-ast (first args)
        f-ast (second args)]
    (for [;; _ (debug 'inlining (ast/file-name name) (ast/line-number name) "\n" (ast/call-ast name args))
          dispatch-val (emit dispatch-ast)
          dispatch-type (var-type-num (.c-var dispatch-val))
          :when-not (= UnknownType dispatch-type)
          impl-ast (map (get-proto-impl name 2 dispatch-type)
                        .ast)
          :when-not (some (.body impl-ast) (partial instance? ast/inline-ast))
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (ev/traverse (.body impl-ast)
                                  (fn [ast]
                                    (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(extend-type Tagged
  Emitter
  (get-param-constraints [sym subs]
    (for [expr (lookup-sym (rdr/tag sym))]
      (-> (get subs (.c-var expr) c/top-type)
          (c/update-var (.c-var expr))
          (c/update-sym sym))))

  (bind-param [binding expr]
    (for [r (bind binding expr)
          _ (set-sym binding (c-param (.c-var expr) [] {(.c-var expr) 1} c/top-type
                                      (ast/file-name binding) (ast/line-number binding)))]
      r))

  (bind-param [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] {arg-var 1} c/top-type)]
          r (bind-param binding arg)]
      r))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg (c-code arg-var [] {arg-var 1} c/top-type)]
          r (bind binding arg)]
      r))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (let [file-name (ast/file-name binding)
          line-number (ast/line-number binding)]
      
      (for [_ (comp (redef-proto-fn-error binding)
                    (set-sym binding (c-code (.c-var evalled) [] {(.c-var evalled) 1}
                                             c/top-type)))]
        (either (and (empty? (.init evalled))
                     (maybe (ParamBinding (.c-var evalled) [] "" [evalled])))
                (ParamBinding (.c-var evalled)
                              [] ""
                              [(c-init (.c-var evalled) (.init evalled)
                                       (.refs-map evalled) file-name line-number)])))))

  (emit [sym]
    (lookup-sym (rdr/tag sym)))

  (emit-defined-value [sym defined-sym]
    (for [value (emit (rdr/tag sym))
          _ (new-module-def defined-sym value)]
      [value]))

  (tail-call [ast params]
    (TailCall ast params))

  (replace-syms [ast subs]
    (wrap sm/zero-sm (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (remove arg-asts (partial instance? ast/NoCode))
          num-args (count args)]
      (either (or (and (or (= name 'wrap)
                           (= name 'apply))
                       (inline-wrap-and-apply name args))
                  (and (or (= name 'flat-map)
                           (= name 'map))
                       (inline-flat-map name args)))
              sm/zero-sm)))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))

(extend-type rdr/tagged-symbol
  Emitter
  (encode-static [x]
    (emit (ast/quoted-ast (.sym x)))))

(extend-type Symbol
  Emitter
  (encode-static [sym]
    (emit (ast/quoted-ast sym))))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [target-lang (wrap sm/zero-sm 'C)
            :when (= (.lang ast) target-lang)
            line-info (line-macro ast "// inline")
            :let [init [line-info (.txt ast) "\n#\n"]]

            expr (comp (for [type-sym (sm/when (.result-type ast))
                             ns-path (sym-ns-path type-sym)
                             type-map (get-type-info ns-path type-sym)
                             c-var (genlocal "rslt")
                             :let [constraint (c/TypeConstraint type-map
                                                                (list [file-name line-number])
                                                                type-sym nothing "")]
                             _ (constrain-var file-name line-number c-var constraint)]
                         (c-code c-var init {} constraint))
                       (wrap sm/zero-sm (c-code "" init {} c/top-type)))]
        expr)))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] {} constraint))
          line-info (line-macro ast "// inline")
          _ (declare [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"])]
      [(c-code c-var [] {} constraint)]))

  (emit-definition [ast]
    (for [target-lang (wrap sm/zero-sm 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          _ (declare [(.txt ast)])]
      [empty-c-code]))

  (tail-call [ast params]
    ast)

  (replace-syms [ast _]
    (wrap sm/zero-sm ast)))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (ev/traverse (.value-exprs ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] {} c/top-type)]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))
                  _ (declare ["Value *" c-var ";\n"])]
              [(.c-var c-info "")])))))

(extend-type StaticFnPtr
  Emitter
  (call-site-meta-data [v f l]
    (wrap sm/zero-sm (c-code "empty_list" [] {} c/top-type)))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'static-fixed-sites] inc)
          (sm/assoc-in-val [.constants .other 'static-fixed-sites] 1))))

(extend-type ProtoDispFnPtr
  Emitter
  (call-site-meta-data [_ file-name line-number]
    (let [str-val (str "at " file-name ": " line-number)]
      (map (make-static-string str-val)
           (fn [expr]
             (.c-var expr (str "(List *)" (.c-var expr)))))))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'proto-dispatch-sites] inc)
          (sm/assoc-in-val [.constants .other 'proto-dispatch-sites] 1))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arity-info arg-vars ast]
  (assert (instance? StaticArity arity-info))

  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [result-sym (genlocal "rslt")
          ;; _ (debug 'csf file-name line-number (.call-target ast) (.c-var target) "\n"
          ;;          (.param-constraints arity-info) "\n"
          ;;          result-sym (.result-constraint arity-info))
          ;; _ (debug 'arg-vars arg-vars)
          _ (constrain-var file-name line-number result-sym (.result-constraint arity-info))
          check-args (constrain-args arg-vars (.param-constraints arity-info)
                                     file-name line-number)

          _ (update-call-site-count (.c-var arity-info))
          line (line-macro ast "// static-fixed")
          call-site-location (call-site-meta-data (.c-var arity-info) file-name line-number)]
      (c-init result-sym
              [check-args
               line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (cons (.c-var call-site-location)
                                (seq (map arg-vars .c-var))) ", ") ");" line-sep]
              {} file-name line-number))))

(defn call-static-variadic [target arity-info arg-vars ast]
  (assert (instance? StaticArity arity-info))

  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [_ (comp (sm/update-in-val [.constants .other 'static-variadic-sites] inc)
                  (sm/assoc-in-val [.constants .other 'static-variadic-sites] 1))
          args-list (call-list (rdr/tag 'list file-name line-number)
                               (map arg-vars (fn [arg]
                                               (.init arg []))))
          result-sym (genlocal "rslt")
          ;; _ (debug 'csv file-name line-number (.call-target ast) (.c-var target) "\n"
          ;;          (.param-constraints arity-info) "\n"
          ;;          result-sym (.result-constraint arity-info))
          _ (constrain-var file-name line-number result-sym (.result-constraint arity-info))
          check-args (constrain-args arg-vars (.param-constraints arity-info)
                                     file-name line-number)
          _ (constrain-var file-name line-number (.c-var args-list) (.param-constraints arity-info))
          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               check-args
               line
               "Value *" result-sym " = " (.c-var arity-info) "((List *)0, (Value *)"
               (.c-var args-list) ");" line-sep]
              {} (ast/file-name ast) (ast/line-number ast)))))

(defn call-dyn-fn-value [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (for [arity-sym (genlocal "arity")
        type-num (var-type-num (.c-var target))
        :when (= FunctionType type-num)
        result-sym (genlocal "rslt")
        ;; _ (debug 'cdf (ast/file-name ast) (ast/line-number ast) (.call-target ast) (.c-var target) "\n"
        ;;          result-sym)
        ;; _ (debug 'target target)
        _ (comp (sm/update-in-val [.constants .other 'dyn-fn-sites] inc)
                (sm/assoc-in-val [.constants .other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        line (line-macro ast "// dynamic fn type")]
    (let [args (map args .c-var)
          arg-syms (comp [(str arity-sym "->closures")] args)
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              {} (ast/file-name ast) (ast/line-number ast)))))

(def symbols-sym (symbol "#symbols"))
(def protocols-sym (symbol "#protocols"))
(def invoke-sym (rdr/tag 'invoke 'core 0))
(def Type-sym (rdr/tag 'Type 'core 0))
(def Function-sym (rdr/tag 'Function 'core 0))
(def Container-sym (rdr/tag 'Container 'core 0))
(def Stringable-sym (rdr/tag 'Stringable 'core 0))
(def type-name-sym (rdr/tag 'type-name 'core 0))
(def type-mapping-sym (rdr/tag 'type-mapping 'core 0))
(def =*-sym (rdr/tag '=* 'core 0))
(def apply-sym (rdr/tag 'apply 'core 0))
(def get-type-sym (rdr/tag 'reified-get-type 'core 0))
(def extract-sym (rdr/tag 'extract 'core 0))
(def instance?-sym (rdr/tag 'instance? 'core 0))
(def string-list-sym (rdr/tag 'string-list 'core 0))
(def list-sym (rdr/tag 'list 'core 0))
(def has-field-sym (rdr/tag 'has-field 'core 0))
(def identical-sym (rdr/tag 'identical 'core 0))
(def Eq-sym (rdr/tag 'Eq 'core 0))
(def Associative-sym (rdr/tag 'Associative 'core 0))
(def get-symb (rdr/tag 'get 'core 0))
(def maybe-sym (rdr/tag 'maybe 'core 0))
(def HashMapNode-sym (rdr/tag 'HashMapNode 'core 0))
(def Hashable-sym (rdr/tag 'Hashable 'core 0))
(def sha1-sym (rdr/tag 'sha1 'core 0))
(def sha1-update-sym (rdr/tag 'sha1-update 'core 0))
(def sha1-init-sym (rdr/tag 'sha1-init 'core 0))
(def sha1-finalize-sym (rdr/tag 'sha1-finalize 'core 0))
(def sha1-update-type-sym (rdr/tag 'sha1-update-type 'core 0))
(def assoc-sym (rdr/tag 'assoc 'core 0))
(def update-field-sym (rdr/tag 'update-field 'core 0))
(def store-sym (rdr/tag 'store 'core 0))
(def reified-type-args-sym (rdr/tag 'reified-type-args 'core 0))
(def get-field-sym (rdr/tag 'get-field 'core 0))
(def nth-sym (rdr/tag 'nth 'core 0))
(def partial-sym (rdr/tag 'partial 'core 0))
(def some-sym (rdr/tag 'some 'core 0))
(def nothing-sym (rdr/tag 'nothing 'core 0))

(defn call-dyn-unknown-type [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [num-args (count args)
        num-invoke-args (inc num-args)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (lookup-core-fn-arity invoke-sym num-invoke-args)
          _ (comp (sm/update-in-val [.constants .other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.constants .other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")
          sym-location (emit (either (= "\"\"" file-name)
                                     (str "\"at " file-name ": " line-number "\"")))]
      (let [args (map args .c-var)
            arg-syms (comp [(str arity-sym "->closures")] args)]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                 result-sym " = " invoke-arity-sym "("
                 (interpose (list* (str "(List *)" (.c-var sym-location))
                                   (.c-var target) args) ", ") ");"
                 line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                 line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                {} file-name line-number)))))

(defn call-invoke [target arg-vars ast]
  (let [arg-vars (comp [target] arg-vars)
        num-args (count arg-vars)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [target-type (var-type-num (.c-var target))
          :when-not (= UnknownType target-type)
          invoke-info (get-proto-impl Function-sym invoke-sym num-args target-type)
          _ (comp (sm/update-in-val [.constants .other 'invoke-sites] inc)
                  (sm/assoc-in-val [.constants .other 'invoke-sites] 1))
          result-sym (genlocal "rslt")
          ;; _ (debug 'ci file-name line-number target num-args 'target-type target-type "\n"
          ;;          (.param-constraints invoke-info) "\n"
          ;;          result-sym (.result-constraint invoke-info))
          ;; _ (debug 'arg-vars arg-vars)
          ;; _ (debug 'param-consts (.param-constraints invoke-info))
          check-args (constrain-args arg-vars (.param-constraints invoke-info)
                                     file-name line-number)

          _ (constrain-var file-name line-number result-sym (.result-constraint invoke-info))
          _ (ev/traverse (zip-lists (map arg-vars .c-var)
                                    (c/extract-items-constraints (.param-constraints invoke-info)))
                         (fn [[var constraint]]
                           (constrain-var file-name line-number var constraint)))

          ;; _ (debug "-----")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line check-args
               "Value *" result-sym " = " (.c-fn invoke-info) "("
               (interpose (list* "(List *)0" (map arg-vars .c-var)) ", ")
               ");" line-sep]
              {} file-name line-number))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(defprotocol CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (call-dyn-fn-value target args ast)
          (call-dyn-unknown-type target args ast))))

(extend-type c-static-reified
  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(extend-type c-constructor
  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(defn static-call-site [target args ast]
  (comp (for [fn-info (sm/get-in-val [.fns (.c-var target)])
              expr (either (or (map (get fn-info (count args))
                                    (fn [arity-info]
                                      (call-static-fixed target arity-info args ast)))
                               (map (get fn-info 'variadic)
                                    (fn [arity-info]
                                      (call-static-variadic target arity-info args ast))))
                           sm/zero-sm)
              _ (either (add-inner-constraint (.c-var expr) ast args)
                        (wrap sm/zero-sm '_))
              _ (add-contents-constraint ast (.c-var expr) args)]
          expr)
        (compilation-error "No arity with" (count args) "arguments found"
                           (either (map (instance? Tagged (.call-target ast))
                                        (fn [sym]
                                          (str "for '" sym "'")))
                                   "")
                           "at:" (ast/file-name ast) (ast/line-number ast))))

(extend-type c-maybe-fn
  CallSite
  (emit-call-site [target args ast]
    (either (map (and (= 1 (count args))
                      (first args))
                 (partial call-maybe (.call-target ast)))
            (compilation-error "Call to 'maybe' in" (ast/file-name ast) "at line" (ast/line-number ast)
                               "has the wrong number of arguments. Only a single argument is valid."))))

(extend-type c-list-fn
  CallSite
  (emit-call-site [target args ast]
    (call-list (.call-target ast) args)))

(extend-type c-vector-fn
  CallSite
  (emit-call-site [target args ast]
    (call-vector (.call-target ast) args)))

(extend-type c-static-fn
  CallSite
  (emit-call-site [target args ast]
    (static-call-site target args ast)))

;; TODO: test add-inner-constraint on state-maybe values
;; TODO: possible contenders to add; apply
;; TODO: add inner constraint to Strings
;; TODO: insert InferredInner into anon fn passed to higher order fn

(def returns-inner #{'seq 'vec 'rest 'butlast 'reverse 'vals 'last 'nth 'get 'first})

(defn propogate-inner-constraint [result-var ast args]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    ;; TODO: do hash-seq as well
    (for [_ (or (returns-inner (.call-target ast))
                (= (.call-target ast) 'extract))
          arg (first args)]
      (update-subs
       (typ/propogate-constraint (.c-var arg) result-var
                                 (fn [constraint]
                                   (let [inner-c (c/extract-inner-constraint constraint)]
                                     (either (or (= inner-c c/top-type)
                                                 (and (= (.call-target ast) 'extract)
                                                      (maybe (.inner inner-c))))
                                             inner-c)))
                                 file-name line-number)))))

(extend-type c-protocol-fn
  CallSite
  (emit-call-site [target args ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [expr (comp (call-proto-impl args ast)
                       (static-call-site target args ast))
            _ (either (propogate-inner-constraint (.c-var expr) ast args)
                      (wrap sm/zero-sm '_))
            _ (either (for [_ (= (.call-target ast) 'wrap)
                            _ (or (= 2 (count args))
                                  (do
                                    (print-err "Wrong number of arguments to 'wrap' in"
                                               file-name "at line" line-number)
                                    (maybe (abort))))
                            wrapped (second args)]
                        (update-subs
                         (typ/propogate-constraint (.c-var wrapped) (.c-var expr)
                                                   (fn [inner]
                                                     (c/InferredInner inner empty-list nothing ""))
                                                   file-name line-number)))
                      (wrap sm/zero-sm '_))]
        expr))))

(defn define-sum-type [fn-val defined-sym]
  (either (map (= (.call-target fn-val) 'comp*)
               (fn [_]
                 (let [[type-sym type-syms] (.args fn-val)
                       type-syms (cons type-sym (seq (.args type-syms)))
                       file-name (ast/file-name defined-sym)
                       line-number (ast/line-number defined-sym)]
                   (for [types-info (ev/traverse type-syms get-type-sym-info)
                         :when-not (empty? (remove types-info empty?))
                         :let [_ (map (zip-lists type-syms types-info)
                                      (fn [[sym info]]
                                        (and (empty? info)
                                             (do
                                               (print-err "Unknown type" (str "'" sym "'") "at"
                                                          (str file-name ":") line-number)
                                               (maybe (abort))))))
                               types-info (reduce types-info {} comp)
                               reified-type-num (extract rdr/type-counter)
                               x* (rdr/tag "#x")
                               y* (rdr/tag "#y")]
                         _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                                            reified-type-num)
                         _ (sm/assoc-in-val [.type-maps reified-type-num] (TypeInfo defined-sym types-info))
                         exprs (emit-defined-value
                                (ast/reified
                                 reified-type-num
                                 {Eq-sym
                                  {=*-sym
                                   [(ast/fn-arity-ast
                                     (str defined-sym "_EQ_QMARK_") ""
                                     (ast/params [x* y*]) ""
                                     [(ast/call-ast =*-sym
                                                    [reified-type-num
                                                     (ast/call-ast get-type-sym [y*])])]
                                     [] c/top-type)]}

                                  Type-sym
                                  {instance?-sym
                                   [(ast/fn-arity-ast
                                     (str defined-sym "_instance_QMARK_") ""
                                     (ast/params [x* y*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast some-sym
                                                      [(ast/call-ast list-sym (vec (keys types-info)))
                                                       (ast/call-ast partial-sym
                                                                     [=*-sym
                                                                      (ast/call-ast get-type-sym [y*])])])
                                        (ast/call-ast maybe-sym [y*])])]
                                     [] c/top-type)]

                                   type-mapping-sym
                                   [(ast/fn-arity-ast
                                     (str defined-sym "_type_mapping") ""
                                     (ast/params [x*]) ""
                                     [(map-vals types-info (fn [field-set]
                                                             (map field-set ast/quoted-ast)))]
                                     [] c/top-type)]}

                                  Stringable-sym
                                  {string-list-sym
                                   [(ast/fn-arity (ast/params [x*]) ""
                                                  [(ast/call-ast list-sym ["<SumType " (str defined-sym) ">"])])]}})
                                defined-sym)]
                     exprs))))
          sm/zero-sm))

(defn define-enum-type [fn-val defined-sym]
  (for [_ (sm/when (= (.call-target fn-val) 'enum))
        type-maps (comp (ev/traverse (.args fn-val)
                                     (fn [sym]
                                       (comp (flat-map (sm/get-in-val [.modules (ast/file-name sym) .types sym])
                                                       (fn [_]
                                                         (compilation-error "Invalid enum value " (str "'" sym "'")
                                                                            " at:" (ast/file-name defined-sym)
                                                                            (ast/line-number defined-sym))))
                                             (for [expr (comp (find-global-sym sym)
                                                              (compilation-error "Invalid enum value " (str "'" sym "'")
                                                                                 " at:" (ast/file-name defined-sym)
                                                                                 (ast/line-number defined-sym)))
                                                   :when (instance? c-static-reified expr)
                                                   type-map (sm/when (-> expr
                                                                         expr-constraints
                                                                         c/extract-type-map))]
                                               type-map))))
                        (compilation-error "Invalid enum values at:"
                                           (ast/file-name defined-sym) (ast/line-number defined-sym)))
        :let [type-map (comp* {} type-maps)
              reified-type-num (extract rdr/type-counter)
              x* (rdr/tag "#x")
              y* (rdr/tag "#y")]
        _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                           reified-type-num)
        _ (sm/assoc-in-val [.type-maps reified-type-num]
                           (TypeInfo defined-sym type-map))
        exprs (emit-defined-value
               (ast/reified
                reified-type-num
                {Type-sym
                 {instance?-sym
                  [(ast/fn-arity-ast
                    (str defined-sym "_instance_QMARK_") ""
                    (ast/params [x* y*]) ""
                    [(ast/and-ast
                      [(ast/call-ast some-sym
                                     [(ast/call-ast list-sym (vec (keys type-map)))
                                      (ast/call-ast partial-sym
                                                    [=*-sym (ast/call-ast get-type-sym [y*])])])
                       (ast/call-ast maybe-sym [y*])])]
                    [] c/top-type)]

                  type-mapping-sym
                  [(ast/fn-arity-ast
                    (str defined-sym "_type_mapping") ""
                    (ast/params [x*]) ""
                    [(map-vals type-map (fn [field-set]
                                          (map field-set ast/quoted-ast)))]
                    [] c/top-type)]}

                 Stringable-sym
                 {string-list-sym
                  [(ast/fn-arity (ast/params ['z]) ""
                                 [(ast/call-ast list-sym
                                                ["<SumType " (str defined-sym) ">"])])]}})
               defined-sym)]
    exprs))

(defn init-at-runtime [ast defined-sym]
  (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
        fn-context (reset-fn-context (.subs init-fn-context [{}]))

        sym-var (emit (ast/quoted-ast defined-sym))
        map-var (lookup-sym (rdr/tag "#symbols" (ast/file-name ast) (ast/line-number ast)))

        value (emit ast)
        constraint (sm/get-in-val [.fn-context .subs 0 (.c-var value)] c/top-type)
        init-fn-context (reset-fn-context fn-context)
        _ (constrain-var (ast/file-name ast) (ast/line-number ast) (.c-var value) constraint)
        _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)]
    (.init value [(.init value)
                  (.c-var map-var) " = hashMapAssoc((Value *)" (.c-var map-var) ", "
                  (.c-var sym-var) ", " (.c-var value) ");\n"])))

(extend-type ast/call-ast
  Emitter
  (emit-defined-value [fn-val defined-sym]
    (comp (define-sum-type fn-val defined-sym)
          (define-enum-type fn-val defined-sym)
          (for [value (init-at-runtime fn-val defined-sym)
                constraint (sm/get-in-val [.fn-context .subs 0 (.c-var value)] c/top-type)
                var (comp (map (lookup-declaration defined-sym) .c-var)
                          (global-var defined-sym "var"))
                _ (new-module-def defined-sym (c-code var [] {} (c/update-var constraint var)))
                _ (declare ["Value *" var ";\n"])]
            [(c-init var [(.init value)
                          var " = " (.c-var value) ";" line-sep
                          var "->refs = -1;" line-sep "\n#\n"]
                     (.refs-map value) (ast/file-name fn-val) (ast/line-number fn-val))])))

  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    (either (and (instance? Symbol target-ast)
                                                 (maybe (rdr/tag target-ast)))
                                            target-ast))))]
      (comp (flat-map (inline-expr (.call-target ast) (.args ast))
                      (fn [x]
                        (for [r (emit x)
                              ;; _ (debug 'old "\n" ast)
                              ;; _ (debug 'new "\n" x)
                              ]
                          r)))
            (flat-map (ev/traverse (.args ast) emit)
                      (fn [args]
                        (comp (for [target (emit (.call-target ast))
                                    call-site (emit-call-site target args ast)]
                                (do
                                  ;; TODO: was comp*
                                  ;; (collapse-expressions (comp [target] args [call-site]))
                                  (comp* target (comp args [call-site]))))
                              (compilation-error "Could not compile call site at:"
                                                 file-name line-number)))))))

  (tail-call [ast params]
    (TailCall ast params))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (ev/traverse (.args ast) (fn [ast]
                                          (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    (either (for [_ (instance? ast/call-ast ast)
                  _ (= (.call-target ast) 'new-sm)
                  fn-ast (first (.args ast))]
              (inline-expr fn-ast arg-asts))
            (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                  new-ast (inline-expr new-call-target arg-asts)]
              new-ast)))

  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? Vector l))
    [ast]))

;; TODO: when a proto impl is wrong (ie; wrong number of args)
;; the error message is trash
(extend-type C-expr
  Emitter
  (tail-call [expr _]
    expr)

  (emit [x]
    (wrap sm/zero-sm x))

  (bind-list [list-var params bind-fn]
    (let [file-name (ast/file-name params)
          line-number (ast/line-number params)
          fixed-count (count (.fixed params))
          tail-sym (either (.variadic params)
                           (rdr/tag "restArgs"))
          list-var (.refs-map list-var (dissoc (.refs-map list-var) (.c-var list-var)))]
      (for [tail-binding (bind-fn tail-sym)
            _ (comp (sm/when (empty? (.init list-var)))
                    (set-sym (.c-var list-var) list-var))
            :let [tail-var (.bound tail-binding)]
            r (comp (sm/when (and (= 0 fixed-count)
                                  (maybe (ParamBinding (.c-var list-var)
                                                       [] tail-var
                                                       [list-var
                                                        (c-init tail-var ["Value *" tail-var " = seq((List *)0, "
                                                                          (.c-var list-var) ");" line-sep]
                                                                {(.c-var list-var) 1}
                                                                file-name line-number)]))))
                    (for [content-vars (ev/traverse (.fixed params)
                                                    (fn [target]
                                                      (genlocal target "arg")))
                          _ (constrain-var file-name line-number
                                           (.c-var list-var)
                                           (c/clear-sym (ast/assert-min-count "" fixed-count)))
                          _ (update-subs
                             (typ/propogate-contents-constraints (.c-var list-var) content-vars tail-var
                                                                 file-name line-number))
                          fixed-bindings (ev/traverse (vec (zip-lists (.fixed params)
                                                                      content-vars))
                                                      (fn [[target var]]
                                                        (bind-fn target (c-code var [] {} c/top-type))))
                          dest-args (genlocal "destArgs")]
                      (ParamBinding (.c-var list-var)
                                    fixed-bindings tail-var
                                    (comp [list-var
                                           (c-code ""
                                                   (destruct-seq (.c-var list-var)
                                                                 (conj content-vars tail-var)
                                                                 (str dest-args) file-name line-number)
                                                   {(.c-var list-var) 1} c/top-type)]
                                          (map (conj content-vars tail-var)
                                               (fn [var]
                                                 (c-init var [] {} file-name line-number)))
                                          (flat-map fixed-bindings .destruct)
                                          (.destruct tail-binding)))))]
        r))))

(extend-type c-code
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-param
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-constructor
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-reified
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-protocol-fn
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-int
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-str
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-sym
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type c-static-fn
  C-Code
  (expr-constraints [expr]
    (.constraints expr)))

(extend-type ast/params-ast
  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  Emitter
  (get-param-constraints [params subs]
    (for [items-constraints (ev/traverse (.fixed params) (fn [param]
                                                           (get-param-constraints param subs)))
          tail-constraint (either (map (.variadic params)
                                       (fn [param]
                                         (get-param-constraints param subs)))
                                  (wrap sm/zero-sm c/top-type))]
      (-> c/empty-items-constraint
          (c/update-path (ast/file-name params) (ast/line-number params))
          (.tail-constraint tail-constraint)
          (.items-constraints items-constraints))))

  (bind-param [params]
    (for [param-var (genlocal "arg")
          destruct (bind-param params (c-code param-var [] {} c/top-type))]
      destruct))

  (bind-param [params expr]
    (bind-list expr params bind-param))

  (bind [params]
    (for [param-var (genlocal "arg")
          destruct (bind-list (c-code param-var [] {} c/top-type)
                              params
                              bind)]
      destruct))

  (bind [params evalled]
    (bind-list evalled params bind))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [locals get-syms
            bindings (ev/traverse (.bindings ast) emit)
            body-exprs (ev/traverse (.body ast) emit)
            _ (ev/traverse bindings
                           (fn [binding]
                             (update-subs (constrain-params binding))))
            code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))
            result-var (either (map (= "" (.c-var code)) sm/state-maybe)
                               (genlocal "let_rslt"))
            _ (update-subs
               (typ/propogate-constraint (.c-var code) result-var identity
                                         file-name line-number))
            _ (set-syms locals)]
        (c-init result-var
                [(.init code)
                 (either (= "" result-var)
                         [line-sep "Value *" result-var " = " (.c-var code) ";" line-sep])]
                (.refs-map code) file-name line-number))))

  (emit-defined-value [ast defined-sym]
    (for [value (init-at-runtime ast defined-sym)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          val-constraint (sm/get-in-val [.fn-context .subs 0 (.c-var value)] c/top-type)
          _ (new-module-def defined-sym (c-code var [] {} val-constraint))
          _ (declare ["Value *" var ";\n"])]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               (.refs-map value) (ast/file-name ast) (ast/line-number ast))]))

  (tail-call [ast params]
    (.body ast (comp (filter (.body ast) (partial instance? c/Constraints))
                     (-> ast
                         .body
                         (remove (partial instance? ast/NoCode))
                         (tail-call params)))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (wrap sm/zero-sm new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))
          new-body (either (empty? (.body ast))
                           (let [[tail & init] (-> (.body ast)
                                                   (remove (partial instance? ast/NoCode))
                                                   reverse)]
                             (-> (ast/call-ast tail unique-syms)
                                 (cons init)
                                 reverse
                                 vec)))
          new-body (comp (filter (.body ast) (partial instance? c/Constraints))
                         new-body)]
      (wrap sm/zero-sm
            (ast/let-ast
             (comp (make-bindings unique-syms arg-asts)
                   (.bindings ast))
             new-body))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (rdr/tag (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body))))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns file-name line-number]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          _ (constrain-var file-name line-number
                           reified-sym (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>")
                                                         nothing reified-sym))]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = " (count impl-fns) ";" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (apply merge-with (list* + (map impl-fns .refs-map))) file-name line-number))))

(defn static-reified-value [file-name line-number type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")
        _ (constrain-var file-name line-number
                         reified-ptr
                         (c/TypeConstraint {type-num #{}} (list [file-name line-number])
                                           (symbol "<Reified Type Value>")
                                           nothing (str reified-ptr)))
        _ (declare ["ReifiedVal " reified-sym " = {"
                    type-num ", -2, "
                    "0, {}};" line-sep
                    "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep])]
    (c-static-reified reified-ptr [] {}
                      (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>")
                                        nothing (str reified-ptr))
                      reified-sym)))

(defprotocol ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (assert-result x (instance? sm/new-sm x))))

(defn new-static-arity [fn-ptr num-params arity-var param-constraints result-constraint]
  (assert (instance? CFnPtr arity-var))

  (sm/assoc-in-val [.fns fn-ptr num-params]
                   (StaticArityInfo arity-var param-constraints result-constraint)))

(deftype StaticArity [arity-fn-var c-fn param-count var-info param-constraints result-constraint]
  (assert (instance? CFnPtr c-fn))
  (assert (instance? C-expr var-info))

  Stringable
  (string-list [_]
    (list "(StaticArity " (str arity-fn-var) " " (str param-count) " "
          (str var-info) " " (str param-constraints) " " (str result-constraint)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (for [_ (sm/update-in-val [.reify-fn-index] inc)
          _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num (.c-var var-info) arity-ast
                            param-constraints result-constraint c-fn)]
      var-info)))

(deftype ClosureArity [arity-fn-var params param-count var-info param-constraints result-constraint]
  (assert (instance? CFnPtr arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (ev/traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num
                              (ArityValPtr (str "&" fn-arity-sym) fn-arity-sym) arity-ast
                              param-constraints result-constraint 
                              (StaticFnPtr (str impl-fn-sym)))
            _ (sm/update-in-val [.reify-fn-index] inc)
            _ (declare ["// implementation of " fn-name "\n"
                        "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                        "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                        ")->impls[" reify-fn-index "];" line-sep
                        "incRef(" dispArg ", 1);" line-sep
                        "if (arityPtr->count != " param-count ") {\n"
                        "fprintf(stderr, \"Booom\\n\");\nabort();\n}\n"
                        "Value *rval = ((FnType" param-count
                        " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                        "dec_and_free(" dispArg ", 1);" line-sep
                        "return(rval);" line-sep
                        "};\n\n"
                        "FnArity " fn-arity-sym " = {FnArityType, -2, " param-count
                        ", (List *)0, 0, " impl-fn-sym ", (Value *)0, (Value *)0};" line-sep])]
        var-info))))

(defn checking-fn [fn-sym params param-vars arity-fn-var constraints]
  (let [file-name (ast/file-name params)
        line-number (ast/line-number params)
        constraints-list (c/extract-items-constraints constraints)]
    (for [dest-args (genlocal "destArgs")
          checking-fn-var (global-var fn-sym "paramChecker")
          line (line-macro params "// paramChecker")]
      (either (or (and (.variadic params)
                       (maybe (c-code checking-fn-var
                                      ["Value *" checking-fn-var
                                       "(List *closures, Value *args) {\n"
                                       line
                                       (-> constraints
                                           (c/update-var "args")
                                           (runtime-check c/top-type file-name line-number))
                                       "return(" arity-fn-var
                                       "(closures, args));\n};\n"]
                                      {} c/top-type)))
                  (and (every constraints-list (partial = c/top-type))
                       (maybe (c-code arity-fn-var [] {} c/top-type))))
              (c-code checking-fn-var
                      ["Value *" checking-fn-var "("
                       (-> param-vars
                           (map (fn [param] (str "Value *" param)))
                           (seq)
                           (conj "List *closures")
                           (interpose ", "))
                       ") {\n"
                       line
                       (for [[constraint var] (zip-lists constraints-list
                                                         param-vars)]
                         (-> constraint
                             (c/update-var var)
                             (runtime-check c/top-type file-name line-number))) 
                       "return(" arity-fn-var "("
                       (-> param-vars
                           (seq)
                           (conj "closures")
                           (interpose ", "))
                       "));\n};\n"]
                      {} c/top-type)))))

(defn destruct-closures [closure-info]
  (for [destArgs (genlocal "destArgs")]
    (let [closures (-> closure-info
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)]
      (comp [(c-code ""
                      [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                       "incRef((Value *)closures, 1);" line-sep
                       "Value **" destArgs "[" closure-count "] = {"
                       (interpose (map closures (fn [arg] ["&" arg])) ", ")
                       "};" line-sep
                       "destructValue(\"\", \"\", (Value *)closures"
                       ", " closure-count ", " destArgs ");" line-sep]
                      {} c/top-type)]
            (map (seq closure-info)
                 (fn [[arg _ constraint]]
                   (c-init arg [] {} "" 0)))))))

(defn set-result-constraint [result-var file-name line-number]
  ;; TODO: shouldn't be returning the result-constraint
  (for [_ (update-subs (for [result-c (typ/get-constraint "#result")
                              var-c (typ/get-constraint result-var)
                              :let [final (c/intersect result-c var-c)
                                    _ (and (= c/bottom-type final)
                                           (do
                                             (print-err "Invalid return value for function at" file-name line-number)
                                             (c/conflicting-assertions final file-name line-number)
                                             (abort)))]
                              _ (typ/set-constraint result-var final)]
                          final))
        result-constraint (sm/get-in-val [.fn-context .subs 0 result-var])]
    result-constraint))

(defn emit-closure-arity [fn-sym fn-context c-fn params param-vars body-exprs]
  (assert (instance? CFnPtr c-fn))

  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [closures (sm/new-sm (fn [s]
                                (assert (instance? GlobalContext s))
                                (let [closures (-> s .fn-context .closed-over .closures)]
                                  (and (first closures)
                                       (maybe [closures s])))))
          closure-subs (sm/get-in-val [.fn-context .subs])
          closures-destruct (destruct-closures closures)
          body (collapse-expressions (comp closures-destruct
                                           body-exprs))
          
          param-constraints (flat-map (sm/get-in-val [.fn-context .subs 0] {})
                                      (fn [sub]
                                        (get-param-constraints params sub)))
          result-constraint (set-result-constraint (.c-var body) file-name line-number)
          _ (reset-fn-context fn-context)
          closed-over (ev/traverse closures (fn [[closed-over sym]]
                                              (map (lookup-sym sym)
                                                   (fn [expr]
                                                     [closed-over (.c-var expr)]))))
          _ (update-subs (typ/traverse (for [closure-sub closure-subs
                                             [closure outer] closed-over
                                             :let [closure-c (get closure-sub closure)]
                                             :when closure-c]
                                         [outer (extract closure-c)])
                                       (fn [[var constraint]]
                                         (typ/append-constraint var constraint file-name line-number))))
          arity-var (genlocal fn-sym "dynArity")
          closure-vars (ev/traverse closures (fn [[closed-over sym]]
                                               (for [closure (lookup-sym sym)]
                                                 (c-code ""
                                                         [arity-var "->closures = listCons((Value *)"
                                                          (.c-var closure) ", (List *)" arity-var
                                                          "->closures);" line-sep]
                                                         {(.c-var closure) 1}
                                                         (c/update-var list-constraint (str (.c-var closure)))))))

          line (line-macro fn-sym "// paramChecker")
          :let [check-params (either (for [_ (.variadic params)
                                           var-args (first param-vars)]
                                       (-> param-constraints
                                           (c/update-var var-args)
                                           (runtime-check c/top-type file-name line-number)))
                                     (for [[constraint var] (zip-lists (c/extract-items-constraints param-constraints)
                                                                       param-vars)]
                                       (-> constraint
                                           (c/update-var var)
                                           (runtime-check c/top-type file-name line-number))))] 
          _ (declare ["Value *" c-fn "("
                      (-> param-vars
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\n"
                      "\nwhile (1) {\n"
                      line
                      check-params
                      (.init body)
                      line-sep "};};\n"])
          :let [arity-init ["FnArity *" arity-var
                            " = malloc_fnArity();" line-sep
                            arity-var "->count = " (count param-vars)
                            ";" line-sep
                            arity-var "->variadic = "
                            (either (and (.variadic params)
                                         (maybe "1"))
                                    "0")
                            ";" line-sep
                            arity-var "->fn = " c-fn ";" line-sep
                            arity-var "->closures = empty_list;" line-sep]]
          expr (collapse-expressions (comp [(c-code arity-var arity-init {} c/top-type)]
                                           closure-vars
                                           [(c-init arity-var [] {} file-name line-number)]))]
      (ClosureArity c-fn params (either (and (.variadic params)
                                             (maybe 'variadic))
                                        (count params))
                    expr
                    param-constraints result-constraint))))

(defn emit-static-arity [fn-sym fn-context fn-var c-fn params param-vars body-exprs]
  (assert (instance? ast/params-ast params))
  (assert (instance? CFnPtr c-fn))

  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [body (collapse-expressions body-exprs)
          arity-var (global-var fn-sym "staticArity")
          param-constraints (flat-map (sm/get-in-val [.fn-context .subs 0] {})
                                      (fn [sub]
                                        (get-param-constraints params sub)))
          result-constraint (set-result-constraint (.c-var body) file-name line-number)
          runtime-check-fn (checking-fn fn-sym params param-vars c-fn param-constraints)
          _ (reset-fn-context fn-context)
          _ (declare ["Value *" c-fn "("
                      (-> param-vars
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\nwhile (1) {\n"
                      (.init body)
                      line-sep "};};\n"
                      (.init runtime-check-fn)
                      "FnArity " arity-var " = {FnArityType, -2, "
                      (count param-vars)
                      ", (List *)0, " (either (and (.variadic params)
                                                   (maybe "1"))
                                              "0")
                      ", " (.c-var runtime-check-fn) ", (Value *)0, (Value *)0};" line-sep])]
      (let [expr (c-static-arity (ArityValPtr (str "&" arity-var) arity-var) [] {} arity-var)]
        ;; TODO: use this to eliminate unknown return type values
        ;; (and (= UnknownType result-type)
        ;;      (maybe (print-err 'unknown-return-type fn-sym
        ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
        (StaticArity fn-var c-fn (either (and (.variadic params)
                                              (maybe'variadic))
                                         (count params))
                     expr
                     param-constraints result-constraint)))))


(defn emit-fn-arity
  ([fn-sym fn-var params body]
   (flat-map (global-var fn-sym "arityImpl")
             (fn [c-fn]
               (emit-fn-arity fn-sym fn-var params body (StaticFnPtr c-fn)))))

  ([fn-sym fn-var params body c-fn]
   (assert (instance? CFnPtr c-fn))

   ;; TODO: there are two ResultConstraint's in 'body'
   (either (and (empty? (remove body (partial instance? ast/NoCode)))
                (maybe sm/zero-sm))
           (let [file-name (ast/file-name body)
                 line-number (ast/line-number body)
                 constraints (filter body (partial instance? c/Constraints))
                 body (remove body (partial instance? ast/NoCode))
                 fn-sym (rdr/tag fn-sym file-name line-number)
                 fn-constraint (-> fn-constraint
                                   (c/update-var (str fn-var))
                                   (c/update-sym fn-sym))]
             (for [fn-context (reset-fn-context)
                   ;; _ (debug "------------\n" (ast/file-name fn-sym) (ast/line-number fn-sym) 'fn-arity fn-sym)
                   p-bindings (either (and (.variadic params)
                                           (maybe (map (bind-param params) vector)))
                                      (for [p-bindings (ev/traverse (.fixed params) bind-param)
                                            _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] '_)]
                                        p-bindings))
                   :let [param-vars (map p-bindings .bound)
                         param-destruct (either (or (and (some body (partial instance? ast/inline-ast))
                                                         (maybe []))
                                                    (and (.variadic params)
                                                         (maybe (flat-map p-bindings .destruct))))
                                                (comp (map param-vars
                                                           (fn [var]
                                                             (c-init var [] {}
                                                                     (ast/file-name params)
                                                                     (ast/line-number params))))
                                                      (flat-map p-bindings .destruct)))]
                   _ (sm/update-in-val [.fn-context .subs]
                                       (fn [subs]
                                         (map subs (fn [sub]
                                                     (reduce (conj param-vars "#result")
                                                             sub dissoc)))))
                   syms get-syms
                   _ (either (map (get syms fn-sym) sm/state-maybe)
                             (set-sym fn-sym (c-code fn-var [] {} fn-constraint)))
                   body-exprs (-> (comp param-destruct constraints body)
                                  (tail-call param-vars)
                                  ;; ((fn [b] (print-err 'body "\n" (interpose b "\n")) b))
                                  (ev/traverse emit))
                   arity-info (comp (emit-closure-arity fn-sym fn-context c-fn params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context fn-var c-fn params
                                                       param-vars body-exprs))
                   ;; _ (debug "============")
                   ]
               arity-info)))))

(deftype ProtoImplDeclaration [proto-sym fn-name arity-ast arity-var c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-name))
  (assert (instance? ArityValPtr arity-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/fn-arity-ast arity-ast))

  Stringable
  (string-list [_]
    (list "<ProtoImplDeclaration " (str proto-sym) " " (str fn-name) ">")))

(defn declare-impl [type-str type-num [proto-sym fn-name arity-ast]]
  (assert (instance? Integer type-num))

  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (global-var (str type-str fn-name) "arityImpl")
          c-fn (global-var (str type-str fn-name) "arityFn")
          :let [impl-fn-var impl-fn-var
                arity-impl-var (ArityValPtr arity-impl-var "")
                c-fn (ProtoDispFnPtr c-fn)]
          dispatcher-info (get-proto-impl proto-sym fn-name num-args 0)
          :let [sym-map (reduce (zip-lists (-> dispatcher-info .ast .params .fixed)
                                           (-> arity-ast .params .fixed))
                                {} (fn [m [old-sym new-sym]]
                                     (assoc m old-sym new-sym)))
                result-assertions (-> dispatcher-info
                                      .ast
                                      .body
                                      (filter (partial instance? c/ResultConstraint)))]
          param-assertions (-> dispatcher-info
                               .ast
                               .body
                               (filter (partial instance? c/SymbolConstraints))
                               (ev/traverse (fn [ast]
                                              (replace-syms ast sym-map))))
          :let [arity-ast (.body arity-ast (comp [] param-assertions result-assertions (.body arity-ast)))]
          _ (new-static-arity impl-fn-var num-args c-fn
                              c/empty-items-constraint c/top-type)
          _ (new-proto-impl proto-sym fn-name num-args type-num arity-impl-var arity-ast
                            c/empty-items-constraint c/top-type c-fn)
          _ (declare ["Value *" c-fn "("
                      (interpose (cons "List *closures"
                                       (seq (map (-> arity-ast .params .fixed)
                                                 (fn [param]
                                                   (str "Value *")))))
                                 ", ")
                      ");\n"
                      "FnArity *" arity-impl-var ";\n"])]
      (ProtoImplDeclaration proto-sym fn-name
                            arity-ast
                            arity-impl-var c-fn))))

(deftype ConstrainVar [constraint]
  (assert (instance? c/SymbolConstraints constraint))

  Stringable
  (string-list [_]
    (list "(ConstrainVar " (str constraint) ")"))

  Emitter
  (replace-syms [_ subs]
    (map (replace-syms constraint subs) ConstrainVar))

  (replace-bound-vars [_ subs]
    (ConstrainVar (replace-bound-vars constraint subs)))

  (emit [_]
    (either (map (.sym constraint)
                 (fn [sym]
                   (for [sym-info (lookup-sym sym)
                         _ (constrain-var (ast/file-name sym) (ast/line-number sym)
                                          (.c-var sym-info) constraint)]
                     empty-c-code)))
            (wrap sm/zero-sm empty-c-code))))

(defn emit-impl [type-str type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))

  (let [[proto-sym fn-sym arity-ast arity-var c-fn] (type-args impl-decl)
        params (.params arity-ast)
        [disp-param] (.fixed params)
        num-args (count params)
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [
          ;; _ (debug 'impl file-name line-number type-str fn-sym num-args)
          default-impl (get-proto-impl fn-sym num-args 0)
          disp-constraint (comp (for [_ (sm/get-in-val [.constants .type-names type-num])
                                      constraint (type-constraint type-num file-name line-number)]
                                  (-> constraint
                                      (c/update-sym disp-param)
                                      ConstrainVar))
                                (wrap sm/zero-sm c/top-type))
          ext-fn (comp (emit-fn-arity (rdr/tag (str type-str fn-sym))
                                      (.fn-var arity-ast)
                                      params
                                      (comp [disp-constraint
                                             (-> (.result-constraint default-impl)
                                                 (c/update-path file-name line-number)
                                                 c/ResultConstraint)]
                                            (.body arity-ast))
                                      c-fn)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-sym "' in")
                                          (str file-name ",") line-number))
          reified (reify-arity ext-fn type-num arity-ast fn-sym proto-sym)
          ;; _ (debug "---------")
          ]
      (-> reified
          (.c-var arity-var)
          (.init (either (or (empty? (.init reified))
                             (and (instance? StaticArity ext-fn)
                                  (maybe (.init reified))))
                         [(.init reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))))))

(defn extend-type* [ast type-num]
  (assert (instance? Integer type-num))
  (let [impl-arities (for [[proto-sym impl-fns] (seq (.impls ast))
                           [fn-name arities] (seq impl-fns)
                           impl-arity arities]
                       [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (wrap sm/zero-sm (str "_" type-num "_")))
                _ (ev/traverse (keys (.impls ast))
                               (fn [protocol-name]
                                 (comp (get-protocol protocol-name)
                                       (compilation-error "Invalid protocol:" protocol-name "in"
                                                          (str (ast/file-name ast) ",")
                                                          (ast/line-number protocol-name)))))
                ;; TODO: make sure the proto-name/fn-name exists
                ;; especially that the fn-name doesn't exist in a different proto-name
                impl-arities (ev/traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (ev/traverse impl-arities (partial emit-impl type-str type-num))]
            (cons head-fn fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (either (map (every impl-fns (partial instance? c-static-arity))
                                        (fn [_]
                                          (static-reified-value (ast/file-name ast) (ast/line-number ast)
                                                                reified-type-num impl-fns)))
                                 (closure-reified-value reified-type-num impl-fns
                                                        (ast/file-name ast) (ast/line-number ast)))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (let [x* (rdr/tag "#x")
          y* (rdr/tag "#y")
          ast (either (and (get-in ast [.impls Eq-sym =*-sym])
                           (maybe ast))
                      (assoc-in ast [.impls Eq-sym =*-sym]
                                [(ast/fn-arity-ast
                                  (str defined-sym "_EQ_QMARK_") ""
                                  (ast/params [x* y*]) ""
                                  [(ast/and-ast
                                    [(ast/call-ast =*-sym
                                                   [(ast/call-ast get-type-sym [x*])
                                                    (ast/call-ast get-type-sym [y*])])
                                     (ast/call-ast maybe-sym [y*])])]
                                  [] c/top-type)]))]
      (for [value (init-at-runtime ast defined-sym)
            value (comp (map (lookup-declaration defined-sym)
                             (fn [c-info]
                               (c-static-reified (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                                 (.c-var value) ";" line-sep]
                                                 (.refs-map value)
                                                 (.constraints value)
                                                 (.c-struct value))))
                        (wrap sm/zero-sm value))
            _ (new-module-def defined-sym (c-static-reified (.c-var value) [] {}
                                                            (.constraints value)
                                                            (.c-struct value)))]
        [value])))

  (tail-call [ast params]
    (TailCall ast params)))

(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          line-number (ast/line-number clause)]
      (for [syms get-syms
            expr (emit clause)
            curr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
            _ (constrain-var file-name line-number (.c-var expr) maybe-constraint)
            _ (set-syms syms)]
        (either (and (= (.c-var expr) "")
                     (maybe expr))
                (.init expr [(.init expr)
                             (either (and (instance? c-param expr)
                                          (maybe ""))
                                     (-> maybe-constraint
                                         (c/update-path file-name line-number)
                                         (c/update-var (.c-var expr))
                                         (runtime-check curr-const file-name line-number)))]))))))

(extend-type TailCall
  EmitCond
  (emit-cond-clause [clause]
    (emit clause)))

(extend-type Tagged
  EmitCond
  (emit-cond-clause [sym]
    (let [file-name (ast/file-name sym)
          line-number (ast/line-number sym)]
      (for [expr (emit sym)
            curr-const (sm/get-in-val [.fn-context .subs 0 (.c-var expr)] c/top-type)
            _ (constrain-var file-name line-number (.c-var expr) maybe-constraint)]
        (.init expr [(.init expr)
                     (either (and (instance? c-param expr)
                                          (maybe ""))
                             (-> maybe-constraint
                                 (c/update-path file-name line-number)
                                 (c/update-var (.c-var expr))
                                 (c/update-sym sym)
                                 (runtime-check curr-const file-name line-number)))])))))

(defn cond-clause-init [cond-test result-var [init refs-map] clause]
  (assert (instance? Vector init))
  (assert (instance? C-expr clause))

  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs))]
    [(conj init
           [(.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            cond-test result-var ",\"\",0)) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  (either (and (= 0 remaining)
                                               (maybe ""))
                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))])
     refs-map]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits] (reduce (butlast evalled-clauses)
                               [[] refs-map]
                               (partial cond-clause-init cond-test result-var))
        last-clause (either (last evalled-clauses)
                            (do
                              (print-err "Booom!!!")
                              (abort)))
        last-init [(.init last-clause)
                   (either (= "" (.c-var last-clause))
                           [result-var " = " (.c-var last-clause) ";" line-sep])]]
    (conj clause-inits last-init)))

(defn clause-refs [exprs result-var]
  (dissoc (apply merge-with (list* + (map exprs .refs-map)))
          result-var))

(defn emit-cond-expr [cond-test result-var clauses tail-return]
  (let [file-name (ast/file-name clauses)
        line-number (ast/line-number clauses)]
    (for [evalled-clauses (ev/traverse clauses emit-cond-clause)
          last-clause (sm/when (last evalled-clauses))
          _ (update-subs
             (typ/propogate-constraint (.c-var last-clause) result-var
                                       identity file-name line-number))]
      (let [refs-map (clause-refs evalled-clauses result-var)]
        (c-init result-var
                ["Value *" result-var ";" line-sep
                 (-> evalled-clauses
                     (clause-inits cond-test refs-map result-var)
                     (interpose [tail-return "} else {" line-sep
                                 "dec_and_free(" result-var ", 1);" line-sep]))
                 (-> (count evalled-clauses)
                     dec
                     (repeat (str "}" line-sep)))]
                refs-map file-name line-number)))))

(deftype TailAnd [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ")
          (flat-map (seq clauses) string-list)
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          _ (constrain-var (ast/file-name ast) (ast/line-number ast) "#result" maybe-constraint)
          expr (emit-cond-expr "if (isNothing(" result-var
                               (.clauses ast)
                               (str "return(nothing);" line-sep))]
      expr)))

(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (and (empty? clauses)
                   (maybe (wrap sm/zero-sm empty-c-code)))
              (for [result-var (genlocal "andRslt")
                    expr (emit-cond-expr "if (isNothing(" result-var clauses "")]
                expr))))

  (tail-call [ast params]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (map (last clauses) (fn [last-c]
                                    (TailAnd (conj (butlast clauses)
                                                   (tail-call last-c params)))))
              ast)))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast (vec new-clauses))))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ")
          (flat-map (seq clauses) string-list)
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          _ (constrain-var (ast/file-name ast) (ast/line-number ast) "#result" maybe-constraint)
          expr (emit-cond-expr "if (!isNothing(" result-var
                               (remove (.clauses ast) (partial instance? ast/NoCode))
                               (str "return(" result-var ");" line-sep))]
      expr)))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (and (empty? clauses)
                   (maybe (wrap sm/zero-sm empty-c-code)))
              (flat-map (genlocal "orRslt")
                        (fn [result-var]
                          (emit-cond-expr "if (!isNothing(" result-var clauses
                                          line-sep))))))

  (tail-call [ast params]
    (let [clauses (remove (.clauses ast) (partial instance? ast/NoCode))]
      (either (map (last clauses) (fn [last-c]
                                    (TailOr (conj (butlast clauses)
                                                  (tail-call last-c params)))))
              ast)))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs))))))

(deftype TailEither [clause alt]

  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "rslt")
          cond-val (emit-cond-clause clause)
          alt-val (emit alt)]
      (let [cond-rslt (.c-var cond-val)
            refs-map (merge-with + (.refs-map cond-val) (.refs-map alt-val))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                refs-map
                c/top-type)))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          cond-val (emit-cond-clause (.clause ast))
          syms get-syms
          alt-val (emit (.alt ast))
          _ (set-syms syms)]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                refs-map (ast/file-name ast) (ast/line-number ast)))))

  (tail-call [ast params]
    (TailEither (.clause ast)
                (tail-call (.alt ast) params)))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs))))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [
          ;; _ (debug "=======\n*** " 'main-fn)
          ;; TODO: add param assertions
          fn-arity (emit-fn-arity (rdr/tag 'main) "" (.params ast) (.body ast))
          ;; _ (debug "======= done main")
          _ (new-static-arity 'main 1 (.c-fn fn-arity)
                              c/empty-items-constraint c/top-type)]
      [empty-c-code])))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (ev/traverse arities
                                     (fn [static-arity]
                                       (for [_ (new-static-arity fn-var
                                                                 (.param-count static-arity)
                                                                 (.c-fn static-arity)
                                                                 (.param-constraints static-arity)
                                                                 (.result-constraint static-arity))]
                                         (.var-info static-arity))))
        :let [arity-count (count emitted-arities)
              fn-constraint (c/update-path fn-constraint
                                           (ast/file-name fn-sym) (ast/line-number fn-sym))]
        _ (constrain-var (ast/file-name fn-sym) (ast/line-number fn-sym)
                         fn-var fn-constraint)
        _ (declare ["Function " struct-var " = {FunctionType, -2, \""
                    fn-sym "\", " arity-count ", "
                    "{" (to-str (interpose (map emitted-arities .c-var)
                                           ", "))
                    "}};\n"
                    "Value *" fn-var " = (Value *)&" struct-var ";\n\n"])]
    (either (or (and (= fn-sym 'list)
                     (maybe (c-list-fn fn-var [] {} struct-var)))
                (and (= fn-sym 'maybe)
                     (maybe (c-maybe-fn fn-var [] {} struct-var)))
                (and (= fn-sym 'vector)
                     (maybe (c-vector-fn fn-var [] {} struct-var))))
            (c-static-fn fn-var [] {}
                         fn-constraint struct-var
                         (reduce arities {}
                                 (fn [m arity]
                                   (assoc m (.param-count arity) arity)))))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities (partial instance? ClosureArity)))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))
        :let [emitted-arities (map arities .var-info)]]
    (let [arity-count (count arities)]
      (c-closure-fn (str fn-var)
                    [(map emitted-arities .init)
                     line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
                     struct-var "->name = \"" fn-sym "\";" line-sep
                     struct-var "->arityCount = " arity-count ";" line-sep
                     (map (zip-lists (map emitted-arities .c-var)
                                     (range arity-count))
                          (fn [[sym index]]
                            (str struct-var "->arities[" index "] = " sym ";" line-sep)))
                     "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
                    (apply merge-with (list* + (map emitted-arities .refs-map)))
                    (reduce arities {}
                            (fn [m arity]
                              (assoc m (.param-count arity) arity)))
                    (ast/file-name fn-sym) (ast/line-number fn-sym)))))

(defn call-universal-proto-fn [fn-sym disp-arg args]
  (let [args (cons disp-arg args)]
    (str "Value *protoRslt;\n"
         "if (universalProtoFn != 0){\n"
         "  List *args = empty_list;\n"
         (to-str (flat-map (reverse args)
                           (fn [arg]
                             (list "  args = listCons(" "(Value *)" arg ", args);\n"))))
         "  args = listCons(symbol(stringValue(\"" fn-sym "\")), args);\n"
         "  args = listCons(stringValue(\"" (ast/file-name fn-sym) "\"), args);\n"
         "  protoRslt = fnApply(universalProtoFn, (Value *)args);\n"
         "  if (protoRslt->type == MaybeType && !isNothing(protoRslt,\"\",0)) {\n"
         "    Value *result = ((Maybe *)protoRslt)->value;\n"
         "    incRef(result, 1);\n"
         "    dec_and_free(protoRslt, 1);\n"
         "    dec_and_free(" disp-arg ", 1);\n"
         "    return(result);\n"
         "}\n} else {\n"
         (to-str (flat-map args (fn [arg]
                                  (list
                                   "  dec_and_free(" arg ", 1);\n"))))
         "protoRslt = nothing;}\n")))

(deftype InsertCode [fn-sym prototype]
  Stringable
  (string-list [_]
    (list "<InsertCode>"))

  Emitter
  (emit [_]
    (let [num-args (-> prototype .params .fixed count)
          [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                            (range num-args))
                                 (fn [[arg idx]]
                                   (either (check-C-var (str arg "_" idx))
                                           (str "arg" idx))))]
      (wrap sm/zero-sm (c-code "protoRslt"
                               [(call-universal-proto-fn fn-sym disp-arg args)]
                               (reduce args {disp-arg 1}
                                       (fn [m arg]
                                         (assoc m arg 1)))
                               c/top-type)))))

(defn missing-impl-body [proto-sym fn-sym prototype]
  (let [num-args (-> prototype .params .fixed count)
        [disp-arg & args] (map (zip-lists (-> prototype .params .fixed)
                                          (range num-args))
                               (fn [[arg idx]]
                                 (either (check-C-var (str arg "_" idx))
                                         (str "arg" idx))))]
    (comp (filter (.default-body prototype) (partial instance? c/Constraints))
          [(c-code ""
                   ["incRef(" disp-arg ", 1);"
                    ;; TODO: maybe use 'InsertCode' instead
                    (call-universal-proto-fn fn-sym disp-arg args)
                    (to-str (line-marker (ast/file-name fn-sym) (ast/line-number fn-sym) ""))
                    "if (closures != (List *)0) {"
                    "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                    "' for type '%s' with %d arguments at %s\\n\", "
                    "((String *)type_name((List *)0, " disp-arg "))->buffer, " num-args
                    ", ((String *)closures)->buffer);abort();"
                    "} else {"
                    "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                    "' for type '%s' with %d arguments.\\n\", "
                    "((String *)type_name((List *)0, " disp-arg "))->buffer, " num-args ");abort();"
                    "}"]
                   (reduce args {disp-arg 1}
                                       (fn [m arg]
                                         (assoc m arg 1)))
                   c/top-type)])))

(defn emit-proto-default [protocol-sym fn-sym disp-fn-var prototype]
  (let [default-body (missing-impl-body protocol-sym fn-sym prototype)
        body (remove (.default-body prototype) (partial instance? ast/NoCode))
        arity-ast (ast/fn-arity (.params prototype) ""
                                (either (and (empty? body)
                                             (maybe default-body))
                                        body))]
    (for [arity-impl-var (global-var (str "Default_" fn-sym) "arityImpl")
          :let [arity-impl-var (ProtoDispFnPtr arity-impl-var)]
          decls (sm/get-in-val [.fn-context .decl])
          _ (sm/assoc-in-val [.fn-context .decl] [])
          default-arity (emit-fn-arity (rdr/tag (str "Default_" fn-sym)) disp-fn-var
                                      (.params prototype)
                                      (-> (.default-body prototype)
                                          (filter (partial instance? c/Constraints))
                                          (comp default-body))
                                      arity-impl-var)
          after-decls (sm/get-in-val [.fn-context .decl])
          _ (sm/assoc-in-val [.fn-context .decl] decls)
          static-arity (either (and (empty? body)
                                    (maybe (for [_ (declare after-decls)]
                                             default-arity)))
                               (emit-fn-arity (rdr/tag (str "Default_" fn-sym)) disp-fn-var
                                              (.params prototype)
                                              (-> (.default-body prototype)
                                                  (filter (partial instance? c/Constraints))
                                                  (comp [(ast/either-ast
                                                          (InsertCode fn-sym prototype)
                                                          (ast/let-ast [] body))]))
                                              arity-impl-var))

          result-constraints (-> (.default-body prototype)
                                 (filter (partial instance? c/ResultConstraint))
                                 (map .assertion)
                                 (ev/traverse to-constraint))
          param-constraints (-> (.default-body prototype)
                                (remove (partial instance? c/ResultConstraint))
                                (filter (partial instance? c/Constraints))
                                (ev/traverse to-constraint))
          :let [result-constraint (reduce result-constraints c/top-type c/intersect)
                param-constraints (.param-constraints default-arity)
                param-count (.param-count static-arity)]

          _ (sm/assoc-in-val [.fns disp-fn-var param-count .param-constraints]
                             param-constraints)
          _ (sm/assoc-in-val [.fns disp-fn-var param-count .result-constraint]
                             result-constraint)
          _ (sm/assoc-in-val [.modules (ast/file-name protocol-sym) .protocols
                              (rdr/untag protocol-sym) (rdr/untag fn-sym)
                              param-count 0]
                             (ProtoImpl 0 (.c-var (.var-info static-arity)) arity-ast
                                        param-constraints result-constraint arity-impl-var))]
      static-arity)))

(defn create-dispatcher [proto-sym [fn-sym arities]]
  (for [_ (emit (ast/quoted-ast proto-sym))
        _ (emit (ast/quoted-ast fn-sym))

        fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                     (global-var (str "dispFn_" fn-sym) "fn"))
        arities-info (ev/traverse arities
                                  (fn [arity]
                                    (let [arg-count (count (.params arity))]
                                      (for [c-fn (global-var (str "disp_" fn-sym) "dispatcher")
                                            _ (new-static-arity fn-var arg-count (ProtoDispFnPtr c-fn)
                                                                c/empty-items-constraint
                                                                c/top-type)]
                                        ["Value *" c-fn "("
                                         (-> (map (range arg-count) (fn [n] (str "Value *arg" n)))
                                             (conj "List *closures")
                                             (interpose ", "))
                                         ");\n"]))))
        _ (declare ["\n// proto fn for " proto-sym "/" fn-sym "\n"
                    "\n// --------- " fn-sym " -------------\n"
                    "Value *" fn-var ";\n"
                    arities-info])
        _ (new-module-def fn-sym (c-protocol-fn fn-var [] {} fn-constraint "" {}))
        default-fns (ev/traverse arities (partial emit-proto-default proto-sym fn-sym fn-var))
        :let [default-arities (reduce default-fns {}
                                      (fn [m arity]
                                        (assoc m (.param-count arity) arity)))]
        _ (sm/assoc-in-val [.modules (ast/file-name fn-sym) .values fn-sym .arities]
                           default-arities)]
    []))

(defn check-protocol-name [proto-sym]
  ;; Ensure all protocol symbols are unique
  (comp (for [proto-info (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols (rdr/untag proto-sym)])]
          (do
            (print-err  "Duplicate protocol"
                        (str "'" proto-sym "'") "at"
                        (str (ast/file-name proto-sym) ":")
                        (ast/line-number proto-sym))
            (abort)))
        (wrap sm/zero-sm '_)))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (check-protocol-name proto-name)
            decl (ev/traverse (seq prototype-map)
                              (partial create-dispatcher proto-name))]
        [empty-c-code]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (either (and (= "" (.fn-sym ast))
                                (maybe 'anon))
                           (.fn-sym ast))
                   (str (.fn-var ast)) (.params ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (wrap sm/zero-sm
          (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                       (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (rdr/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (either (map (.fn-sym ast)
                   (fn [fn-sym]
                     (for [ ;; _ (debug "=========")
                           ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                           fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                                        (global-var fn-sym "fn"))
                           _ (declare ["\n// --------- " fn-sym " -------------\n"
                                       "Value *" fn-var ";\n"])
                           _ (constrain-var file-name line-number fn-var fn-constraint)
                           arities (ev/traverse (map (.arities ast) (fn [arity]
                                                                      (-> arity
                                                                          (.fn-sym fn-sym)
                                                                          (.fn-var fn-var))))
                                                emit)
                           fn-expr (comp (closure-fn fn-sym fn-var arities)
                                         (static-fn fn-sym fn-var arities))
                           ;; _ (debug "---------")
                           ]
                       fn-expr)))
              (for [fn-var (global-var "fn")
                    _ (declare ["Value *" fn-var ";\n"])
                    _ (constrain-var file-name line-number fn-var fn-constraint)
                    arities (ev/traverse (.arities ast) emit)
                    fn-expr (comp (closure-fn (str "anonymous function at "
                                                   (ast/file-name ast) ": " (ast/line-number ast))
                                              fn-var arities)
                                  (static-fn (str "anonymous function at "
                                                  (ast/file-name ast) ": " (ast/line-number ast))
                                             fn-var arities))]
                fn-expr))))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params]
    (TailCall x params))

  (inline-expr [ast arg-asts]
    (either (map (-> (.arities ast)
                     (filter (fn [arity]
                               (= (count arg-asts) (count (.params arity)))))
                     first)
                 (fn [arity] 
                   (inline-expr arity arg-asts)))
            sm/zero-sm))

  (replace-syms [ast subs]
    (for [new-arities (ev/traverse (.arities ast)
                                   (fn [arity]
                                     (replace-syms arity subs)))]
      (.arities ast (vec new-arities))))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (get-type-numbers (maybe type-sym))
                  fns (map (ev/traverse (seq type-nums) (partial extend-type* ast))
                           flatten)]
              fns)
            (compilation-error "Trying to extend unknown type: "
                               (str "'" type-sym "'") "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(defn emit-constructor [new-type-name type-num new-type-constraint fields assertions]
  (assert (instance? c/TypeConstraint new-type-constraint))
  (assert (instance? Vector fields))

  (let [file-name (ast/file-name new-type-name)
       line-number (ast/line-number new-type-name)
       reified-type-num (extract rdr/type-counter)
        x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field-count (count fields)
        args (map (range field-count)
                  (fn [n]
                    (rdr/tag (symbol (str "arg" n)))))
        args-map (reduce (zip-lists fields args) {}
                         (fn [m [k v]]
                           (assoc m k v)))]
    (for [assertions (ev/traverse assertions (fn [assert]
                                               (replace-syms assert args-map)))
          :let [ast (ast/reified reified-type-num
                                 {Eq-sym
                                  {(rdr/tag =*-sym file-name line-number)
                                   [(ast/fn-arity-ast
                                     (str new-type-name "_EQ_QMARK_") ""
                                     (ast/params [x* y*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast =*-sym
                                                      [type-num
                                                       (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast maybe-sym [y*])])]
                                     [] c/top-type)]}

                                  Type-sym
                                  {type-name-sym
                                   [(ast/fn-arity-ast (str new-type-name "_const_type_name") ""
                                                      (ast/params ['_]) ""
                                                      [(str "*" new-type-name " constructor*")]
                                                      [] c/top-type)]
                                   type-mapping-sym
                                   [(ast/fn-arity-ast (str new-type-name "_const_type_map") ""
                                                      (ast/params ['_]) ""
                                                      [(map-vals (.type-maps new-type-constraint)
                                                                 (fn [field-set]
                                                                   (map field-set ast/quoted-ast)))]
                                                      [] c/top-type)]
                                   instance?-sym
                                   [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") ""
                                                      (ast/params [x* y*]) ""
                                                      [(ast/and-ast
                                                        [(ast/call-ast =*-sym
                                                                       [type-num
                                                                        (ast/call-ast get-type-sym [y*])])
                                                         (ast/call-ast maybe-sym [y*])])]
                                                      [] c/top-type)]}

                                  Function-sym
                                  {invoke-sym
                                   [(ast/fn-arity-ast (str new-type-name "_invoke") ""
                                                      (ast/params (comp ['_] args)) ""
                                                      (comp
                                                       assertions
                                                       [(c/TypeConstraint {}
                                                                          (list [file-name line-number])
                                                                          new-type-name nothing "#result")
                                                        (ast/inline-ast
                                                         'C nothing
                                                         (str "ReifiedVal *rv = malloc_reified("
                                                              field-count ");\n"
                                                              "#ifdef SINGLE_THREADED\n"
                                                              "rv->refs = refsInit;\n#else\n"
                                                              " __atomic_store(&rv->refs,"
                                                              " &refsInit, __ATOMIC_RELAXED);\n"
                                                              "#endif\n"
                                                              "rv->type = " type-num ";\n"
                                                              (to-str (map (range field-count)
                                                                           (fn [idx]
                                                                             (str "rv->impls[" idx "] = arg" idx
                                                                                  "_" (inc idx) ";\n"))))
                                                              "return((Value *)rv);\n")
                                                         "" 0)])
                                                      [] c/top-type)]}

                                  Container-sym
                                  {apply-sym
                                   [(ast/fn-arity-ast (str new-type-name "_apply_ST_") ""
                                                      (ast/params ['_ 'fields]) ""
                                                      [(c/ItemsConstraint assertions c/top-type
                                                                          (list [file-name line-number])
                                                                          (maybe
                                                                           (rdr/tag'fields file-name line-number))
                                                                          "")
                                                       (ast/inline-ast 'C nothing
                                                                       (str "return(newTypeValue(" type-num
                                                                            ", listVec(fields_1)));")
                                                                       "" 0)]
                                                      [] c/top-type)]}

                                  Stringable-sym
                                  {string-list-sym
                                   [(ast/fn-arity (ast/params ['z]) ""
                                                  [(ast/call-ast list-sym
                                                                 ["<ValueConstructor " (str new-type-name) " ["
                                                                  (to-str (interpose fields ", "))
                                                                  "]>"])])]}})]
          value (init-at-runtime ast new-type-name)
          expr (comp (map (lookup-declaration new-type-name)
                          (fn [c-info]
                            (c-static-reified (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                              (.c-var value) ";" line-sep]
                                              (.refs-map value)
                                              (.constraints value)
                                              (.c-struct value))))
                     (wrap sm/zero-sm value))
          _ (new-module-def new-type-name (c-constructor (.c-var expr) [] {}
                                                         (.constraints expr)
                                                         (.c-struct expr)
                                                         type-num fields))]
      [expr])))

(defn default-type-impls [type-sym type-num fields]
  (let [x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field* (rdr/tag "#field")
        ctxt* (rdr/tag "#ctxt")]
    {Type-sym
     [[type-name-sym
       [(ast/fn-arity-ast (str type-sym "_type_name") ""
                          (ast/params [x*]) ""
                          [(str type-sym)]
                          [] c/top-type)]]
      [has-field-sym
       [(ast/fn-arity-ast
         (str type-sym "_has_field") ""
         (ast/params [x* field*]) ""
         [(ast/or-ast
           (conj (map fields
                      (fn [field]
                        (ast/call-ast identical-sym
                                      [(rdr/tag (str "." field))
                                       field*])))
                 nothing-sym))]
         [] c/top-type)]]]

     Eq-sym
     [[=*-sym
       [(ast/fn-arity-ast
         (str type-sym "_EQ_STAR_") ""
         (ast/params [x* y*]) ""
         [(ast/and-ast
           [(ast/call-ast
             =*-sym [(ast/call-ast get-type-sym [x*])
                     (ast/call-ast get-type-sym [y*])])
            (ast/call-ast
             =*-sym [(ast/call-ast reified-type-args-sym [x*])
                     (ast/call-ast reified-type-args-sym [y*])])
            (ast/call-ast maybe-sym [x*])])]
         [] c/top-type)]]]

     Associative-sym
     [[get-symb
       [(ast/fn-arity-ast
         (str type-sym "_get") ""
         (ast/params [x* field*]) ""
         [(ast/and-ast
           [(ast/call-ast has-field-sym [x* field*])
            (ast/call-ast maybe-sym
                          [(ast/call-ast field* [x*])])])]
         [] c/top-type)]]

      [assoc-sym
       [(ast/fn-arity-ast
         (str type-sym "_assoc_") ""
         (ast/params [x* field* 'new-value]) ""
         [(ast/either-ast
           (ast/and-ast
            [(ast/call-ast has-field-sym [x* field*])
             (ast/call-ast maybe-sym
                           [(ast/call-ast field* [x* 'new-value])])])
           x*)]
         [] c/top-type)]]]

     Hashable-sym
     [[sha1-update-sym
       [(ast/fn-arity-ast
         (str type-sym "_sha1_update") ""
         (ast/params [x* ctxt*]) ""
         [(ast/call-ast sha1-update-type-sym [x* ctxt*])
          (ast/call-ast
           sha1-update-sym
           [(ast/call-ast reified-type-args-sym [x*]) ctxt*])]
         [] c/top-type)]]
      [sha1-sym
       [(ast/fn-arity-ast
         (str type-sym "_sha1") ""
         (ast/params [x*]) ""
         [(ast/call-ast
           sha1-finalize-sym
           [(ast/call-ast
             sha1-update-sym
             [x* (ast/call-ast sha1-init-sym [])])])]
         [] c/top-type)]]]}))

(defn declare-getters [new-type-name fields]
  (ev/traverse fields
               (fn [field]
                 (let [getter-sym (rdr/tag (str "." field) 'core 0)]
                   (comp (map (sm/get-in-val [.modules 'core .protocols (rdr/untag Type-sym) (rdr/untag getter-sym)])
                              (fn [_] []))
                         (create-dispatcher Type-sym
                                            [getter-sym
                                             [(ast/prototype getter-sym
                                                             (ast/params [(symbol "#x")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint getter-sym
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])
                                              (ast/prototype getter-sym
                                                             (ast/params [(symbol "#x") (symbol "#y")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint getter-sym
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])]]))))))

(defn create-getters [sym constraint fields field-constraints]
  (let [type-value (rdr/tag "#value")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            [(rdr/tag (str "." field))
             [(ast/fn-arity-ast (str sym "_" field) ""
                                (ast/params [type-value (rdr/tag "#field")]) ""
                                [(c/update-sym field-constraint (rdr/tag "#field"))
                                 (ast/inline-ast 'C (maybe sym)
                                                 (str "return(updateField(value_0, field_1, "
                                                      field-index "));\n")
                                                 "" 0)]
                                [] c/top-type)
              (ast/fn-arity-ast (str sym "_" field) ""
                                (ast/params [type-value]) ""
                                [(c/ResultConstraint (c/clear-sym field-constraint))
                                 (ast/inline-ast 'C nothing
                                                 (str "return(getField(value_0, " field-index "));\n")
                                                 "" 0)]
                                [] c/top-type)]]))}))

(defn destruct-impl-fields [sym ast field-types arity]
  (let [[type-value-parameter] (.fixed (.params arity))
        fields (.fixed (.fields ast))
        field-count (count fields)
        new-body (comp (filter (.body arity) (partial instance? c/Constraints))
                       [(ConstrainVar (c/TypeConstraint {} empty-list (.sym ast) nothing ""))
                        (-> (zip-lists fields
                                       (range field-count))
                            (map (fn [[field-sym index]]
                                   (ast/binding field-sym
                                     (ast/call-ast get-field-sym
                                                   [type-value-parameter index]))))
                            vec
                            (ast/let-ast 
                             (-> (c/extract-items-constraints field-types)
                                 (map (fn [c]
                                        (either (map (instance? c/SymbolConstraints c) ConstrainVar)
                                                c)))
                                 (comp (remove (.body arity) (partial instance? c/Constraints))))))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str sym "_" fn-name)))))

(defn destructure-fields [sym ast field-types]
  (let [impls (comp* {} (filter (.impls ast)
                                (partial instance? HashMap)))]
    (map-vals impls
              (fn [impl-arities]
                ;; TODO: maybe use 'for'
                (map (seq impl-arities)
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields sym ast field-types))]))))))

(def pre-defed-types {'HashSet HashSetType
                      'TypeConstraint TypeConstraintType
                      'NoValues NoValuesType
                      'AllValues AllValuesType
                      'MultiConstraint MultiConstraintType
                      'ResultConstraint ResultConstraintType
                      'ItemsConstraint ItemsConstraintType
                      'FieldConstraint FieldConstraintType
                      'StaticIntConstraint StaticIntConstraintType
                      'MinValue MinValueType
                      'MaxValue MaxValueType
                      'InferredInner InferredInnerType
                      'StaticLengthConstraint StaticLengthConstraintType
                      'StaticStrConstraint StaticStrConstraintType
                      'ContentsConstraint ContentsConstraintType})

(defn new-type-number [type-symbol]
  (assert (instance? Tagged type-symbol))
  (either (get pre-defed-types type-symbol)
          (extract rdr/type-counter)))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))
          field-assertions (filter (.impls ast) (partial instance? c/SymbolConstraints))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            (either (and (= file-name 'core)
                                                         (maybe "$TOCCATA_DIR/core.toc"))
                                                    file-name)
                                            ", " line-number))]
              "")

            (let [type-num (new-type-number sym)
                  type-map {type-num (-> fields
                                         (map (fn [name]
                                                (symbol (str "." name))))
                                         set)}
                  new-type-constraint (c/TypeConstraint type-map (list [file-name line-number])
                                                        sym nothing "")]
              (for [_ (sm/assoc-in-val [.type-maps type-num] (TypeInfo sym type-map))
                    _ (sm/assoc-in-val [.modules file-name .types sym] type-num)
                    _ (sm/assoc-in-val [.constants .type-names type-num] (str sym))
                    getters (declare-getters sym fields)

                    ;; TODO: this whole section is bogus
                    field-assertions (ev/traverse field-assertions to-constraint)
                    :let [field-map (reduce field-assertions
                                            {} (fn [m c]
                                                 (validate-field c m fields file-name line-number)))

                          field-constraints (c/ItemsConstraint
                                             (map fields (fn [field]
                                                           (either (get field-map field)
                                                                   c/top-type)))
                                             c/top-type
                                             empty-list (maybe (symbol (str sym "-field-constraints"))) "")
                          impls (merge-with comp
                                            (default-type-impls sym type-num fields)
                                            (create-getters sym new-type-constraint fields
                                                            (c/extract-items-constraints field-constraints))
                                            (destructure-fields sym ast field-constraints))
                          impl-arities (for [[proto-sym impl-fns] (seq impls)
                                             [fn-name arities] (seq impl-fns)
                                             impl-arity arities]
                                         [proto-sym fn-name (.fn-var impl-arity (str (.fn-var impl-arity)))])]
                    type-constructor (emit-constructor sym type-num new-type-constraint
                                                       fields field-assertions)
                    impl-arities (ev/traverse impl-arities (partial declare-impl (str sym) type-num))
                    _ (ev/traverse impl-arities (partial emit-impl (str sym) type-num))
                    ;; TODO: this should be better
                    const-type-num (flat-map (lookup-sym sym)
                                             (fn [expr]
                                               (var-type-num (.c-var expr))))
                    _ (sm/assoc-in-val [.modules 'core .protocols (rdr/untag Function-sym) (rdr/untag invoke-sym)
                                        const-arity-index const-type-num .result-constraint]
                                       new-type-constraint)
                    _ (declare (flatten getters))]
                type-constructor))))))

;; (defn js-callable-arity [[num-args expr]]
;;   (for [c-fn-name (global-var (str (.sym ast) "_" num-args))
;;         :let [c-fn-name (either (check-C-var c-fn-name)
;;                                 c-fn-name)
;;               js-wrapper (c-code ""
;;                                  ["\nEM_ASM(\n" (str (.sym ast)) " = function("
;;                                   (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
;;                                   "_" c-fn-name "("
;;                                   (interpose (map (range num-args)
;;                                                   (fn [idx]
;;                                                     ["sendValue(arg" idx ")"]))
;;                                              ", ")
;;                                   ");\n return; \n};);\n"]
;;                                  [] {} {})]
;;         _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
;;                                                 (conj exprs js-wrapper)))]
;;     [c-fn-name num-args]
;;     [(c-code "" []
;;              ["EMSCRIPTEN_KEEPALIVE\n void " c-fn-name "("
;;               (interpose (map (range num-args) (partial str "int64_t arg")) ", ")
;;               ") {\ndec_and_free("
;;               (.c-var expr) "("
;;               (interpose (cons "empty_list"
;;                                (map (range num-args)
;;                                     (fn [idx]
;;                                       ["(Value *)arg" idx])))
;;                          ", ")
;;               "), 1);\n return; \n};\n"]
;;              {} {})]))

(extend-type ast/JS-callable
  Emitter
  (emit-definition [ast]
    (let [num-args (.num-args ast)]
      (comp (for [fn-var (map (lookup-sym (.sym ast)) .c-var)
                  expr (lookup-static-arity-info fn-var num-args)
                  c-fn-name (global-var (str (.sym ast)))
                  :let [c-fn-name (either (check-C-var c-fn-name)
                                          c-fn-name)
                        js-wrapper (c-code ""
                                           ["\n#ifdef TOCCATA_WASM\n"
                                            "EM_ASM(\n" (str (.sym ast)) " = function("
                                            (interpose (map (range num-args) (partial str "arg")) ", ") ") {\n"
                                            "_" c-fn-name "("
                                            (interpose (map (range num-args)
                                                            (fn [idx]
                                                              ["sendValue(arg" idx ")"]))
                                                       ", ")
                                            ");\n return; \n};);\n"
                                            "#endif\n"]
                                           {} c/top-type)]
                  _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                          (conj exprs js-wrapper)))
                  _ (declare ["\n#ifdef TOCCATA_WASM\n"
                              "EMSCRIPTEN_KEEPALIVE\n void " c-fn-name "("
                              (interpose (map (range num-args) (partial str "int arg")) ", ")
                              ") {\ndec_and_free("
                              (.c-var expr) "("
                              (interpose (cons "(List *)0"
                                               (map (range num-args)
                                                    (fn [idx]
                                                      (str "(Value *)arg" idx))))
                                         ", ")
                              "), 1);\n return; \n};\n"
                              "#endif\n"])]
              [empty-c-code])
            (compilation-error "Could not find function" (.sym ast) "or an arity with" num-args "arguments.")))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {} empty-closures [] [{}])
                                   (RuntimeInit (FunctionArityContext {} 0 {} {} empty-closures [] [{}])
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names {})
                                   0                        ;; reify-fn-index
                                   core-types               ;; type-maps
                                   ))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");\n"]))

(defn declare-dispatcher [file-name [fn-sym arities]]
  (for [disp-fn (sm/get-in-val [.modules file-name .values (rdr/tag fn-sym)])
        :let [fn-var (.c-var disp-fn)]
        c-fns (ev/traverse (keys arities)
                           (fn [arg-count]
                             (for [disp-arity (lookup-static-arity-info fn-var arg-count)
                                   arity-var (global-var "arity")]
                               [arg-count arity-var (.c-var disp-arity)])))
        struct-var (global-var "dispFnStruct")

        _ (sm/assoc-in-val [.modules file-name .values (rdr/tag fn-sym) .c-struct] struct-var)
        _ (declare [(map c-fns
                         (fn [[arg-count arity-var c-fn]]
                           (let [impls (extract (get arities arg-count))]
                             ["Value *" c-fn "(List *"
                              (interpose (cons "closures" (map (range arg-count)
                                                               (partial str "Value *arg")))
                                         ",")
                              ") {\nFnArity *arity;\n#\n"
                              "FnType" arg-count " *_fn;\n"
                              "switch (arg0->type) {\n"
                              (map (seq (dissoc impls 0))
                                   (fn [[type-num arity-info]]
                                     (assert (instance? ProtoImpl arity-info))

                                     ["case " (str type-num) ": arity = "
                                      (.c-var arity-info) ";\n_fn = (FnType"
                                      arg-count " *)" (.c-fn arity-info) ";\n"
                                      (for [[constraint var] (-> (.param-constraints arity-info)
                                                                 c/extract-items-constraints
                                                                 (zip-lists (map (range arg-count)
                                                                                 (partial str "arg")))
                                                                 rest)]
                                        (-> constraint
                                            (c/update-var var)
                                            (runtime-check c/top-type
                                                           (str "(closures == (List *)0 ? \"\" : "
                                                                "((String *)closures)->buffer)"))))
                                      "\nclosures = arity->closures;\nbreak;\n"]))
                              (let [arity-info (extract (get impls 0))]
                                ["default: arity = " (.c-var arity-info) ";_fn = (FnType" arg-count
                                 " *)" (.c-fn arity-info) ";\nbreak;\n"])
                              "}\n"
                              ;; "FnType" arg-count " *_fn = (FnType" arg-count " *)arity->fn;\n" 
                              "return(_fn(closures, " (-> (range arg-count)
                                                          (map (partial str "arg"))
                                                          (interpose ", "))
                              "));\n}\n"
                              "FnArity " arity-var " = {FnArityType, -2, "
                              arg-count
                              ", (List *)0, 0, " c-fn ", (Value *)0, (Value *)0};\n"])))
                    "Function " struct-var " = {FunctionType, -2, \""
                    fn-sym "\", " (count c-fns) ", "
                    "{" (interpose (map c-fns (fn [[_ arity-var]] (str "&" arity-var))) ", ")
                    "}};\n"
                    "Value *" fn-var " = (Value *)&" struct-var ";\n\n"])]
    '_))

(defn gather-protocols [file-name]
  (comp (for [protocols (sm/get-in-val [.modules file-name .protocols])
              expr (encode-static protocols)
              x (apply (wrap sm/zero-sm list)
                       (map (for [[_ proto-fns] (seq protocols)
                                  [fn-sym arities] (seq proto-fns)]
                              [fn-sym arities])
                            (partial declare-dispatcher file-name)))
              protos-var (sm/get-in-val [.modules file-name .values protocols-sym])
              r (collapse-expressions [expr
                                       (c-code (.c-var protos-var)
                                               [(.c-var protos-var) " = " (.c-var expr) ";\n"]
                                               {} c/top-type)])]
          r)
        (compilation-error "Could not gather the protocols for" (str "'" file-name "'"))))

(defn gather-symbols [file-name]
  (for [symbols (sm/get-in-val [.modules file-name .values])
        expr (-> symbols
                 (dissoc symbols-sym protocols-sym)
                 (assoc 'filename (either (instance? String file-name)
                                          ""))
                 seq
                 (reduce {} (fn [m [k v]]
                              (either (and (instance? c-code v)
                                           (maybe m))
                                      (assoc m k v))))
                 (encode "symbols_"))
        sym-var (sm/get-in-val [.modules file-name .values symbols-sym])
        r (collapse-expressions [expr
                                 (c-code (.c-var sym-var)
                                         [(.c-var sym-var) " = " (.c-var expr) ";\n"]
                                         {} c/top-type)])]
    r))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity-info 'main 1)
                      (compilation-error "'main' function is missing"))
        modules (sm/get-in-val [.modules])
        protos (ev/traverse (keys modules) gather-protocols)
        symbols (ev/traverse (keys modules) gather-symbols)
        values (sm/get-in-val [.rt-init .exprs])
        decl (sm/get-in-val [.fn-context .decl])
        _ (sm/assoc-in-val [.fn-context .decl] [])]
    (do
      (write-strings decl)
      (write-strings ["\n#\n"
                      "\nint main (int argc, char **argv) {\n"
                      "#ifdef SINGLE_THREADED\n"
                      "#ifdef CHECK_MEM_LEAK\n"
                      "fprintf(stderr, \"Cannot use SINGLE_THREADED (or TOCCATA_WASM) and CHECK_MEM_LEAK "
                      "at same time.\");\n "
                      "abort();\n"
                      "#endif\n"
                      "#endif\n"
                      "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                      "maybeNothing->refs = -1;\n"
                      "outstream = stdout;\n"
                      "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                      "futuresQueue.output = empty_list;\n"
                      "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                      "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                      "pthread_mutex_init(&shutDown.access, NULL);\n"
                      "startWorkers();\n"
                      (map protos .init)
                      (map symbols .init)
                      (map values .init) "\n"
                      (map symbols (fn [sym-map]
                                     ["if(" (.c-var sym-map) "->refs > 0)\n"
                                      (.c-var sym-map) "->refs = -1;\n"]))
                      "\n#\n"
                      "  List *argList = malloc_list();\n"
                      "  argList->len = 0;\n"
                      "  argList->head = (Value *)0;\n"
                      "  argList->tail = (List *)0;\n"
                      "  List *tail = argList;\n"
                      "  for(int i = 0; i < argc; i++) {\n"
                      "     List *newTail = malloc_list();\n"
                      "     newTail->len = 0;\n"
                      "     newTail->tail = (List *)0;\n"
                      "     newTail->head = (Value *)0;\n"
                      "     tail->head = stringValue(argv[i]);\n"
                      "     tail->tail = newTail;\n"
                      "     tail = newTail;\n"
                      "     argList->len++;\n}\n"
                      "  argList->refs = -1;\n"
                      "Value *the_final_answer = " (.c-var main-fn)
                      "((List *)0, (Value *)argList);\n\n"
                      "#ifdef CHECK_MEM_LEAK\n"
                      "cleaningUp = 1;\n"
                      "mainThreadDone = 1;\n"
                      "waitForWorkers();\n"
                      (map (vals modules) (fn [module]
                                            (either (map (get-in module [.values symbols-sym])
                                                         (fn [expr]
                                                           (free-global (c-init (.c-var expr) [] {} "" 0))))
                                                    "")))
                      (map values free-global)
                      "\n#\n"
                      "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                      "  if (malloc_count - free_count != 0)\n"
                      "    return(1);\n"
                      "#endif"
                      "\n#\n"
                      "  return(0);\n};\n"]))))

(defn get-proto-dispatch-sym [fn-sym num-args]
  (for [fn-var (lookup-sym fn-sym)
        arity-var (sm/get-in-val [.fns (.c-var fn-var) num-args])]
    (.c-var arity-var)))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (for [protos-var (global-var "protos_")
                              symbols-var (global-var "symbols_")
                              core-syms (sm/get-in-val [.modules 'core .values] {})
                              _ (sm/assoc-in-val [.modules module-name]
                                                 (Module module-name
                                                         {protocols-sym (c-code protos-var [] {} c/top-type)
                                                          symbols-sym (c-code symbols-var [] {} c/top-type)}
                                                         {} core-type-nums {} {}))
                              _ (declare ["Value *" protos-var " = (Value *)&emptyBMI;\n"
                                          "Value *" symbols-var " = (Value *)&emptyBMI;\n"])]
                          '_)
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              _ (map (sm/get-in-val [.fn-context .decl]) write-strings)
                              _ (sm/assoc-in-val [.fn-context .decl] [])
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))


(def fixup-native-symbols*
  (apply (wrap sm/zero-sm (fn [& decl]
                            (write-strings decl)))
          (list (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                     (fn [arity-sym]
                       ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                     (fn [arity-sym]
                       ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                     (fn [arity-sym]
                       ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                     (fn [arity-sym]
                       ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                     (fn [arity-sym]
                       ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                     (fn [arity-sym]
                       ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                     (fn [arity-sym]
                       ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'vals) 1)
                     (fn [arity-sym]
                       ["Value *(*vals)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'rest) 1)
                     (fn [arity-sym]
                       ["Value *(*rest)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'seq) 1)
                     (fn [arity-sym]
                       ["Value *(*seq)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                     (fn [arity-sym]
                       ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                     (fn [arity-sym]
                       ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'has-field) 2)
                     (fn [arity-sym]
                       ["Value *(*hasField)(List *, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                     (fn [arity-ptr]
                       ["Value *(*showFn)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'new-hash-set) 1)
                     (fn [arity-ptr]
                       ["Value *(*newHashSet)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'apply) 2)
                     (fn [arity-ptr]
                       ["Value *(*fn_apply)(List *, Value*, Value*) = " arity-ptr ";\n"]))
                )))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ev/Evaluator
  (ev/eval [x]
    (let [file (.file-path x)]
      (comp (for [curr-file-name (sm/get-val .file-name)
                  curr-file-path (sm/when (sys/file-directory curr-file-name))
                  :let [file (str curr-file-path file)]
                  mod-syms (comp (sm/get-in-val [.ns file .syms])
                                 (for [asts (sm/when (for [file-in (fio/file-in file)
                                                           asts (ev/parse {'file-name file
                                                                           'line-number 1}
                                                                          (lazy-list file-in))]
                                                       asts))
                                       _ (sm/set-val .file-name file)
                                       base-imports (sm/get-val .base-imports)
                                       _ (sm/assoc-in-val [.ns file] (ev/EvalNamespace file base-imports {} {}))
                                       _ (ev/eval asts)
                                       mod-syms (sm/get-in-val [.ns file .syms])]
                                   mod-syms))
                  _ (sm/assoc-in-val [.ns curr-file-name .imports file] mod-syms)]
              mod-syms)
            (ev/abort-interp "Could not import module" (str "'" file "'") "at"
                             (ev/ast-location-str x))))) 

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def repo-cloner (agent {}))

(defn clone-repo* [ast proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sh/command "/usr/bin/git" (list "clone" "--branch" branch
                                                  (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sh/command "/usr/bin/git"
                                            (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ev/Evaluator
  (ev/eval [ast]
    ;; Only called when interpreting a file (I think)
    (let [file (.file ast)]
      (either (and (-> file
                      seq
                      (some (partial = "/")))
                   (maybe (ev/abort-interp "For git dependencies,"
                                           "files may only be imported from root of repository,"
                                           file "is invalid.")))
              (comp (for [script-dir (sm/get-val .script-dir)
                          :let [clone-waiter (promise)
                                dep-path (do
                                           (clone-repo {} ast clone-waiter script-dir)
                                           (extract clone-waiter))
                                module-path (str dep-path "/" file)
                                _ (or (sys/access module-path)
                                      (do
                                        (print-err "Dependency file" file "missing from cloned repository"
                                                   (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                                        (abort)))]
                          curr-file-name (sm/get-val .file-name)
                          _ (sm/set-val .file-name module-path)
                          r (ev/eval (ast/module-ast file))
                          _ (sm/set-val .file-name curr-file-name)]
                      r)
                    (ev/abort-interp "Could not import module" (str "'" file "'") "from git repo at"
                                     (ev/ast-location-str ast))))))

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      [waiter ast])))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                ;; old code
                                ;; (map modules extract)
                                (map modules
                                     (fn [[waiter ast]]
                                       ;; TODO: refactor this mess
                                       (send ast-emitter
                                             (fn [context ns-file-name mod-file-name ns-sym]
                                               (update-context
                                                context
                                                (for [syms (sm/get-in-val [.modules ns-file-name .values])
                                                      _ (sm/assoc-in-val [.modules mod-file-name .ns-syms ns-sym]
                                                                         syms)]
                                                  '_)))
                                             (extract waiter) (ast/file-name ast) (.ns-sym ast)))))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn fixup-generated-symbols [context file-name protocols-sym symbols-sym]
  (update-context context
                  (for [protocols-var (sm/get-in-val [.modules file-name .values protocols-sym])
                        _ (sm/assoc-in-val [.modules file-name .values 'protocols]
                                           protocols-var)
                        symbols-var (sm/get-in-val [.modules file-name .values symbols-sym])
                        _ (sm/assoc-in-val [.modules file-name .values 'symbols]
                                           symbols-var)]
                    '_)))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (do
                  (send ast-emitter
                        fixup-generated-symbols 'core protocols-sym symbols-sym)
                  (assoc modules 'core 'loaded))))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? HashMap loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (let [r (analyze-forms {'file-name file-name
                                                                         'root-directory root-dir
                                                                         'project-directory proj-dir
                                                                         'line-number 1}
                                                                        (lazy-list file-in))]
                                                   (send ast-emitter
                                                         fixup-generated-symbols file-name
                                                         protocols-sym symbols-sym)
                                                   r)))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(extend-type ev/Thunk
  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (wrap sm/zero-sm (fn [& rules]
                      (apply (wrap sm/zero-sm (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type ev/ProtoDispatcher
  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (wrap sm/zero-sm (fn [& rules]
                      (apply (wrap sm/zero-sm (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type sm/new-sm
  ev/Evaluator
  (ev/apply-fn [mv [state]]
    (wrap sm/zero-sm (mv state))))

(main [params]
  (either (or (and (< (count params) 2)
                   (do
                     (print-err "A filename to compile must be provided.")
                     (maybe -1)))
              (and (< 2 (count params))
                   (let [[_ option file-name & args] params]
                     (or (and (= "--script" option)
                              (flat-map (sys/file-directory file-name)
                                        (fn [script-dir]
                                          (interp/interp-file
                                           file-name script-dir
                                           [(interp/CompiledNs 'file (either (get fio/symbols 'filename)
                                                                             "")
                                                               fio/symbols fio/protocols)
                                            (interp/CompiledNs 'reader (either (get rdr/symbols 'filename)
                                                                               "")
                                                               rdr/symbols rdr/protocols)
                                            (interp/CompiledNs 'grammar  (either (get grmr/symbols 'filename)
                                                                                 "")
                                                               grmr/symbols grmr/protocols)
                                            (interp/CompiledNs 'parse  (either (get rd/symbols 'filename)
                                                                               "")
                                                               rd/symbols rd/protocols)
                                            (interp/CompiledNs 'ast  (either (get ast/symbols 'filename)
                                                                             "")
                                                               ast/symbols ast/protocols)
                                            (interp/CompiledNs 'sys  (either (get sys/symbols 'filename)
                                                                             "")
                                                               sys/symbols sys/protocols)
                                            (interp/CompiledNs 'state-maybe  (either (get sm/symbols 'filename)
                                                                                     "")
                                                               sm/symbols sm/protocols)
                                            (interp/CompiledNs 'const  (either (get c/symbols 'filename)
                                                                               "")
                                                               c/symbols c/protocols)
                                            (interp/CompiledNs 'shell  (either (get sh/symbols 'filename)
                                                                               "")
                                                               sh/symbols sh/protocols)
                                            (interp/CompiledNs 'strm  (either (get strm/symbols 'filename)
                                                                              "")
                                                               strm/symbols strm/protocols)]
                                           args))))
                         (do
                           (print-err "The only option for the compiler is '--script'")
                           (maybe -1))))))
          (let [[_ file-name] params
                waiter (promise)]
            (or (map (sys/file-directory file-name)
                     (fn [root-dir]
                       (write-strings ["\n#define _XOPEN_SOURCE 600"
                                       "\n#include <stdlib.h>"
                                       "\n#include \"core.h\"\n"])
                       (send module-compiler compile-module file-name waiter root-dir root-dir)))
                (do
                  (print-err "Could not find " (str "'" file-name "'"))
                  (abort)))
            (extract waiter)
            (send ast-emitter (fn [context]
                                (write-strings ["\nint typeCount = "
                                                (str (extract rdr/type-counter))
                                                ";\n"])
                                context))
            (send ast-emitter emit-main)
            (send ast-emitter fixup-native-symbols)
            (send ast-emitter (fn [ctxt]
                                (map (get-in ctxt ['_ .constants .other])
                                     (fn [counts]
                                       (apply print-err (list* "\n" (interpose (map (seq counts)
                                                                                     (fn [[k v]]
                                                                                       (str k ": " v)))
                                                                               "\n")))
                                       (print-err "number of types" (extract rdr/type-counter))))))
            ;; wait for agents to clear their queues
            (let [waiter (promise)]
              (send ast-emitter (fn [_]
                                  (send string-writer (fn [_]
                                                        (deliver waiter 'x)))))
              (extract waiter)))))
