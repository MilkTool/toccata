
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "fb242d4"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "c89ab00"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "7690cd3"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "28f53b9"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "ecde30b"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e7a489b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "5cb99a5"))

(def Tagged (comp ast/SymbolOrString
                  rdr/tagged-symbol))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "\n")

(defn line-macro [ast marker]
  (let [file-name (ast/file-name ast)]
    (sm/state-maybe (either (= "" file-name)
                            ["\n" marker "\n// #line "
                             (str (ast/line-number ast)) " " "\""
                             (either (and (= 'core file-name)
                                          (maybe path-to-core))
                                     file-name)
                             "\"\n"]))))

(def IgnoreType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IgnoreType};"))
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringBufferType "String"
                 SubStringType "String"
                 FnArityType "FnArity"
                 FunctionType "Function"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-types {'Integer #{IntegerType}
                 'StringBuffer #{StringBufferType}
                 'SubString #{SubStringType}
                 'FnArity #{FnArityType}
                 'Function #{FunctionType}
                 'List #{ListType}
                 'Maybe #{MaybeType}
                 'Vector #{VectorType}
                 'Symbol #{SymbolType}
                 'BitmapIndexedNode #{BitmapIndexedType}
                 'ArrayNode #{ArrayNodeType}
                 'HashCollisionNode #{HashCollisionNodeType}
                 'HashMap #{ArrayNodeType BitmapIndexedType HashCollisionNodeType}
                 'Promise #{PromiseType}
                 'Future #{FutureType}
                 'Agent #{AgentType}
                 'Opaque #{OpaqueType}
                 'TypeCount #{TypeCount}})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params return-constraints])

  ;; Does 'ast' produce any executable code when emitted?
  (produces-code? [ast]
    (assert-result x (instance? Maybe x))
    (maybe ast))

  ;; Emit a call expression if the call target is a tagged-symbol. Otherwise, fail
  (emit-call-expr [target-ast args call-expr-ast]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x))))

(defprotocol Assertion
  (get-param-constraints [_]
    (assert-result x (instance? sm/new-sm x)))

  (assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (return-assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (add-assertion [ast]
    (assert-result x (instance? sm/new-sm x)))

  (format-path [ast]
    (either (empty? (.path ast))
            (map (.path ast)
                 (fn [[file line]]
                   (str file " " line)))))

  (assert-type [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (assert-return-type [ast]
    (assert-result x (instance? Maybe x))
    nothing))

;; combine a sequence of expressions, adding reference increments and decrements
;; where needed
(defprotocol C-Code
  (check-seq-constraints [var assertions arg file-name line-number])

  (collapse-expressions* [x y]))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; type-num: the Toccata type of the value produced
;; refs-map: map of C variables that are used in 'init' and how many times
(deftype empty-code [c-var init decl type-num refs-map]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap refs-map))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Composition
  (zero [c] c)
  (comp* [_ cs]
    (apply comp cs))

  C-Code
  (check-seq-constraints [var _ _ _ _]
    (sm/state-maybe var))

  (collapse-expressions* [x y] y)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def empty-c-code (empty-code "" [] [] UnknownType {}))

(deftype c-code [c-var init decl type-num refs-map]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap refs-map))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c collapse-expressions*))

  Collection
  (empty? [c]
    (and (empty? (.init c))
         (empty? (.decl c))))

  C-Code
  (check-seq-constraints [var constraints arg file-name line-number]
    ;; TODO: this will be needed later
    ;; (sm/state-maybe (.init var [init
    ;;                             "if (((Integer *)count(empty_list, " (.c-var var) "))->numVal < "
    ;;                             (str (count assertions)) ") {" line-sep
    ;;                             "fprintf(stderr, \"Insufficient values at %s, line %d\\n\", \""
    ;;                             file-name "\"," line-number ");" line-sep
    ;;                             "fprintf(stderr, \"Needed " (str (count assertions))
    ;;                             ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, "
    ;;                             (.c-var var) "))->numVal);" line-sep
    ;;                             "abort();" line-sep
    ;;                             "}" line-sep]))
    (sm/state-maybe empty-c-code))

  (collapse-expressions* [x y]
    (c-code (.c-var y)
            [(.init x) (.init y)]
            [(.decl x) (.decl y)]
            (.type-num y)
            (merge-with + (.refs-map x) (.refs-map y))))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl type-num refs-map]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap refs-map))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing)

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (c-init (.c-var c)
                           [(.init result) (.init c)]
                           [(.decl result) (.decl c)]
                           (.type-num c)
                           (merge-with + (.refs-map result) (.refs-map c))))))

  C-Code
  (check-seq-constraints [var constraints arg file-name line-number]
    ;; TODO: this will be needed later
    ;; (sm/state-maybe (.init var [init
    ;;                             "if (((Integer *)count(empty_list, " (.c-var var) "))->numVal < "
    ;;                             (str (count assertions)) ") {" line-sep
    ;;                             "fprintf(stderr, \"Insufficient values at %s, line %d\\n\", \""
    ;;                             file-name "\"," line-number ");" line-sep
    ;;                             "fprintf(stderr, \"Needed " (str (count assertions))
    ;;                             ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, "
    ;;                             (.c-var var) "))->numVal);" line-sep
    ;;                             "abort();" line-sep
    ;;                             "}" line-sep]))
    (sm/state-maybe empty-c-code))

  (collapse-expressions* [x y]
    (let [init (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" ["incRef(" c-var ", " (dec refs) ");" line-sep])
                               (.init y)])
                            (and (= "" c-var)
                                 (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" c-var ", 1);" line-sep
                        (.init y)])
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              [(.decl x) (.decl y)]
              (.type-num y)
              refs-map)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(deftype list-c-code [c-var init decl type-num refs-map len]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap refs-map))

  Stringable
  (string-list [_]
    (list "<C-List " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing)

  Composition
  (zero [_] empty-c-code)

  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (list-c-code (.c-var c)
                                [(.init result) (.init c)]
                                [(.decl result) (.decl c)]
                                (.type-num c)
                                (merge-with + (.refs-map result) (.refs-map c))
                                len))))

  C-Code
  (check-seq-constraints [a _ _ _ _]
    (sm/state-maybe empty-c-code))

  (collapse-expressions* [x y]
    (let [init (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" ["incRef(" c-var ", " (dec refs) ");" line-sep])
                               (.init y)])
                            (and (= "" c-var)
                                 (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" c-var ", 1);" line-sep
                        (.init y)])
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              [(.decl x) (.decl y)]
              (.type-num y)
              refs-map)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(deftype vector-c-code [c-var init decl type-num refs-map len]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? Integer type-num))
  (assert (instance? HashMap refs-map))

  Stringable
  (string-list [_]
    (list "<C-Vector " (str c-var) ", len: " (str len) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing)

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (vector-c-code (.c-var c)
                                  [(.init result) (.init c)]
                                  [(.decl result) (.decl c)]
                                  (.type-num c)
                                  (merge-with + (.refs-map result) (.refs-map c))
                                  len))))

  C-Code
  (check-seq-constraints [a _ _ _ _]
    (sm/state-maybe empty-c-code))

  (collapse-expressions* [x y]
    (let [init (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" ["incRef(" c-var ", " (dec refs) ");" line-sep])
                               (.init y)])
                            (and (= "" c-var)
                                 (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" c-var ", 1);" line-sep
                        (.init y)])
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              [(.decl x) (.decl y)]
              (.type-num y)
              refs-map)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def C-expr (comp empty-code
                  c-code
                  c-init
                  list-c-code
                  vector-c-code))

(defprotocol Constraint
  (update-path [constraint file-name line-number]
    (.path constraint (cons [(str file-name ":") line-number] (.path constraint))))

  (update-sym [constraint new-sym]
    (assert (instance? Tagged new-sym)))

  (runtime-check [constraint var file-name line-number])

  (static-check [constraint expr file-name line-number])

  (check-constraint [constraint ast expr file-name line-number]
    ;; Check that a ast and it's compiled expression do not contradict
    ;; a constraint (constraint). And that the constraint does not conflict with an earlier one
    ;; Adds code to check at runtime if cannot rule out conflict
    (assert (instance? C-expr expr))
    (assert-result x (instance? sm/new-sm x)))

  (to-assertion [ast sym])

  (conflict [new-constraint old-constraint file-name line-number])

  (restrict [new-constraint old-constraint]))

(defn collapse-expressions [cs]
  (either (and (empty? cs) (maybe empty-c-code))
          (let [[c & cs] (reverse cs)
                cs (remove cs empty?)]
            (reduce cs c (fn [y x]
                           (collapse-expressions* x y))))))

(deftype Closures [closures refs-map constraints]
  (assert (instance? Vector closures))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints)))

(def empty-closures (Closures [] {} {}))

(deftype ConstantValues [numbers strings symbols type-names]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names)))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count syms context-syms closed-over
                               constraints params]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  ;;                    hash-map from Symbol to SymbolInfo
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))
  ;; constraints   constraints on C variables
  (assert (instance? HashMap constraints))
  ;; params        parameters passed to the function arity
  (assert (instance? HashMap params))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types declarations]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; proto-fns        map of protocol fn symbols to fn information
  (assert (instance? HashMap proto-fns))
  ;; types            map of type symbols to type definitions
  (assert (instance? HashMap types))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [fn-context init modules fns namespaces constants reify-fn-index other]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit init))
  ;; modules                info for each module compiled
  (assert (instance? HashMap modules))
  ;; fns                    static functions
  (assert (instance? HashMap fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))
  ;; other                  a map of anything
  (assert (instance? HashMap other))

  Stringable
  (string-list [_] (list "<GlobalContext>")))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      new-context (comp (-> curr-fn-context .context-syms)
                                        (-> curr-fn-context .syms))]
                  (maybe [curr-fn-context
                          (.fn-context s
                                       (FunctionArityContext {} 0 {} new-context 
                                                             empty-closures {} {}))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.fn-context s) (.fn-context s new-fn-context)])))))

(defn extract-sym-path [s sym]
  (let [file-name (ast/file-name sym)]
    (flat-map (rdr/namespace sym)
              (fn [ns-sym] 
                (or (get-in (.namespaces s) [file-name ns-sym])
                    (get-in (.namespaces s) [file-name (rdr/tag ns-sym)]))))))

(defn sym-ns-path [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (map (extract-sym-path s sym) (fn [path]
                                                   [path s]))
                   (maybe [(ast/file-name sym) s])))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (sm/new-sm (fn [s]
                     (assert (instance? GlobalContext s))
                     (-> (.modules s)
                         (get (ast/file-name proto-sym))
                         (flat-map (fn [module]
                                     (map (get (.protocols module) proto-sym)
                                          (fn [proto-info]
                                            (print-err  "Duplicate protocol"
                                                        (str "'" proto-sym "'") "at"
                                                        (str (ast/file-name proto-sym) ":")
                                                        (ast/line-number proto-sym))
                                            (abort))))))))
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [path (either (extract-sym-path s proto-sym)
                                      (ast/file-name proto-sym))]
                     (for [proto-info (-> (.modules s)
                                          (get path)
                                          (flat-map (fn [module]
                                                      (get (.protocols module) proto-sym))))]
                       [proto-info s]))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.protocols module) proto-sym))))]
                     [proto-info s])))))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  (assert (instance? Tagged fn-sym))
  (assert (instance? Symbol disp-sym))
  (assert (instance? HashMap dispatchers))

  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (sm/new-sm (fn [s]
                     (assert (instance? GlobalContext s))
                     (-> (.modules s)
                         (get (ast/file-name fn-sym))
                         (flat-map (fn [module]
                                     (map (get (.proto-fns module) fn-sym)
                                          (fn [proto-info]
                                            (print-err "Duplicate protocol function"
                                                       (str "'" fn-sym "'") "at"
                                                       (str (ast/file-name fn-sym) ":")
                                                       (ast/line-number fn-sym))
                                            (abort))))))))
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (and (-> (.modules s)
                        (get path)
                        (flat-map (fn [module]
                                    (get (.proto-fns module) fn-sym))))
                    (maybe [path s])))))

(defn find-protocol-path [fn-sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [namespace (either (extract-sym-path s fn-sym)
                                           (ast/file-name fn-sym))]
                     (and (-> (.modules s)
                              (get namespace)
                              (flat-map (fn [module]
                                          (get (.proto-fns module) fn-sym))))
                          (maybe [namespace s])))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.proto-fns module) fn-sym))))]
                     ['core s])))))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym return-type
                             return-constraints param-constraints type-impls]
  (assert (instance? Integer arg-count))
  (assert (instance? Symbol dispatch-sym))
  (assert (instance? Symbol impls-sym))
  (assert (instance? Integer return-type))
  (assert (instance? Vector return-constraints))
  (assert (instance? Sequence param-constraints))
  (assert (instance? HashMap type-impls))

  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) " " (str return-type) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym return-type
                            return-constraints param-constraints]
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym return-type
                                       return-constraints param-constraints {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [namespace (either (extract-sym-path s fn-sym)
                                           (ast/file-name fn-sym))]
                     (for [module (get (.modules s) namespace)
                           proto-fn (get (.proto-fns module) fn-sym)
                           dispatcher (get (.dispatchers proto-fn) num-args)]
                       [dispatcher s]))
                   (for [module (get (.modules s) 'core)
                         proto-fn (get (.proto-fns module) fn-sym)
                         dispatcher (get (.dispatchers proto-fn) num-args)]
                     [dispatcher s])))))

(defn get-proto-impls-sym [fn-sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [namespace (either (extract-sym-path s fn-sym)
                                           (ast/file-name fn-sym))]
                     (for [module (get (.modules s) namespace)
                           proto-fn (get (.proto-fns module) fn-sym)
                           dispatcher (get (.dispatchers proto-fn) num-args)
                           impls-sym (get dispatcher .impls-sym)]
                       [impls-sym s]))
                   (for [module (get (.modules s) 'core)
                         proto-fn (get (.proto-fns module) fn-sym)
                         dispatcher (get (.dispatchers proto-fn) num-args)
                         impls-sym (get dispatcher .impls-sym)]
                     [impls-sym s])))))

(deftype ProtoImpl [dispatch-type c-var ast]
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/SymbolOrString c-var))

  Stringable
  (string-list [_] (list "<ProtoImpl " (target-type-name dispatch-type) " " c-var ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type c-code ast]
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type (.c-var c-code) ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [proto-path (either (extract-sym-path s fn-name)
                                            (ast/file-name fn-name))]
                     (for [module (get (.modules s) proto-path)
                           proto-fn (get (.proto-fns module) fn-name)
                           dispatcher (get (.dispatchers proto-fn) arg-count)
                           impl-info (get (.type-impls dispatcher) type-num)]
                       [impl-info s]))
                   (for [module (get (.modules s) 'core)
                         proto-fn (get (.proto-fns module) fn-name)
                         dispatcher (get (.dispatchers proto-fn) arg-count)
                         impl-info (get (.type-impls dispatcher) type-num)]
                     [impl-info s])))))


(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str start (seq remaining)))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (either (check-C-var (str sym "_"))
                                       arg-name)
                               sym-count)
                          new-ctxt]))))))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(deftype ParamBinding [vars destruct]
  (assert (instance? Vector vars))
  (assert (instance? Vector destruct))

  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (vec (cons x xs))]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn traverse [asts f]
  (assert-result x (instance? sm/new-sm x))

  ;; TODO: use a vector instead
  (reduce (reverse asts) (sm/state-maybe empty-list)
            (fn [l ast]
              (flat-map (f ast)
                        (fn [emitted]
                          (map l (fn [x]
                                   (cons emitted x))))))))

(extend-type List
  Assertion
  (check-constraint [constraints ast expr file-name line-number]
    (check-seq-constraints expr constraints ast file-name line-number))

  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts args return-constraints]
    (let [asts (-> asts
                   (filter produces-code?)
                   reverse)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args return-constraints)
                    (cons init)
                    reverse))))))

(extend-type Vector
  Emitter
  (emit [asts]
    (traverse asts emit))

  (tail-call [asts params return-constraints]
    (let [asts (filter asts produces-code?)]
      (extract (or (empty? asts)
                   (flat-map (last asts)
                             (fn [tail]
                               (store asts (dec (count asts))
                                      (tail-call tail params return-constraints)))))))))

(extend-type HashSet
  Assertion
  (check-constraint [constraints ast expr file-name line-number]
    (check-seq-constraints expr (seq constraints) ast file-name line-number)))

;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name] (sm/state-maybe (gensym arg-name)))
  ([sym arg-name]
   (sm/state-maybe (gensym (either (check-C-var (str sym "_"))
                                   arg-name)))))


(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.modules s)
                   (get (ast/file-name sym))
                   (flat-map (fn [module]
                               (map (get-in (.declarations module) [sym '_])
                                    (fn [expr]
                                      [expr s]))))))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(def get-all-constraints (sm/new-sm (fn [s]
                                  (assert (instance? GlobalContext s))
                                  (maybe [(.constraints (.fn-context s)) s]))))

(defn get-constraints [var]
  (flat-map get-all-constraints (fn [constraints]
                              (sm/when (or (get constraints var)
                                           (maybe #{}))))))

(defn set-all-constraints [constraints]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.constraints (.fn-context s) constraints))]))))

(defn set-constraints [var constraint-set]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     constraints (.constraints ctxt)]
                 (maybe [s (.fn-context s (.constraints ctxt (assoc constraints
                                                               var constraint-set)))])))))

(def get-params (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           ;; TODO: these calls should be type-known. They're not
                           (maybe [(.params (.fn-context s)) s]))))

(defn set-params [params]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.params (.fn-context s) params))]))))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn get-sym [sym]
  (flat-map get-syms (fn [syms]
                       (sm/when (get syms sym)))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

(defn lookup-sym [sym]
  (let [sym-file (ast/file-name sym)]
    (comp (sm/new-sm
           (fn [s]
             (assert (instance? GlobalContext s))
             (let [ctxt (.fn-context s)
                   syms (.syms ctxt)
                   modules (.modules s)
                   closed-over (.closed-over ctxt)
                   closures (.closures closed-over)
                   refs-map (.refs-map closed-over)]
               (or (map (or (and (rdr/namespace sym)
                                 (or (-> (flat-map (extract-sym-path s sym)
                                                   (partial get modules))
                                         (flat-map (fn [module]
                                                     (let [values (.values module)]
                                                       (or (get values (.base sym))
                                                           (get values (rdr/tag (.base sym))))))))
                                     (do
                                       (print-err "Undefined symbol" (str "'" sym "'") "at"
                                                  (str sym-file ":")
                                                  (ast/line-number sym))
                                       (maybe (abort)))))
                            (get syms sym))
                        (fn [expr]
                          [expr s]))
                   (map (-> ctxt .context-syms (get sym) (map .type-num))
                        (fn [type-num]
                          (either (some closures
                                        (fn [[closure-var sym-literal]]
                                          (for [_ (= sym sym-literal)
                                                refs-count (get refs-map closure-var)]
                                            (let [new-refs-map (assoc refs-map closure-var (inc refs-count))
                                                  new-closed-over (.refs-map closed-over new-refs-map)
                                                  new-ctxt (.closed-over ctxt new-closed-over)]
                                              [(c-code closure-var [] [] type-num {closure-var 1})
                                               (.fn-context s new-ctxt)]))))
                                  (let [sym-count (.sym-count ctxt)
                                        closure-var (str "val" sym-count)
                                        new-sym-count (inc sym-count)
                                        new-closures (conj closures [closure-var sym])
                                        new-refs-map (assoc refs-map closure-var 1)
                                        new-closed-over (-> closed-over
                                                            (.closures new-closures)
                                                            (.refs-map new-refs-map))
                                        new-ctxt (-> ctxt
                                                     (.sym-count new-sym-count)
                                                     (.closed-over new-closed-over))]
                                    [(c-code closure-var [] [] type-num {closure-var 1})
                                     (.fn-context s new-ctxt)]))))
                   (map (or (flat-map (get modules sym-file)
                                      (fn [module]
                                        (or (get (.values module) sym)
                                            (get-in (.declarations module) [sym '_]))))
                            (flat-map (get modules 'core)
                                      (fn [module]
                                        (get (.values module) sym))))
                        (fn [expr] [expr s]))
                   (do
                     (print-err "Undefined symbol" (str "'" sym "'") "at"
                                (str sym-file ":")
                                (ast/line-number sym))
                     (abort)))))))))

(deftype StaticArityInfo [c-info param-constraints]
  (assert (instance? C-expr c-info))
  (assert (instance? Sequence param-constraints)))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.fns s)
                   (get-in [fn-var num-params .c-info])
                   (map (fn [expr]
                          [expr s]))))))

(defn lookup-static-constraints [fn-var num-params]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [(either (get-in (.fns s) [fn-var num-params .param-constraints])
                               [])
                       s]))))

(defn new-static-arity
  ([fn-var num-params arity-var type-num]
   (new-static-arity fn-var num-params arity-var type-num []))
  ([fn-var num-params arity-var type-num param-constraints]
   (sm/assoc-in-val [.fns fn-var num-params]
                    (StaticArityInfo (c-code arity-var [] [] type-num {})
                                     param-constraints))))

(defn lookup-core-fn-arity [sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [module (get (.modules s) 'core)
                     fn-sym (get (.values module) sym)
                     expr (get-in (.fns s) [(.c-var fn-sym) num-args .c-info])]
                 [expr s]))))


(extend-type ast/block-comment-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))

  (emit-defined-value [_ _] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe []))

  (tail-call [ast params return-constraints] ast))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (sm/new-sm (fn [s]
                               (assert (instance? GlobalContext s))
                               (-> s
                                   .constants
                                   .strings
                                   count
                                   (vector s)
                                   maybe)))
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.constants .strings str-val] (c-code str-ptr [] [] StringBufferType {}))]
      (c-init str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringBufferType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringBufferType {}))))

(defn make-c-code [value]
  (c-code (.c-var value) (.init value) (.decl value) (.type-num value) (.refs-map value)))

(defn get-type-nums [path type-symbol]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [modules (.modules s)]
                 (map (or (flat-map (get modules path)
                                    (fn [module]
                                      (get (.types module) type-symbol)))
                          (flat-map (get modules 'core)
                                    (fn [module]
                                      (get (.types module) type-symbol))))
                      (fn [type-nums]
                        [type-nums s]))))))

(defn get-type-numbers [type-symbol]
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-nums ns-path type-symbol)]
          type-nums)
        (sm/state-maybe #{})))

(defn get-type-number [type-symbol]
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-nums ns-path type-symbol)]
          (either (and (= 1 (count type-nums))
                       (first (seq type-nums)))
                  UnknownType))
        (sm/state-maybe UnknownType)))

(defn get-asserted-types [type-symbol file-name line-number]
  (comp (for [ns-path (sym-ns-path type-symbol)
              type-nums (get-type-nums ns-path type-symbol)]
          type-nums)
        (compilation-error "Unknown type"
                           (str "'" type-symbol "'")
                           "in assertion at"
                           (str file-name ":")
                           line-number)))

(defn get-asserted-type [type-symbol file-name line-number]
  (comp (for [ns-path (sym-ns-path type-symbol)
              type-nums (get-type-nums ns-path type-symbol)]
          (either (and (= 1 (count type-nums))
                       (first (seq type-nums)))
                  UnknownType))
        (compilation-error "Unknown type"
                           (str "'" type-symbol "'")
                           "in assertion at"
                           (str file-name ":")
                           line-number)))

(defn set-type [sym type-num]
  (comp (for [_ (get-sym sym)
              _ (sm/assoc-in-val [.fn-context .syms sym .type-num] type-num)]
          "")
        sm-space))

;; TODO: line numbering starts to go wrong here

(extend-type ast/assert-ast
  Assertion
  (assertion? [ast]
    (maybe ast))

  (assert-type [ast]
    (assert-type (.assertion ast)))

  Emitter
  (replace-bound-vars [ast subs]
    (ast/assert-ast (replace-bound-vars (.assertion ast) subs)))

  (replace-syms [ast subs]
    (map (replace-syms (.assertion ast) subs)
         (fn [assertion]
           (ast/assert-ast assertion))))

  (produces-code? [ast]
    nothing)

  (emit [ast]
    (let [assertion (.assertion ast)
          file-name (ast/file-name ast)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (add-assertion (.path assertion (conj (.path assertion)
                                            [(str file-name ":") (ast/line-number ast)])))))

  (tail-call [ast params return-constraints] ast))

(defn add-constraint [new-constraint arg expr file-name line-number]
  (let [var (.c-var expr)
        sym (either (and (or (instance? Symbol arg)
                             (instance? rdr/tagged-symbol arg))
                         (maybe arg))
                    "")]
    ;; TODO: how to set type in a generic 'add-constraint'
    ;; asserted-type (get-asserted-type type-sym file-name line-number)
    ;; Only set the type of the var if there is one and only one
    ;; asserted type number
    ;; _ (set-type sym asserted-type)
    (comp (for [constraints (get-constraints var)
                new (sm/when (map (every (seq constraints)
                                         (fn [old-constraint]
                                           (or (conflict new-constraint old-constraint
                                                         file-name line-number)
                                               (restrict new-constraint old-constraint)
                                               (maybe old-constraint))))
                                  set))
                _ (set-constraints var (either (map (= new constraints)
                                                    (fn [old]
                                                      (conj old new-constraint)))
                                               new))]
            empty-c-code)
          ;; TODO: just in case something slips through during development
          (for [_ (debug "Could not add constraint for" (str "'" sym "'") "at"
                         (str file-name ":") line-number)
                _ (debug new-constraint)]
            empty-c-code)
          (sm/state-maybe empty-c-code))))

(defn constrain-symbol [new-constraint sym]
  (let [file-name (ast/file-name sym)
        file-name (either (and (= file-name 'core)
                               (maybe "$TOCCATA_DIR/core.toc"))
                          file-name)
        line-number (ast/line-number sym)]
    (for [expr (comp (lookup-sym sym)
                     (compilation-error "Invalid assertion at"
                                        (str file-name ":") (str line-number ".")
                                        "Symbol" (str "'" sym "' not found.")))
          _ (add-constraint new-constraint sym expr file-name line-number)]
      empty-c-code)))

(defn conflicting-assertions [path1 path2 file-name line-number]
  (let [max-path (either (> (count path1) (count path2))
                         (count path2))
        path1 (either (map (< (count path1) max-path)
                           (fn [_]
                             (comp path1 (repeat (- max-path (count path1)) ""))))
                      path1)
        path2 (either (map (< (count path2) max-path)
                           (fn [_]
                             (comp path2 (repeat (- max-path (count path2)) ""))))
                      path2)
        max-width (reduce path1 0 (fn [max s]
                                    (either (> max (count s))
                                            (count s))))]
    (apply print-err "Conflicting assertions at"
           (str file-name ":") line-number "\n"
           (map (zip-lists path1 path2)
                (fn [[x y]]
                  (str x (spaces (- max-width (count x))) "   " y "\n"))))
    (maybe (abort))))

(deftype TypeConstraint [type-nums path type-sym constrained-symbol]
  (assert (instance? HashSet type-nums))
  (assert (instance? List path))
  (assert (instance? Maybe constrained-symbol))

  Eq
  (=* [x y]
    (and (instance? TypeConstraint y)
         (= type-nums (.type-nums y))
         (maybe x)))

  Hashable
  (sha1-update [s ctxt]
    (sha1-update-type s ctxt)
    (sha1-update type-nums ctxt))

  (sha1 [s]
    (let [ctxt (sha1-init)]
      (sha1-update-type s ctxt)
      (sha1-update type-nums ctxt)
      (sha1-finalize ctxt)))

  Stringable
  (string-list [_]
    (list "<TypeConstraint " (str type-sym) " " (str type-nums)
          " " (str constrained-symbol) ">"))

  ;; TODO: should be Constraint eventually
  Assertion
  (to-assertion [constraint sym]
    (ast/assert-ast (ast/type-assertion type-sym sym (rest path))))

  Constraint
  (update-sym [_ new-sym]
    (TypeConstraint type-nums path type-sym (maybe new-sym)))

  (restrict [new-constraint old-constraint]
    (and (instance? TypeConstraint old-constraint)
         (maybe (.type-nums new-constraint
                            (intersection type-nums (.type-nums old-constraint))))))

  (conflict [type1 type2 file-name line-number]
    (and (flat-map (get type2 .type-nums)
                   (fn [other-type-nums]
                     (empty? (intersection type-nums other-type-nums))))
         (conflicting-assertions (cons (str "'" type-sym "' from:") (format-path type1))
                                 (cons (str "'" (.type-sym type2)  "' from:") (format-path type2))
                                 file-name line-number)))

  (runtime-check [constraint var file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          sym-location (either (= "" file-name)
                               (str " at " file-name ", line " line-number))]
      ["switch (" var "->type) {" line-sep
       (map (seq type-nums) (fn [type-num]
                              ["case " type-num ": " line-sep]))
       "break;" line-sep " default:"
       "\n#ifndef EMBEDDED\n"
       "fprintf(stderr, \"Invalid type of value for "
       "parameter '" (either constrained-symbol "<unknown>") "'" sym-location "\\n\");\n"
       "fprintf(stderr, \"Needed %s, got %s\\n\", \""
       (str type-sym)
       "\", extractStr(type_name(empty_list, "
       var ")));" line-sep
       "fprintf(stderr, \"From: \\n"
       (interpose (format-path constraint) "\\n")
       "\\n\");"
       "\n#endif\n"
       "abort();" line-sep
       "}" line-sep]))

  (static-check [constraint expr file-name line-number]
    (for [_ (sm/when-not (or (= UnknownType (.type-num expr))
                             (= IgnoreType (.type-num expr))))
          bad-type-sym (sm/get-in-val [.constants .type-names (.type-num expr)]
                                      (.type-num expr))
          _ (comp (sm/when (type-nums (.type-num expr)))
                  (apply compilation-error
                         "Failed type assertion at"
                         (str file-name ":") (str line-number ".")
                         "\nExpected" (str "'" type-sym "', got")
                         (str "'" bad-type-sym "'.")
                         "\nAssertion from\n"
                         (interpose (format-path constraint) "\n")))]
      empty-c-code)))

(deftype MinCountConstraint [min-count path constrained-symbol]
  (assert (instance? List path))
  (assert (instance? Maybe constrained-symbol))

  Eq
  (=* [x y]
    (and (instance? MinCountConstraint y)
         (= min-count (.min-count y))
         (maybe x)))

  Hashable
  (sha1-update [s ctxt]
    (sha1-update-type s ctxt)
    (sha1-update min-count ctxt))

  (sha1 [s]
    (let [ctxt (sha1-init)]
      (sha1-update-type s ctxt)
      (sha1-update min-count ctxt)
      (sha1-finalize ctxt)))

  Stringable
  (string-list [_]
    (list "<MinCountConstraint " (str min-count) " " (str constrained-symbol) ">"))

  ;; TODO: should be Constraint eventually
  Assertion
  (to-assertion [constraint sym]
    (ast/assert-ast (ast/min-count-assertion sym min-count (rest path))))

  Constraint
  (update-sym [_ new-sym]
    (MinCountConstraint min-count path (maybe new-sym)))

  (restrict [new-constraint old-constraint]
    (and (instance? MinCountConstraint old-constraint)
         (< (.min-count old-constraint) min-count)
         (maybe new-constraint)))

  (runtime-check [constraint var file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          sym-location (either (= "" file-name)
                               (str " at " file-name ", line " line-number))]
      ["if (countSeq(incRef(" var ", 1)) < " (str min-count) ") {"
       "\n#ifndef EMBEDDED\n"
       "fprintf(stderr, \"Insufficient values" sym-location "\\n\");\n"
       "fprintf(stderr, \"Needed " (str min-count)
       ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, " var "))->numVal);" line-sep
       "fprintf(stderr, \"From: \\n"
       (interpose (format-path constraint) "\\n")
       "\\n\");"
       "\n#endif\n"
       "abort();" line-sep
       "}" line-sep])))

(deftype StaticLengthConstraint [length path constrained-symbol]
  (assert (instance? List path))
  (assert (instance? Maybe constrained-symbol))

  Eq
  (=* [x y]
    (and (instance? StaticLengthConstraint y)
         (= length (.length y))
         (maybe x)))

  Hashable
  (sha1-update [s ctxt]
    (sha1-update-type s ctxt)
    (sha1-update length ctxt))

  (sha1 [s]
    (let [ctxt (sha1-init)]
      (sha1-update-type s ctxt)
      (sha1-update length ctxt)
      (sha1-finalize ctxt)))

  Stringable
  (string-list [_]
    (list "<StaticLengthConstraint " (str length) " " (str constrained-symbol) ">"))

  ;; TODO: should be Constraint eventually
  Assertion
  (to-assertion [constraint sym]
    (ast/assert-ast (ast/length-assertion sym length (rest path))))

  Constraint
  (update-sym [_ new-sym]
    (StaticLengthConstraint length path (maybe new-sym)))

  (restrict [new-constraint old-constraint]
    nothing)

  (conflict [type1 type2 file-name line-number]
    (or (flat-map (get type2 .min-count)
                  (fn [min-count]
                    (and (< length min-count)
                         (conflicting-assertions (cons "Actual length from:" (format-path type1))
                                                 (cons "Min length from:" (format-path type2))
                                                 file-name line-number))))
        ;; TODO: add max-count
        ))

  (runtime-check [constraint var file-name line-number]
    [])

  (static-check [constraint expr file-name line-number]
    (zero sm/state-maybe)))

(extend-type MinCountConstraint
  Constraint
  (static-check [constraint expr file-name line-number]
    (for [constraints (get-constraints (.c-var expr))
          :when (some (seq constraints)
                      (fn [expr-constraint]
                        (flat-map (get expr-constraint .length)
                                  (partial <= (.min-count constraint)))))]
      empty-c-code))

  (conflict [type1 type2 file-name line-number]
    (flat-map (get type2 .length)
              (fn [len]
                (and (< len (.min-count type1))
                     (conflicting-assertions (cons "Actual length from:" (format-path type2))
                                             (cons "Min length from:" (format-path type1))
                                             file-name line-number))))))

(def Constraints (comp TypeConstraint
                       StaticLengthConstraint
                       MinCountConstraint))

(extend-type Constraints
  Constraint
  (check-constraint [constraint ast expr file-name line-number]
    ;; Check that an ast and it's compiled expression do not contradict
    ;; a constraint (constraint). And that the constraint does not conflict with an earlier one
    ;; Adds code to check at runtime if cannot rule out conflict
    (assert (instance? C-expr expr))
    (assert-result x (instance? sm/new-sm x))

    (comp (for [params get-params
                :when (get params (.c-var expr))
                _ (add-constraint (update-path constraint file-name line-number)
                                  ast expr file-name line-number)]
            empty-c-code)
          (static-check constraint expr file-name line-number)
          (for [_ (sm/when (instance? Tagged ast))
                _ (add-constraint (update-path constraint file-name line-number)
                                  ast expr file-name line-number)
                line (line-macro ast "")]
            (c-code ""
                    [line
                     (runtime-check constraint (.c-var expr) file-name line-number)]
                    [] (.type-num expr) {}))
          (flat-map (line-macro ast "")
                    (fn [line]
                      (sm/state-maybe (c-code ""
                                              [line
                                               (runtime-check constraint (.c-var expr)
                                                              file-name line-number)]
                                              [] (.type-num expr) {})))))))

(extend-type ast/type-assertion
  Emitter
  (replace-bound-vars [ast subs]
    (.sym ast (either (get subs (.sym ast))
                      (.sym ast))))

  (replace-syms [ast subs]
    (sm/state-maybe (.sym ast (either (get subs (.sym ast))
                                      (.sym ast)))))

  (emit [ast]
    (for [type-nums (get-asserted-types (.type-sym ast) (ast/file-name ast) (ast/line-number ast))
          var (lookup-sym (.sym ast))]
      (c-code ""
              ["switch (" (.c-var var) "->type) {" line-sep
               (map (seq type-nums) (fn [type-num]
                                      ["case " type-num ": " line-sep]))
               "break;" line-sep " default: " line-sep
               "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
               (ast/file-name ast) "\"," (ast/line-number ast)
               ");" line-sep
               "fprintf(stderr, \"Expected %s, got %s\\n\", \""
               (str (.type-sym ast)) "\", extractStr(type_name(empty_list, " (.c-var var)
               ")));" line-sep
               "abort();" line-sep
               "}" line-sep]
              [] UnknownType {})))

  Assertion
  (assert-type [ast]
    (maybe (.type-sym ast)))

  (add-assertion [ast]
    (for [asserted (get-asserted-types (.type-sym ast) (ast/file-name ast) (ast/line-number ast))
          _ (comp (sm/when-not (= 1 (count asserted)))
                  (for [type-num (sm/when (first (seq asserted)))
                        _ (set-type (.sym ast) type-num)]
                    '_))
          r (constrain-symbol (TypeConstraint asserted (.path ast) (.type-sym ast)
                                              (maybe (.sym ast)))
                              (.sym ast))]
      r)))

(extend-type ast/result-ast
  Assertion
  (return-assertion? [ast] (maybe ast))

  (assert-return-type [ast]
    (for [type-sym (assert-type (.assertion ast))
          _ (= (.sym ast) (.sym (.assertion ast)))]
      type-sym))

  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe empty-c-code))

  (tail-call [ast params return-constraints] ast))

(defn emit-return-constraints [expr return-constraints]
  (traverse return-constraints
            (fn [constraint]
              (for [locals get-syms
                    _ (set-sym (.sym constraint) expr)
                    const-expr (emit (.assertion constraint))
                    _ (set-syms locals)]
                const-expr))))

(defn emit-tail-expr [ast file-name line-number return-constraints expr]
  (flat-map (get-type-numbers (some return-constraints assert-return-type))
            (fn [return-types]
              (comp (for [_ (sm/when (or (empty? return-types)
                                         (return-types (.type-num expr))))
                          return-assertions (emit-return-constraints expr
                                                                     (remove return-constraints
                                                                             assert-return-type))]
                      (collapse-expressions (comp [expr]
                                                  return-assertions
                                                  [(c-code ""
                                                           ["return(" (.c-var expr) ");" line-sep]
                                                           [] (.type-num expr)
                                                           {(.c-var expr) 1})])))
                    (for [_ (sm/when (= UnknownType (.type-num expr)))
                          return-assertions (emit-return-constraints expr return-constraints)]
                      (let [return-type (either (and (= 1 (count return-types))
                                                     (first (seq return-types)))
                                                UnknownType)]
                        ;; TODO: periodically enable this to check on things
                        ;; (print-err 'check (some return-constraints assert-return-type) return-type
                        ;;            (ast/file-name ast) (ast/line-number ast))
                        (collapse-expressions (comp [(.type-num expr return-type)]
                                                    return-assertions
                                                    [(c-code ""
                                                             ["return(" (.c-var expr) ");" line-sep]
                                                             [] return-type
                                                             {(.c-var expr) 1})]))))
                    (sm/new-sm (fn [s]
                                 (or (and (= "" (ast/file-name return-constraints))
                                          (maybe (print-err "Return value fails return assertion")))
                                     (maybe (print-err "Return value fails return assertion:"
                                                       (ast/file-name return-constraints)
                                                       (ast/line-number return-constraints))))
                                 nothing))))))

(deftype TailCall [ast params return-constraints]
  (assert (instance? Vector params))
  (assert (instance? Sequence return-constraints))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) " " (string-list return-constraints) " "
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))
  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (or (instance? Symbol (.call-target ast))
                                    (instance? rdr/tagged-symbol (.call-target ast)))))
                target (emit (.call-target ast))
                _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (filter produces-code?)
                         emit)
                line (line-macro ast "// recursive-fixed")]
            (collapse-expressions (comp args
                                        [(c-init ""
                                                 [line
                                                  (map (zip-lists params (map args .c-var))
                                                       (fn [[param arg]]
                                                         [param " = " arg ";" line-sep]))]
                                                 [] IgnoreType
                                                 (reduce (map args .c-var) {}
                                                         (fn [m arg]
                                                           (assoc m arg 1))))])))
          (flat-map (emit ast)
                    (partial emit-tail-expr
                             ast
                             (ast/file-name ast)
                             (ast/line-number ast)
                             return-constraints)))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.constants .strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] StringBufferType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailCall x params return-constraints)))


(defn make-static-num [num]
  (for [num-idx (sm/new-sm (fn [s]
                               (assert (instance? GlobalContext s))
                               (-> s
                                   .constants
                                   .numbers
                                   count
                                   (vector s)
                                   maybe)))
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Integer
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] IntegerType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailCall x params return-constraints)))


(extend-type ast/quoted-ast
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-code sym-ptr [] [] SymbolType {}))]
              (c-code sym-ptr
                      []
                      ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                       ", 0, 0, \"" sym "\"};\n"
                       "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                      SymbolType {})))))

  (emit-defined-value [ast defined-sym]
    (for [quoted (emit ast)
          _ (new-module-def defined-sym (c-code (.c-var quoted) [] [] SymbolType {}))]
      [(make-c-code quoted)]))

  (tail-call [ast params return-constraints]
    (TailCall ast params return-constraints)))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")
        _ (add-constraint (StaticLengthConstraint (count args)
                                                  (list [(ast/file-name target)
                                                         (ast/line-number target)])
                                                  nothing)
                          '_ (c-code result-sym [] [] UnknownType {})
                          (ast/file-name target) (ast/line-number target))
        line (line-macro target "// call-vector")]
    (comp* (vector-c-code "" [] [] VectorType {} (count args))
           (comp args
                 [(vector-c-code result-sym
                                 [line
                                  "Vector *" vect-sym " = empty_vect;" line-sep
                                  (map args
                                       (fn [arg]
                                         (let [arg-sym (.c-var arg)]
                                           [vect-sym " = mutateVectConj(" vect-sym ", "
                                            arg-sym ");" line-sep])))
                                  "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
                                 [] VectorType {} (count args))]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        line (line-macro target "// call-list")
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")
        _ (add-constraint (StaticLengthConstraint (count args)
                                                  (list [(ast/file-name target)
                                                         (ast/line-number target)])
                                                  nothing)
                          '_ (c-code result-sym [] [] UnknownType {})
                          (ast/file-name target) (ast/line-number target))]
    (comp* (list-c-code "" [] [] ListType {} (count args))
           (comp args
                 [(list-c-code result-sym
                               [line "List *" list-sym " = empty_list;" line-sep
                                (map (reverse args)
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [list-sym " = listCons(" "(Value *)" arg-sym
                                          ", " list-sym ");" line-sep])))
                                "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
                               [] ListType {} (count args))]))))

(defn dispatch-type-known [target args ast]
  (let [num-args (count args)]
    (for [dispatch-val (sm/when (first args))
          impl-info (get-proto-impl target num-args (.type-num dispatch-val))
          arity-info (lookup-static-arity (.c-var impl-info) num-args)
          constraints (lookup-static-constraints (.c-var impl-info) num-args)
          exprs (traverse (for [[var arg constraints] (zip-lists (seq args)
                                                                 (.args ast)
                                                                 (seq constraints))
                                constraint (seq constraints)]
                            [constraint arg var])
                          (fn [[constraint arg var]]
                            (check-constraint constraint arg var
                                             (ast/file-name ast)
                                             (ast/line-number ast))))
          ;; _ (comp (sm/update-in-val [.other 'type-known-sites] inc)
          ;;         (sm/assoc-in-val [.other 'type-known-sites] 1))
          result-sym (genlocal "rslt")
          line (line-macro target (str "// type-known for " target))]
      (let [return-type (either (or (and (= (.type-num arity-info) UnknownType)
                                         ;; TODO: these should be the result of
                                         ;; asserts on the protocol fn defs
                                         (or (= target 'map)
                                             (= target 'rest)
                                             (= target 'assoc*))
                                         (maybe (.type-num dispatch-val))))
                                (.type-num arity-info))]
        (comp* (c-init "" [] [] UnknownType {})
               (comp args
                     exprs
                     [(c-init result-sym
                              [line "Value *" result-sym " = " (.c-var arity-info) "("
                               (interpose (conj (map args .c-var) "empty_list")
                                          ", ")
                               ");" line-sep]
                              []
                              return-type {})]))))))

(defn dispatch-type-unknown [target args ast]
  (let [num-args (count args)]
    (for [impls-info (get-protocol-dispatcher target num-args)
          :let [constraints (.param-constraints impls-info)]
          exprs (traverse (for [[var arg constraints] (zip-lists (seq args)
                                                                 (.args ast)
                                                                 (seq constraints))
                                constraint (seq constraints)]
                            [constraint arg var])
                          (fn [[constraint arg var]]
                            (check-constraint constraint arg var
                                             (ast/file-name ast)
                                             (ast/line-number ast))))
          ;; _ (comp (sm/when (or (= (ast/file-name target) 'core)))
          ;;         (sm/update-in-val [.other 'type-unknown-sites] inc)
          ;;         (sm/assoc-in-val [.other 'type-unknown-sites] 1))
          result-sym (genlocal "rslt")
          line (comp (map (sm/when (or (= (ast/file-name target) 'core)))
                          (fn [_] ""))
                     (line-macro target (str "// type-unknown " target)))]
      (comp* (c-init "" [] [] UnknownType {})
             (comp args
                   [(c-init result-sym
                            [line "Value *" result-sym " = proto" num-args "Arg(&"
                             (.impls-sym impls-info)
                             ", \"" (.sym target) "\", "
                             (interpose (comp (map args .c-var)
                                              [(str "\"" (.file-name target) "\"")
                                               (ast/line-number target)])
                                        ", ")
                             ");" line-sep]
                            []
                            (.return-type impls-info) {})])))))

(defn call-proto-impl [name args ast]
  (for [_ (sm/when (< 0 (count args)))
        call-info (comp (dispatch-type-known name args ast)
                        (dispatch-type-unknown name args ast))]
    call-info))

(defn inline-wrap-and-apply* [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (< 0 num-args)
                          (or (= name 'wrap)
                              (= name 'apply*))))
          :let [[dispatch-ast & arg-asts] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          expr (-> impl-ast
                   (replace-bound-vars {})
                   (inline-expr (cons dispatch-val arg-asts)))]
      expr)))


(defn inline-flat-map [name args]
  (let [num-args (count args)]
    (for [_ (sm/when (and (= 2 num-args)
                          (or (= name 'flat-map)
                              (= name 'map))))
          :let [[dispatch-ast f-ast] args]
          dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name num-args (.type-num dispatch-val))
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (traverse (.body impl-ast)
                               (fn [ast]
                                 (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(extend-type rdr/tagged-symbol
  Assertion
  (get-param-constraints [sym]
    (for [c-info (lookup-sym sym)
          constraints (get-constraints (.c-var c-info))]
      (map constraints (fn [constraint]
                         (update-sym constraint sym)))))

  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          constraints (get-constraints (.c-var evalled))
          :let [arg-var (str arg-var)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (set-constraints arg-var constraints)
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (new-module-def defined-sym value)]
      [(make-c-code value)]))

  (tail-call [ast params return-constraints]
    (TailCall ast params return-constraints))

  (emit-call-expr [target-ast args call-expr-ast]
    (comp (call-vector target-ast args)
          (call-list target-ast args)
          (call-proto-impl target-ast args call-expr-ast)))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type Symbol
  Assertion
  (get-param-constraints [sym]
    (for [c-info (lookup-sym sym)
          constraints (get-constraints (.c-var c-info))]
      (map constraints (fn [constraint]
                         (update-sym constraint sym)))))

  Emitter
  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (for [arg-var (genlocal binding "arg")
          constraints (get-constraints (.c-var evalled))
          :let [arg-var (str arg-var)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled)
                                    {(.c-var evalled) 1})]
          _ (set-constraints arg-var constraints)
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [evalled (c-init (.c-var evalled) [] []
                                             (.type-num evalled) {})]))))

  (emit [sym]
    (lookup-sym sym))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)]
      (comp (inline-wrap-and-apply* name args)
            (inline-flat-map name args))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          line-info (line-macro ast "// inline")]
      (c-code "" [line-info (.txt ast) "\n#\n"] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] [] type-num {}))
          line-info (line-macro ast "// inline")]
      [(c-code "" [] [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"]
               type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] type-num {})]))

  (tail-call [ast params return-constraints]
    ;; TODO: statically verify the return type, if possible
    ast)

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (traverse (.value-exprs ast) (fn [ast]
                                          (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] UnknownType {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              [(-> c-info
                   (.c-var "")
                   (.decl ["Value *" c-var ";\n"]))])))))


;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars ast]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        ;; _ (comp (sm/update-in-val [.other 'static-fixed-sites] inc)
        ;;         (sm/assoc-in-val [.other 'static-fixed-sites] 1))
        constraints (lookup-static-constraints (.c-var target) (count arg-vars))
        exprs (traverse (for [[var arg constraints] (zip-lists (seq arg-vars)
                                                               (seq (.args ast))
                                                               (seq constraints))
                              constraint (seq constraints)]
                          [constraint arg var])
                        (fn [[constraint arg var]]
                          (check-constraint constraint arg var
                                            (ast/file-name ast)
                                            (ast/line-number ast))))
        result-sym (genlocal "rslt")
        line (line-macro ast "// static-fixed")]
    (c-init result-sym
            [(map exprs .init)
             line "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq (map arg-vars .c-var))) ", ") ");" line-sep]
            [] (.type-num arity-info) {})))

(defn call-static-variadic [target args ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-info (lookup-static-arity (.c-var target) 'variadic)
          constraints (lookup-static-constraints (.c-var target) 'variadic)
          ;; _ (comp (sm/update-in-val [.other 'static-variadic-sites] inc)
          ;;         (sm/assoc-in-val [.other 'static-variadic-sites] 1))
          args-list (call-list (rdr/tag 'list file-name line-number)
                               (map args (fn [arg]
                                           (.init arg []))))
          args-cs (get-constraints (.c-var args-list))
          check-exprs (traverse (flat-map constraints seq)
                                (fn [constraint]
                                  (check-constraint constraint '_ args-list
                                                    file-name line-number)))
          result-sym (genlocal "rslt")
          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               (map check-exprs .init)
               line
               "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
               (.c-var args-list) ");" line-sep]
              []
              (.type-num arity-info)
              {}))))

(defn call-dyn-fn-value [target args ast]
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (.type-num target))
        ;; _ (comp (sm/update-in-val [.other 'dyn-fn-sites] inc)
        ;;         (sm/assoc-in-val [.other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              []
              UnknownType {}))))

(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type))
(def Function-sym (rdr/tag 'Function))
(def Stringable-sym (rdr/tag 'Stringable))
(def type-name-sym (rdr/tag 'type-name))
(def =*-sym (rdr/tag '=*))
(def get-type-sym (rdr/tag 'reified-get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def new-type-value-sym (rdr/tag 'new-type-value))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative))
(def get-symb (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode))
(def Hashable-sym (rdr/tag 'Hashable))
(def sha1-sym (rdr/tag 'sha1))
(def sha1-update-sym (rdr/tag 'sha1-update))
(def sha1-init-sym (rdr/tag 'sha1-init))
(def sha1-finalize-sym (rdr/tag 'sha1-finalize))
(def sha1-update-type-sym (rdr/tag 'sha1-update-type))
(def assoc*-sym (rdr/tag 'assoc*))
(def make-value-sym (rdr/tag 'make-value))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  (let [num-args (count args)
        num-invoke-args (inc num-args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (map (lookup-core-fn-arity invoke-sym num-invoke-args)
                                .c-var)
          impls-sym (get-proto-impls-sym invoke-sym num-invoke-args)
          ;; _ (comp (sm/update-in-val [.other 'dyn-unknown-sites] inc)
          ;;         (sm/assoc-in-val [.other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                 "FnArity *_arity = (FnArity *)findProtoImpl(" (.c-var target)
                 "->type, &" impls-sym ");" line-sep
                 "if(_arity == (FnArity *)0) {" line-sep
                 "fprintf(stderr, \"\\n*** No implementation of 'invoke' with "
                 (str num-invoke-args) " arguments for type: %s (%\" PRId64 \") at "
                 (ast/file-name ast) ": " (str (ast/line-number ast)) "\\n\"," line-sep
                 "extractStr(type_name(empty_list, " (.c-var target) ")), " (.c-var target)
                 "->type);" line-sep
                 "abort();" line-sep
                 "}" line-sep
                 "FnType" num-invoke-args " *_fn = (FnType" num-invoke-args
                 " *)_arity->fn;" line-sep

                 result-sym " = _fn(_arity->closures, "
                 (to-str (interpose (conj args (.c-var target)) ", "))
                 ");" line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                 line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                [] UnknownType {})))))

(defn call-invoke [target arg-vars ast]
  (let [num-args (inc (count arg-vars))]
    (for [invoke-info (get-proto-impl invoke-sym num-args (.type-num target))
          arity-info (lookup-static-arity (.c-var invoke-info) num-args)
          ;; _ (comp (sm/update-in-val [.other 'invoke-sites] inc)
          ;;         (sm/assoc-in-val [.other 'invoke-sites] 1))
          constraints (lookup-static-constraints (.c-var invoke-info) num-args)
          exprs (traverse (for [[var arg constraints] (zip-lists (seq arg-vars)
                                                                 (.args ast)
                                                                 (rest (seq constraints)))
                                constraint (seq constraints)]
                            [constraint arg var])
                          (fn [[constraint arg var]]
                            (check-constraint constraint arg var
                                             (ast/file-name ast)
                                             (ast/line-number ast))))
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [(map exprs .init)
               line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (conj (cons (.c-var target) (map arg-vars .c-var))
                                "empty_list") ", ") ");" line-sep]
              []
              (.type-num arity-info)
              {}))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (filter produces-code?)
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse
                vec))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    ((instance? Symbol target-ast)
                                     (rdr/tag target-ast)
                                     target-ast))))]
      (comp (for [new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.type-num call-site) (.refs-map call-site)))
            (for [args (-> (.args ast)
                           (filter produces-code?)
                           emit)
                  ;; TODO: turn into a 'flat-map'
                  call-site (comp (emit-call-expr (.call-target ast) args ast)
                                  (for [target (emit (.call-target ast))
                                        call-site (comp
                                                   (call-static-fixed target args ast)
                                                   (call-static-variadic target args ast)
                                                   (call-invoke target args ast)
                                                   (call-dyn-fn-value target (map args .c-var) ast)
                                                   (call-dyn-unknown-type target (map args .c-var)
                                                                          ast))]
                                    (comp* (c-init "" [] [] UnknownType {})
                                           (comp args [target call-site])))
                                  (compilation-error "Could not compile call site at:"
                                                     file-name line-number))]
              call-site))))

  (emit-defined-value [fn-val defined-sym]
    (comp (for [[type-sym type-syms] (sm/when (and (= (.call-target fn-val) 'comp*)
                                                   (maybe (.args fn-val))))
                type-nums (get-type-numbers (maybe type-sym))
                :when-not (empty? type-nums)
                other-type-nums (traverse (.args type-syms)
                                          (fn [sym]
                                            (for [type-nums (get-type-numbers (maybe sym))
                                                  _ (sm/when-not (empty? type-nums))]
                                              type-nums)))
                :let [all-type-nums (comp* type-nums other-type-nums)]
                _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                                   all-type-nums)
                expr (emit-defined-value
                      (ast/reified
                       (extract rdr/type-counter)
                       {Type-sym
                        [[instance?-sym
                          [(ast/fn-arity-ast
                            (str defined-sym "_instance_QMARK_") ""
                            (ast/params ['x 'y]) "" []
                            [(ast/call-ast (rdr/tag 'some)
                                           [(ast/call-ast list-sym (vec all-type-nums))
                                            (ast/call-ast (rdr/tag 'partial)
                                                          [=*-sym
                                                           (ast/call-ast get-type-sym ['y])])])])]]]})
                      defined-sym)]
            expr)
          (for [init-fn-context (sm/new-sm (fn [s]
                                             (assert (instance? GlobalContext s))
                                             (-> s
                                                 .init
                                                 .fn-context
                                                 (vector s)
                                                 maybe)))
                fn-context (reset-fn-context init-fn-context)
                value (emit fn-val)
                var (comp (map (lookup-declaration defined-sym) .c-var)
                          (global-var defined-sym "var"))
                init-fn-context (reset-fn-context fn-context)
                _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
                _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
            [(c-init var [(.init value)
                          var " = " (.c-var value) ";" line-sep
                          var "->refs = -1;" line-sep "\n#\n"]
                     [(.decl value) "Value *" var ";\n"]
                     (.type-num value) (.refs-map value))])))

  (tail-call [ast params return-constraints]
    (TailCall ast params return-constraints))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (traverse (.args ast) (fn [ast]
                                       (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= (.call-target ast) 'new-sm))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))

  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defn unpack-arg-list [list-var elem-vars file-name line-num]
  (let [elem-count (count elem-vars)]
    (comp (sm/when (for [elem (first elem-vars)
                         :when (= 1 (count elem-vars))
                         var (first (.vars elem))]
                     (ParamBinding [(.c-var list-var)]
                                   [(c-init var ["Value *" var " = (Value *)" (.c-var list-var) ";" line-sep]
                                            [] ListType {})])))
          (for [dest-args (genlocal "destArgs")
                check-expr (check-constraint (MinCountConstraint (dec elem-count)
                                                                 empty-list nothing)
                                            '_ list-var file-name line-num)
                :let [elem-c-vars (flat-map elem-vars .vars)
                      tail-var (extract (last elem-c-vars))
                      elem-exprs (map elem-c-vars (fn [var]
                                                    (c-init var [] []
                                                            ((= var tail-var) ListType UnknownType)
                                                            {})))]
                _ (traverse elem-exprs (fn [expr]
                                         (set-sym (.c-var expr) expr)))]
            (ParamBinding [(.c-var list-var)]
                          (comp [check-expr
                                 (c-code ""
                                         [(map elem-c-vars (fn [var]
                                                             ["Value *" var ";" line-sep]))
                                          "Value **" dest-args "[" elem-count "] = {"
                                          (interpose (map elem-c-vars (fn [arg] ["&" arg])) ", ")
                                          "};" line-sep "destructValue(\"" file-name "\", \"" line-num
                                          "\", (Value *)" (.c-var list-var) ", " elem-count ", "
                                          dest-args ");" line-sep]
                                         [] UnknownType {(.c-var list-var) 1})]
                                elem-exprs
                                (flat-map elem-vars .destruct)))))))

(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? Vector l))
    [ast]))

(extend-type ast/params-ast
  Assertion
  (get-param-constraints [params]
    (traverse (.fixed params) get-param-constraints))

  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  Emitter
  (bind [params]
    (for [fixed-vars (map (traverse (.fixed params) bind) vec)
          tail-var (bind (either (.variadic params)
                                 (rdr/tag "#tail")))
          param-var (genlocal "arg")
          destruct (unpack-arg-list (c-code param-var [] [] UnknownType {})
                                    (conj fixed-vars tail-var)
                                    (ast/file-name params)
                                    (ast/line-number params))]
      destruct))

  (bind [params evalled]
    (let [tail-sym (either (.variadic params)
                           (rdr/tag "#tail"))]
      (for [fixed-vars (map (traverse (.fixed params) bind) vec)
            tail-var (bind tail-sym)
            destruct (unpack-arg-list evalled (conj fixed-vars tail-var)
                                      (ast/file-name params) (ast/line-number params))
            _ (comp (sm/when (empty? (.init evalled)))
                    (set-sym (.c-var evalled) evalled))
            _ (set-type tail-sym ListType)]
        (either (and (empty? (.init evalled))
                     (empty? (.decl evalled))
                     (maybe (.vars destruct [(.c-var evalled)])))
                (-> destruct
                    (.vars [(.c-var evalled)])
                    (.destruct (comp [evalled] (.destruct destruct))))))))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (for [val-var (emit (.val ast))
          bound-var (bind (.binding ast) val-var)]
      bound-var)))

(defn merge-constraints [c1 c2]
  (comp c1 c2))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals get-syms
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          params get-params
          bound-syms get-syms
          _ (traverse (seq bound-syms)
                      (fn [[sym expr]]
                        (comp (sm/when (or (get params (.c-var expr))
                                           (flat-map (get locals sym)
                                                     (fn [lcl]
                                                       (= (.c-var lcl)
                                                          (.c-var expr))))))
                              (for [cs get-all-constraints
                                    _ (set-all-constraints (dissoc cs (.c-var expr)))]
                                '_))))
          _ (set-syms locals)]
      (let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
        (c-init (.c-var code) (.init code) (.decl code) (.type-num code) (.refs-map code)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .init
                                           .fn-context
                                           (vector s)
                                           maybe)))
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))]))

  (tail-call [ast params return-constraints]
    (.body ast (-> ast
                   .body
                   (tail-call params return-constraints))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (sm/state-maybe new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (rdr/tag (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body))))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = "
               (count impl-fns) ";" line-sep
               "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (map impl-fns .decl)
              type-num
              (apply merge-with + (map impl-fns .refs-map))))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-code reified-ptr
            []
            [(map impl-fns .decl)
             "ReifiedVal " reified-sym " = {"
             type-num ", -1, (Value *)0, 0, {}};" line-sep
             "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
            type-num {})))

(defprotocol ArityType
  (closure-arity? [_]
    (assert-result x (instance? Maybe x))
    nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (assert-result x (instance? sm/new-sm x))))

(deftype StaticArity [arity-fn-var param-count return-type var-info param-constraints]
  (assert (instance? String arity-fn-var))
  ;; TODO
  ;; (assert (instance? (Integer or 'variadic) param-count))
  (assert (instance? Integer return-type))
  (assert (instance? C-expr var-info))
  (assert (instance? Sequence param-constraints))

  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " "
                (target-type-name return-type) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (for [_ (new-proto-impl fn-name param-count dispatch-type-num var-info arity-ast)
          _ (new-static-arity (.c-var var-info) param-count arity-fn-var return-type
                              param-constraints)]
      var-info)))

(deftype ClosureArity [arity-fn-var params var-info]
  (assert (instance? String arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))

  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl fn-name param-count dispatch-type-num
                              (c-code (str "&" fn-arity-sym) [] [] FunctionType {}) arity-ast)
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                                  ")->impls["
                                  reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};" line-sep]
                                 UnknownType {})]
          (comp reified-fn var-info))))))

(defn bind-params [params fn-var arity-fn-var]
  (comp (for [tail (sm/when (.variadic params))
              non-params get-syms
              fixed-vars (map (traverse (.fixed params) bind) vec)
              tail-var (bind tail)
              syms get-syms
              _ (set-params (-> (keys non-params)
                                (reduce syms dissoc)
                                (seq)
                                (reduce {} (fn [params [_ var]]
                                             (assoc params (.c-var var) 1)))))
              _ (sm/assoc-in-val [.fn-context .syms tail .type-num] ListType)
              param-var (genlocal "arg")
              destruct (unpack-arg-list (c-code param-var [] [] UnknownType {})
                                        (conj fixed-vars tail-var)
                                        (ast/file-name params)
                                        (ast/line-number params))]
          destruct)
        (for [non-params get-syms
              vars (traverse (.fixed params) bind)
              :when-not (empty? vars)
              syms get-syms
              _ (set-params (-> (keys non-params)
                                (reduce syms dissoc)
                                (seq)
                                (reduce {} (fn [params [_ var]]
                                             (assoc params (.c-var var) 1)))))
              _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] arity-fn-var)]
          (let [[var & vars] vars
                param-vars (comp* var vars)
                param-destruct (comp (map (.vars param-vars)
                                                  (fn [var]
                                                    (c-init var [] [] UnknownType {})))
                                             (.destruct param-vars))]
            (ParamBinding (.vars param-vars) param-destruct)))
        (for [_ (sm/assoc-in-val [.fn-context .recurse fn-var 0] arity-fn-var)
              _ (set-params {})]
          (ParamBinding [] []))))

(defn emit-closure-arity [fn-sym fn-context arity-fn-var params param-vars body-exprs]
  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [closures (sm/new-sm (fn [s]
                                (assert (instance? GlobalContext s))
                                (-> s
                                    .fn-context
                                    .closed-over
                                    .closures
                                    (vector s)
                                    maybe)))
          :when-not (empty? closures)
          destArgs (genlocal "destArgs")
          new-constraints get-all-constraints
          ;; TODO: what about constraints for the variadic vars
          param-constraints (get-param-constraints params)
          _ (reset-fn-context)
          check-params (traverse (for [[constraints arg var] (zip-lists param-constraints
                                                                        (.fixed params)
                                                                        (.destruct param-vars))
                                       constraint (seq constraints)]
                                   [constraint arg var])
                                 (fn [[constraint arg var]]
                                   (check-constraint constraint arg var file-name line-number)))
          _ (reset-fn-context fn-context)
          arity-var (genlocal fn-sym "dynArity")
          _ (traverse closures
                      (fn [[var sym]]
                        (traverse (seq (either (get new-constraints var)
                                               #{}))
                                  (fn [constraint]
                                    (constrain-symbol constraint sym)))))
          closure-vars (traverse closures (fn [[_ sym]] (lookup-sym sym)))]
      (let [closures (-> closures
                         (map (fn [[arg]] arg))
                         (seq)
                         (conj "closuresTail")
                         (reverse))
            closure-count (count closures)
            destruct-closures (cons (c-code ""
                                            [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                                             "incRef((Value *)closures, 1);" line-sep
                                             "Value **" destArgs "[" closure-count "] = {"
                                             (interpose (map closures (fn [arg] ["&" arg])) ", ")
                                             "};" line-sep
                                             "destructValue(\"\", \"\", (Value *)closures"
                                             ", " closure-count ", " destArgs ");" line-sep]
                                            []
                                            UnknownType {})
                                    (map closures (fn [arg] (c-init arg [] [] UnknownType {}))))
            body (collapse-expressions (comp (.destruct param-vars)
                                             destruct-closures
                                             body-exprs))
            arity-decl [(.decl body)
                        "Value *" arity-fn-var "("
                        (-> (.vars param-vars)
                            (map (fn [param] (str "Value *" param)))
                            (seq)
                            (conj "List *closures")
                            (interpose ", "))
                        ") {\n"
                        (map check-params .init)
                        "\nwhile (1) {\n"
                        (.init body)
                        line-sep "};};\n"]
            arity-init ["FnArity *" arity-var
                        " = malloc_fnArity();" line-sep

                        arity-var "->count = " (count (.vars param-vars))
                        ";" line-sep
                        arity-var "->variadic = "
                        ((.variadic params) "1" "0") ";" line-sep
                        arity-var "->fn = " arity-fn-var ";" line-sep
                        arity-var "->closures = empty_list;" line-sep]]
        (ClosureArity arity-fn-var params
                      (comp* (c-init arity-var arity-init arity-decl FnArityType {})
                             (map closure-vars (fn [closure]
                                                 (c-code arity-var
                                                         [arity-var "->closures = listCons((Value *)"
                                                          (.c-var closure) ", (List *)" arity-var
                                                          "->closures);" line-sep]
                                                         [] ListType {(.c-var closure) 1})))))))))

(defn emit-static-arity [fn-sym fn-context arity-fn-var params param-vars param-types body-exprs]
  ;; TODO: remove the 'param-types' parameter
  (let [arity-index ((.variadic params) 'variadic (count params))
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    ;; TODO: what about constraints for the variadic vars
    (for [param-constraints (get-param-constraints params)
          _ (reset-fn-context)
          check-params (traverse (for [[constraints arg var] (zip-lists param-constraints
                                                                        (.fixed params)
                                                                        (.destruct param-vars))
                                       constraint (seq constraints)]
                                   [constraint arg var])
                                 (fn [[constraint arg var]]
                                   (check-constraint constraint arg var file-name line-number)))
          _ (reset-fn-context fn-context)
          checking-fn-var (global-var fn-sym "paramChecker")
          arity-var (comp (for [dispatch-type (sm/when (first param-types))
                                proto-impl (get-proto-impl fn-sym arity-index dispatch-type)]
                            (.c-var proto-impl))
                          (global-var fn-sym "staticArity"))]
      (let [fn-var (either (or (and (.variadic params)
                                    (maybe checking-fn-var))
                               (and (every param-constraints empty?)
                                       (maybe arity-fn-var)))
                           checking-fn-var)
            body (collapse-expressions (comp (.destruct param-vars) body-exprs))
            arity-decl [(.decl body)
                        "Value *" arity-fn-var "("
                        (-> (.vars param-vars)
                            (map (fn [param] (str "Value *" param)))
                            (seq)
                            (conj "List *closures")
                            (interpose ", "))
                        ") {\nwhile (1) {\n"
                        (.init body)
                        line-sep "};};\n"]
            checking-fn (either (or (and (.variadic params)
                                         (maybe ["Value *" checking-fn-var
                                                 "(List *closures, Value *args) {\n"
                                                 "if (countSeq(incRef(args, 1)) < "
                                                 (str (count params)) ") {"
                                                 "\n#ifndef EMBEDDED\n"
                                                 "fprintf(stderr, \"Insufficient variadic args for "
                                                 (str "'" fn-sym "'") " at " file-name " line:"
                                                 (str line-number) "\\n\");\n"
                                                 "fprintf(stderr, \"Needed " (str (count params))
                                                 ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, args))->numVal);\n"
                                                 "#endif\n"
                                                 "abort();" line-sep
                                                 "}" line-sep
                                                 ;; (map check-params .init)
                                                 "return(" arity-fn-var
                                                 "(closures, args));\n};\n"]))
                                    (and (every param-constraints empty?)
                                         (maybe [])))
                                ["Value *" checking-fn-var "("
                                 (-> (.vars param-vars)
                                     (map (fn [param] (str "Value *" param)))
                                     (seq)
                                     (conj "List *closures")
                                     (interpose ", "))
                                 ") {\n"
                                 (map check-params .init)
                                 "return(" arity-fn-var "("
                                 (-> (.vars param-vars)
                                     (seq)
                                     (conj "closures")
                                     (interpose ", "))
                                 "));\n};\n"])]
        (do
          ;; TODO: use this to eliminate unknown return type values
          ;; (and (= UnknownType (.type-num body))
          ;;      (maybe (print-err 'unknown-return-type fn-sym
          ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
          (let [param-constraints (either (and (.variadic params)
                                       (maybe [#{(MinCountConstraint (count params)
                                                                     (list [file-name line-number])
                                                                     nothing)}]))
                                          param-constraints)]
            (StaticArity arity-fn-var arity-index (.type-num body)
                         (c-code (str "&" arity-var) []
                                 [arity-decl
                                  checking-fn
                                  "FnArity " arity-var " = {FnArityType, -1, "
                                  (count (.vars param-vars))
                                  ", (List *)0, " ((.variadic params) "1" "0")
                                  ", " fn-var "};" line-sep]
                                 FnArityType {})
                         param-constraints)))))))

(defn emit-fn-arity
  ([fn-sym fn-var params param-types body]
   ;; TODO: this should be redundant
   ;; (assert (instance? String fn-var))
   (flat-map (global-var fn-sym "arityImpl")
             (fn [arity-fn-var]
               (emit-fn-arity fn-sym fn-var params param-types body
                              (str arity-fn-var)))))

  ([fn-sym fn-var params param-types body arity-fn-var]
   ;; TODO: this should be redundant
   ;; (assert (instance? String fn-var))

   ;; TODO
   ;; (assert (min-count body 1))
   (assert (instance? String arity-fn-var))

   (either (and (empty? (filter body produces-code?))
                (maybe (zero sm/state-maybe)))
           (let [return-constraints (filter body return-assertion?)
                 return-types (reduce body empty-list
                                      (fn [asserted-types assertion]
                                        (either (map (assert-return-type assertion)
                                                     (fn [type-sym]
                                                       (conj asserted-types type-sym)))
                                                asserted-types)))]
             (for [fn-context (reset-fn-context)
                   _ (comp (sm/when (or (empty? return-types)
                                        (apply = return-types)))
                           (compilation-error "Conflicting result assertions in:"
                                              fn-sym "at:" (ast/file-name body)
                                              (ast/line-number body)
                                              (to-str (flat-map return-constraints
                                                                (fn [a]
                                                                  ["\n" (ast/file-name a)
                                                                   " " (ast/line-number a)])))))
                   _ (comp (get-sym fn-sym)
                           (set-sym fn-sym (c-code fn-var [] [] FunctionType {})))
                   param-vars (bind-params params fn-var arity-fn-var)
                   :let [param-vars (either (and (some body (partial instance? ast/inline-ast))
                                                 (maybe (.destruct param-vars [])))
                                            param-vars)]
                   _ (traverse (zip-lists (seq (.fixed params)) (seq param-types))
                               (fn [[var type-num]] (set-type var type-num)))
                   _ (-> body
                         (remove produces-code?)
                         (remove return-assertion?)
                         emit)
                   body-exprs (-> body
                                  (tail-call (.vars param-vars) return-constraints)
                                  emit)
                   arity-info (comp (emit-closure-arity fn-sym fn-context arity-fn-var params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context arity-fn-var params
                                                       param-vars param-types body-exprs))]
               arity-info)))))

(defn validate-protocol-names [ast]
  (traverse (keys (.impls ast))
            (fn [protocol-name]
              (comp (get-protocol protocol-name)
                    (compilation-error "Invalid protocol:" protocol-name "in"
                                       (str (ast/file-name ast) ",")
                                       (ast/line-number protocol-name))))))

(defn validate-proto-fn-name [fn-name arg-count]
  (comp (get-protocol-dispatcher fn-name arg-count)
        (compilation-error "Invalid protocol fn:"
                           (str "'" fn-name "' in")
                           (str (ast/file-name fn-name) ",")
                           (ast/line-number fn-name))))

(deftype ProtoImplDeclaration [fn-name arity-ast arity-impl-var c-decl]
  (assert (instance? Tagged fn-name))
  (assert (instance? String arity-impl-var))
  (assert (instance? ast/fn-arity-ast arity-ast))
  (assert (instance? Vector c-decl)))

(defn declare-impl [type-str type-num [fn-name arity-ast]]
  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (map (global-var (str type-str fn-name) "arityImpl") str)
          dispatcher-info (validate-proto-fn-name fn-name num-args)
          _ (new-proto-impl fn-name num-args type-num
                            (c-code impl-fn-var [] [] (.return-type dispatcher-info) {})
                            arity-ast)
          _ (new-static-arity impl-fn-var num-args arity-impl-var (.return-type dispatcher-info))]
      (ProtoImplDeclaration fn-name arity-ast arity-impl-var
                            ["Value *" arity-impl-var "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"]))))

(defn emit-impl [type-str type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))
  (let [[fn-name arity-ast arity-var] (type-args impl-decl)
        params (.params arity-ast)
        num-args (count params)]
    (for [dispatcher-info (validate-proto-fn-name fn-name num-args)
          ;; _ (debug 'fn-name type-str fn-name
          ;;          (ast/file-name fn-name) (ast/line-number fn-name))
          :let [param-constraints (.param-constraints dispatcher-info)
                assertions (for [[param constraints] (zip-lists (.fixed params)
                                                                param-constraints)
                                 constraint (seq constraints)]
                             (to-assertion constraint param))]
          ext-fn (comp (emit-fn-arity (rdr/tag (str type-str fn-name))
                                      (.fn-var arity-ast)
                                      params [type-num]
                                      (comp assertions
                                            (.return-constraints dispatcher-info)
                                            (.body arity-ast))
                                      arity-var)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-name "' in")
                                          (str (ast/file-name fn-name) ",")
                                          (ast/line-number fn-name)))
          reified (reify-arity ext-fn type-num arity-ast fn-name)
          ;; _ (debug "---------")
          ]
      reified)))

(defn extend-type* [ast type-num]
  (let [impl-arities (for [impl-fns (vals (.impls ast))
                            [fn-name arities] (seq impl-fns)
                            impl-arity arities]
                       [fn-name impl-arity])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (sm/state-maybe (str "_" type-num "_")))
                _ (validate-protocol-names ast)
                impl-arities (traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns)
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .init
                                           .fn-context
                                           (vector s)
                                           maybe)))
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-code (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                     (.c-var value) ";" line-sep]
                                     (.decl value) (.type-num value) (.refs-map value))))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] (.type-num value) {}))]
      [value]))

  (tail-call [ast params return-constraints]
    (TailCall ast params return-constraints)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defn cond-clause-init [cond-test result-var [init refs-map] [clause constraints]]
  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs)
                     (filter-vals (partial < 0)))]
    [(conj (vec init)
           [(.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            cond-test result-var ",\"\",0)) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  ["dec_and_free(" c-sym ", " remaining ");" line-sep]))])
     refs-map]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits] (reduce (butlast evalled-clauses)
                               [[] refs-map]
                               (partial cond-clause-init cond-test result-var))]
    clause-inits))

;; TODO move this to Emitter
(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (map (emit clause)
           (fn [expr]
             (either (and (or (= (.type-num expr) MaybeType)
                              (= "" (.c-var expr)))
                          (maybe expr))
                     (.init expr [(.init expr)
                                  "if (" (.c-var expr) "->type != MaybeType) {" line-sep
                                  "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
                                  file-name "\","
                                  (ast/line-number clause)
                                  ");" line-sep
                                  "fprintf(stderr, \"Expected Maybe, got %s\\n\", extractStr(type_name(empty_list, "
                                  (.c-var expr) ")));" line-sep
                                  "abort();" line-sep
                                  "}" line-sep])))))))

(extend-type rdr/tagged-symbol
  EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (for [_ (constrain-symbol (TypeConstraint #{MaybeType}
                                                (list [(str file-name ":")
                                                       (ast/line-number clause)])
                                                'Maybe
                                                (maybe clause))
                                clause)
            expr (emit clause)]
        expr))))

(extend-type Symbol
  EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (for [_ (constrain-symbol (TypeConstraint #{MaybeType}
                                                (list [(str file-name ":")
                                                       (ast/line-number clause)])
                                                'Maybe
                                                (maybe clause))
                                clause)
            expr (emit clause)]
        expr))))

(defn diff-constraints [new old]
  (reduce (seq new) {}
          (fn [diff [var constraints]]
            (either (flat-map (get old var)
                              (fn [old-constraints]
                                (let [constraint-diff (difference constraints old-constraints)]
                                  (or (and (empty? constraint-diff)
                                           (maybe diff))
                                      (maybe (assoc diff var constraint-diff))))))
                    (assoc diff var constraints)))))

(defn intersect-constraints [a b]
  (reduce (seq a) {}
          (fn [inter [var a-consts]]
            (either (flat-map (get b var)
                              (fn [b-consts]
                                (let [ab-consts (intersection a-consts b-consts)]
                                  (or (and (empty? ab-consts)
                                           (maybe inter))
                                      (maybe (assoc inter var ab-consts))))))
                    inter))))

(defn clause-refs [exprs]
  (let [clause-vars (-> exprs
                        (remove (fn [c] (empty? (.init c))))
                        (map .c-var)
                        set)
        refs-maps (map exprs .refs-map)]
    (-> (apply merge-with + refs-maps)
        (remove-keys clause-vars)
        (filter-vals (partial < 0)))))

(defn last-init [evalled-clauses result-var]
  (let [[last-clause last-constraints] (either (last evalled-clauses)
                                               (do
                                                 (print-err "Booom!!!")
                                                 (abort)))]
    ((= "" (.c-var last-clause))
     (.init last-clause)
     [(.init last-clause)
      result-var " = " (.c-var last-clause) ";" line-sep])))

(defn add-runtime-constraints [constraints]
  (for [[var const-set] (seq constraints)
        constraint (seq const-set)]
    (runtime-check constraint var "" 0)))

(defn emit-cond-expr [cond-test result-var clauses tail-return]
  (for [initial-constraints get-all-constraints
        evalled-clauses (-> clauses
                            (filter produces-code?)
                            (traverse (fn [clause]
                                        (for [curr-constraints get-all-constraints
                                              expr (emit-cond-clause clause)
                                              new-constraints get-all-constraints]
                                          [expr (diff-constraints new-constraints
                                                                  curr-constraints)]))))
        :let [[[first-clause first-constraints] & evalled-clauses] evalled-clauses]
        _ (set-all-constraints (merge-with union initial-constraints
                                           first-constraints))]
    (let [evalled-clauses (map evalled-clauses
                               (fn [[expr constraints]]
                                 [(.init expr [(add-runtime-constraints constraints)
                                               (.init expr)])
                                  constraints]))
          evalled-clauses (cons [first-clause {}] evalled-clauses)
          refs-map (-> evalled-clauses
                       (map (fn [[c]] c))
                       clause-refs)
          clause-count (dec (count evalled-clauses))]
      (c-init result-var
              ["Value *" result-var ";" line-sep
               (-> evalled-clauses
                   (clause-inits cond-test refs-map result-var)
                   (conj (last-init evalled-clauses result-var))
                   (interpose [tail-return "} else {" line-sep
                               "dec_and_free(" result-var ", 1);" line-sep]))
               (repeat clause-count (str "}" line-sep))]
              (map evalled-clauses (fn [[c]] (.decl c)))
              MaybeType refs-map))))

(deftype TailAnd [clauses]
  (assert (instance? List clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr "if (isNothing(" result-var
                               (.clauses ast) (str "return(nothing);" line-sep))]
      expr)))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr "if (isNothing(" result-var (.clauses ast) "")]
      expr))

  (tail-call [ast params return-constraints]
    (let [[last-clause & clauses] (reverse (seq (.clauses ast)))]
      (TailAnd (-> (tail-call last-clause params return-constraints)
                   (cons clauses)
                   reverse))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast (vec new-clauses))))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr "if (!isNothing(" result-var (.clauses ast)
                               (str "return(" result-var ");" line-sep))]
      expr)))

(def TailExpr (comp TailCall
                    TailAnd
                    TailOr))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (flat-map (genlocal "orRslt")
              (fn [result-var]
                (emit-cond-expr "if (!isNothing(" result-var (.clauses ast) line-sep))))

  (tail-call [ast params return-constraints]
    (let [clauses (.clauses ast)]
      (TailOr (either (flat-map (last clauses)
                                (fn [last-clause]
                                  (store clauses (dec (count clauses))
                                         (tail-call last-clause params return-constraints))))
                      []))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs))))))

(deftype TailEither [clause alt return-constraints]
  (assert (instance? Sequence return-constraints))

  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (for [cond-val (emit clause)
          alt-val (emit alt)
          result-var (genlocal "rslt")
          type-num (get-type-number (some return-constraints assert-return-type))
          cond-check (emit-return-constraints (c-code result-var [] [] UnknownType {})
                                              return-constraints)
          alt-val (comp (emit-tail-expr clause
                                        (ast/file-name ast)
                                        (ast/line-number ast)
                                        return-constraints
                                        alt-val)
                        (compilation-error "Could not emit code for 'either' expression at"
                                           (str (ast/file-name clause) ":")
                                           (ast/line-number clause)))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map cond-check .init)
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                type-num
                refs-map)))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          ;; TODO: make sure cond-val is a Maybe type in a way that propagates out
          cond-val (emit (.clause ast))
          alt-val (emit (.alt ast))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val)
                                     (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 (-> (.refs-map alt-val)
                     (filter-vals (partial < 0))
                     seq
                     (map (fn [[var refs]]
                            ["dec_and_free(" var ", " refs ");" line-sep])))
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                UnknownType
                refs-map))))

  (tail-call [ast params return-constraints]
    (TailEither (.clause ast) (.alt ast) return-constraints))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs))))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug 'main-fn)
          fn-arity (emit-fn-arity (rdr/tag 'main) "" (.params ast) [ListType] (.body ast))
          ;; _ (debug "=======")
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [params (.params prototype)
        num-args (count params)
        body (.default-body prototype)
        type-symbol (some body assert-return-type)
        return-constraints (filter body return-assertion?)
        assertions (filter body assertion?)]
    (for [curr-context (reset-fn-context)
          _ (bind-params params "" "")
          _ (emit assertions)
          constraints (traverse (.fixed params)
                                (fn [sym]
                                  (for [var (map (lookup-sym sym) .c-var)
                                        cs (get-constraints var)]
                                    cs)))
          _ (reset-fn-context curr-context)
          arity-fn-var (global-var fn-name "protoDisp")
          impls-sym (global-var (str fn-name "_Implementations") "protoImpls")
          return-type (get-type-number type-symbol)
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym
                                  return-type return-constraints constraints)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var return-type)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    ;; TODO: remove 'when-not'
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-fn-arity (rdr/tag (str "Default_" fn-name)) ""
                                            (.params prototype) [] default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.var-info static-arity) default-body)]
            (.decl (.var-info static-arity)))
          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (global-var fn-name "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] FunctionType {}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities
                                   (partial declare-proto-dispatch-arity fn-name
                                            dispatch-fn-sym))
        default-fns (traverse arities (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map)
                           (partial create-dispatcher proto-name))]
        [(c-code "" [] decl UnknownType {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    ;; TODO: remove the '.param-types' field
    (emit-fn-arity (either (and (= "" (.fn-sym ast))
                                (maybe (rdr/tag 'anon)))
                           (.fn-sym ast))
                   (.fn-var ast) (.params ast) (.param-types ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (sm/state-maybe (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (rdr/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (traverse arities
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.arity-fn-var static-arity)
                                                              (.return-type static-arity)
                                                              (.param-constraints static-arity))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              FunctionType {}))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-code fn-var
              [(map emitted-arities .init)
               line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
               struct-var "->name = \"" fn-sym "\";" line-sep
               struct-var "->arityCount = " arity-count ";" line-sep
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";" line-sep)))
               "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
              [(map emitted-arities .decl)]
              FunctionType
              (apply merge-with + (map emitted-arities .refs-map))))))

(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                arities (emit (map (.arities ast) (fn [arity]
                                                    (-> arity
                                                        (.fn-sym fn-sym)
                                                        (.fn-var fn-var)))))
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                arities (emit (.arities ast))
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] FunctionType {}))]
      [(make-c-code value)]))

  (tail-call [x params return-constraints]
    (TailCall x params return-constraints))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (traverse (.arities ast)
                                (fn [arity]
                                  (replace-syms arity subs)))]
      (.arities ast (vec new-arities))))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [ns-path (sym-ns-path (.type ast))
                  type-nums (get-type-numbers (maybe type-sym))
                  fns (map (traverse (seq type-nums) (partial extend-type* ast))
                           flatten)]
              fns)
            (compilation-error "Trying to extend unknown type: "
                               type-sym "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(deftype sym-type-ast [sym type-num]
  (assert (instance? Tagged sym))
  (assert (instance? Integer type-num))

  Stringable
  (string-list [_]
    (list "<FieldType " (str sym) " " (str type-num) ">"))

  Emitter
  (replace-syms [ast subs]
    (sm/state-maybe (sym-type-ast (either (get subs sym)
                                          sym)
                                  type-num)))

  (emit [_]
    (set-type sym type-num)))

(deftype expr-type-ast [type-sym ast]
  (assert (instance? Tagged type-sym))

  Stringable
  (string-list [_]
    (list "<ExprType " (str type-sym) " " (str ast) ">"))

  Emitter
  (tail-call [_ params return-constraints]
    (expr-type-ast type-sym (tail-call ast params return-constraints)))

  (emit [_]
    (for [type-num (get-type-number (maybe type-sym))
          expr (emit ast)]
      (.type-num expr type-num))))

(defn constructor-expr [new-type-name type-val-sym fields assertions]
  (ast/definition new-type-name
    [(ast/reified (extract rdr/type-counter)
                  {Type-sym
                   [[type-name-sym
                     [(ast/fn-arity-ast (str new-type-name "_const_type_name") ""
                                        (ast/params ['_]) "" []
                                        [(str "*" new-type-name " constructor*")])]]
                    [instance?-sym
                     [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") ""
                                        (ast/params ['x 'y]) "" []
                                        [(ast/call-ast =*-sym
                                                       [(ast/call-ast get-type-sym [type-val-sym])
                                                        (ast/call-ast get-type-sym ['y])])])]]]

                   Function-sym
                   [[invoke-sym
                     [(ast/fn-arity-ast (str new-type-name "_invoke") ""
                                        (ast/params (vec (cons '_ (seq fields)))) "" []
                                        (comp assertions
                                              [(expr-type-ast
                                                new-type-name
                                                (ast/call-ast new-type-value-sym
                                                              [type-val-sym
                                                               (ast/call-ast 'vector
                                                                             (vec fields))]))]))]]]

                   Stringable-sym
                   [[string-list-sym
                     [(ast/fn-arity (ast/params ['z]) ""
                                    [(ast/call-ast list-sym
                                                   ["<TypeCon " (str new-type-name) " ["
                                                    (to-str (interpose fields ", ")) "]>"])])]]]})]))

(defn type-val-expr [type-sym type-num type-val-sym fields impls]
  (let [x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field* (rdr/tag "#field")
        ctxt* (rdr/tag "#ctxt")]
    (ast/definition type-val-sym
      [(ast/reified type-num
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") ""
                                                      (ast/params [x*]) "" []
                                                      [(str type-sym)])]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/or-ast
                                       (conj (map fields
                                                  (fn [field]
                                                    (ast/call-ast identical-sym
                                                                  [(rdr/tag (str "." field))
                                                                   field*])))
                                             (rdr/tag 'nothing)))])]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") ""
                                     (ast/params [x* y*]) "" []
                                     [(ast/and-ast
                                       [(ast/call-ast
                                         =*-sym [(ast/call-ast get-type-sym [x*])
                                                 (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast
                                         =*-sym [(ast/call-ast reified-type-args-sym [x*])
                                                 (ast/call-ast reified-type-args-sym [y*])])
                                        (ast/call-ast maybe-sym [x*])])])]]]

                                 Associative-sym
                                 [[get-symb
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") ""
                                     (ast/params [x* field*]) "" []
                                     [(ast/and-ast
                                       [(ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym
                                                      [(ast/call-ast field* [x*])])])])]]]

                                 HashMapNode-sym
                                 [[assoc*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_STAR_") ""
                                     (ast/params [x* field* 'new-value '_ '_]) "" []
                                     [(ast/call-ast
                                       extract-sym
                                       [(ast/or-ast
                                         [(ast/and-ast
                                           [(ast/call-ast has-field-sym [x* field*])
                                            (ast/call-ast
                                             maybe-sym
                                             [(ast/call-ast field* [x* 'new-value])])])
                                          (ast/call-ast maybe-sym [x*])])])])]]]

                                 Hashable-sym
                                 [[sha1-update-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1_update") ""
                                     (ast/params [x* ctxt*]) "" []
                                     [(ast/call-ast sha1-update-type-sym [x* ctxt*])
                                      (ast/call-ast
                                       sha1-update-sym
                                       [(ast/call-ast reified-type-args-sym [x*]) ctxt*])])]]
                                  [sha1-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1") ""
                                     (ast/params [x*]) "" []
                                     [(ast/call-ast
                                       sha1-finalize-sym
                                       [(ast/call-ast
                                         sha1-update-sym
                                         [x* (ast/call-ast sha1-init-sym [])])])])]]]}
                                impls))])))

(defn declare-getters [new-type-name fields]
  (traverse fields
            (fn [field]
              (let [getter-sym (rdr/tag (str "." field) 'core 0)]
                (comp (map (sm/get-in-val [.modules 'core .proto-fns getter-sym]) (fn [_] []))
                      (for [dispatch-fn-var (global-var "dispatchFnPtr")
                            arity-fn-var1 (global-var "protoImpl")
                            impls-sym1 (global-var "protoImpls")
                            arity-fn-var2 (global-var "protoImpl")
                            impls-sym2 (global-var "protoImpls")
                            _ (new-module-def getter-sym (c-code dispatch-fn-var [] []
                                                                 FunctionType {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 1]
                                               (ProtocolDispatcher 1 arity-fn-var1 impls-sym1
                                                                   UnknownType [] [] {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 2]
                                               (ProtocolDispatcher 2 arity-fn-var2 impls-sym2
                                                                   UnknownType [] [] {}))
                            _ (new-static-arity dispatch-fn-var 1 arity-fn-var1 UnknownType)
                            _ (new-static-arity dispatch-fn-var 2 arity-fn-var2 UnknownType)]
                        ["ProtoImpls " impls-sym1 ";\n"
                         "ProtoImpls " impls-sym2 ";\n"
                         "Value *" dispatch-fn-var ";\n"
                         "Value *" arity-fn-var1
                         "(List *closures, Value *arg);\n"
                         "Value *" arity-fn-var2
                         "(List *closures, Value *arg1, Value *arg2);\n"]))))))

(defn create-getters [sym fields type-assertions]
  (let [type-value (rdr/tag "#value")
        field-types (reduce type-assertions {}
                            (fn [field-types assertion]
                              (let [type-assertion (.assertion assertion)]
                                (assoc field-types
                                  (.sym type-assertion) (.type-sym type-assertion)))))]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)))
          (fn [[field field-index]]
            (let [new-value (rdr/tag (str field))
                  extract-field (ast/call-ast
                                 extract-sym
                                 [(ast/call-ast
                                   nth-sym [(ast/call-ast reified-type-args-sym
                                                          [type-value])
                                            field-index])])
                  extract-field (either (map (get field-types field)
                                             (fn [field-type]
                                               (expr-type-ast field-type extract-field)))
                                        extract-field)
                  set-field (expr-type-ast
                             sym (ast/call-ast
                                  make-value-sym
                                  [type-value
                                   (ast/call-ast extract-sym
                                                 [(ast/call-ast
                                                   store-sym
                                                   [(ast/call-ast
                                                     reified-type-args-sym
                                                     [type-value])
                                                    field-index new-value])])]))]
              [(rdr/tag (str "." field))
               [(ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value new-value]) "" []
                                  (either (map (get field-types field)
                                               (fn [type-sym]
                                                 [(ast/assert-expr
                                                   (ast/assert-type type-sym new-value))
                                                  set-field]))
                                          [set-field]))
                (ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value]) "" []
                                  [extract-field])]])))}))

(defn destruct-impl-fields [sym ast assertions arity]
  (let [[type-value-parameter] (.fixed (.params arity))
        return-constraints (filter (.body arity) return-assertion?)
        new-body (comp return-constraints
                       (vec assertions)
                       (filter (.body arity) assertion?)
                       [(ast/let-ast [(ast/binding (.fields ast)
                                        (ast/call-ast
                                         reified-type-args-sym
                                         [type-value-parameter]))]
                                     (remove (.body arity) assertion?))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str sym "_" fn-name)))))

(defn destructure-fields [sym ast assertions]
  (let [impls (comp* {} (filter (.impls ast)
                                (partial instance? HashMap)))]
    (map-vals impls
              (fn [impl-arities]
                (map impl-arities
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields sym ast assertions))]))))))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            file-name ", " (ast/line-number ast)))]
              "")

            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym
                                              (ast/file-name sym)
                                              (ast/line-number sym))
                        type-num (extract rdr/type-counter)]
                  _ (sm/assoc-in-val [.modules file-name .types sym] #{type-num})
                  _ (sm/assoc-in-val [.constants .type-names type-num] sym)
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition
                                    (constructor-expr sym type-val-sym fields
                                                      (filter (.impls ast) assertion?)))
                  const-type-num (sm/get-in-val [.modules file-name .values sym .type-num])

                  field-types (traverse (filter (.impls ast) assert-type)
                                        (fn [assertion]
                                          (let [type-assertion (.assertion assertion)]
                                            (for [type-num (-> (.type-sym type-assertion)
                                                               maybe
                                                               get-type-number)]
                                              (sym-type-ast (.sym type-assertion) type-num)))))
                  :let [impls (merge-with comp
                                          (create-getters sym fields
                                                          (filter (.impls ast) assert-type))
                                          (destructure-fields sym ast field-types))]
                  type-val-def (emit-definition (type-val-expr sym type-num type-val-sym
                                                               fields impls))
                  constructor-arity (map (get-proto-impl invoke-sym const-arity-index
                                                         const-type-num)
                                         .c-var)
                  _ (sm/assoc-in-val [.fns constructor-arity const-arity-index .c-info .type-num]
                                     type-num)]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) UnknownType {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {} empty-closures {} {})
                                   (RuntimeInit (FunctionArityContext
                                                 {} 0 {} {} empty-closures {} {})
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names)
                                   0                        ;; reify-fn-index
                                   {}                       ;; other
                                   ))

(def string-writer (agent ""))

(def logger (agent ""))
(defn log [& msg]
  (send logger (fn [_]
                 (apply print-err msg))))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");" line-sep]))

(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity 'main 1)
                      (compilation-error "'main' function is missing"))
        values (sm/new-sm (fn [s]
                            (assert (instance? GlobalContext s))
                            (-> s
                                .init
                                .exprs
                                (vector s)
                                maybe)))]
    (write-strings ["\n#\n"
                    "\nint main (int argc, char **argv) {\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map values .init) "\n"
                    "#\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    (map values free-global) "\n"
                    "#\n"
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif\n"
                    "#\n"
                    "  return(0);\n};\n"])))

;; TODO: use 'switch' to dispatch proto fns
(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity
                    (str "&" arity-sym) num-args UnknownType
                    (c-code (str "&" arity-sym)
                            []
                            ["\n// " fn-name " " num-args " args\n"
                             "ProtoImpls " impls-sym " = {"
                             (count impls) ", {"
                             (rest (flat-map (vals impls)
                                             ;; [type arity-sym fn-sym]
                                             (fn [type-impl]
                                               [", " "{" (.dispatch-type type-impl)
                                                ", (Value *)" (.c-var type-impl)
                                                "}"])))
                             "}};\n"
                             "Value *" (.dispatch-sym proto-disp) "("
                             (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                              "List *closures")
                                        ", ")
                             ") {\n"
                             "  return(proto" num-args "Arg(&" impls-sym ", \""
                             fn-name "\", " (interpose
                                             (comp args
                                                   [(str "\"" (ast/file-name fn-name) "\"")
                                                    (ast/line-number fn-name)])
                                             ", ")
                             "));\n}\n"
                             "FnArity " arity-sym " = {FnArityType, -1, "
                             num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                            FnArityType {})
                    [])]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn))
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              UnknownType {}))))

(defn get-proto-dispatch-sym [fn-name num-args]
  (sm/get-in-val [.modules 'core .proto-fns fn-name .dispatchers num-args .dispatch-sym]))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (sm/assoc-in-val [.modules module-name]
                                         (Module module-name {} {} {} core-types {}))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [_ (map emitted (fn [expr]
                                                     (write-strings (.decl expr))))]
                              _ (sm/update-in-val [.init .exprs] (fn [exprs]
                                                                   (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))

(def finalize-protocols*
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              emit-proto-fn)]
    (map dispatchers (fn [expr] (write-strings (.decl expr))))))

(defn finalize-protocols [context]
  (update-context context
                  (comp finalize-protocols*
                        (compilation-error "Compilation error (Could not finalize protocols.)"))))

(def fixup-native-symbols*
  (apply-to (fn [& decl]
              (write-strings decl))
            (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                 (fn [arity-sym]
                   ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                 (fn [arity-sym]
                   ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                 (fn [arity-sym]
                   ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                 (fn [arity-sym]
                   ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                 (fn [arity-sym]
                   ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                 (fn [arity-sym]
                   ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                 (fn [arity-sym]
                   ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                 (fn [arity-sym]
                   ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'assoc*) 5)
                 (fn [arity-sym]
                   ["Value *(*assoc)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                 (fn [arity-sym]
                   ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym (rdr/tag 'get*) 5)
                 (fn [arity-sym]
                   ["Value *(*get)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                 (fn [arity-sym]
                   ["Value *(*showFn)(List *, Value *) = " (.c-var arity-sym) ";\n"]))

            (map (lookup-core-fn-arity (rdr/tag 'fn-apply) 2)
                 (fn [arity-sym]
                   ["Value *(*fn_apply)(List *, Value*, Value*) = "
                    (.c-var arity-sym) ";\n"]))))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(defn file-directory [src-file-name]
  (map (sys/realpath src-file-name)
       (fn [real-path]
         (let [[path-len] (reduce real-path [-1 0]
                                  (fn [[slash-pos c-pos] c]
                                    (let [c-pos (inc c-pos)]
                                      ((= c "/")
                                       [c-pos c-pos]
                                       [slash-pos c-pos]))))]
           (subs real-path 0 path-len)))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def clone-repo)
(def repo-cloner (agent {}))

(defn clone-repo* [ast root-dir proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sys/sh-proc "/usr/bin/git" (list "clone" "--branch" branch
                                                   (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sys/sh-proc "/usr/bin/git"
                                             (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter root-dir proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast root-dir proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter root-dir proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (assoc modules 'core 'loaded)))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? HashMap loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (analyze-forms {'file-name file-name
                                                                 'root-directory root-dir
                                                                 'project-directory proj-dir
                                                                 'line-number 1}
                                                                (lazy-list file-in))))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(main [params]
      (let [[_ file-name] params
            waiter (promise)]
        (or (map (file-directory file-name)
                 (fn [root-dir]
                   (write-strings ["\n#define _XOPEN_SOURCE 600"
                                   "\n#include <stdlib.h>"
                                   "\n#include \"core.h\"\n"])
                   (send module-compiler compile-module file-name waiter root-dir root-dir)))
            (do
              (print-err "Could not find " (str "'" file-name "'"))
              (abort)))
        (extract waiter)
        (send ast-emitter emit-main)
        (send ast-emitter finalize-protocols)
        (send ast-emitter fixup-native-symbols)
        ;; (send ast-emitter (fn [ctxt]
        ;;                     (print-err
        ;;                      "\n" 'static-fixed (get-in ctxt ['_ .other 'static-fixed-sites])
        ;;                      "\n" 'static-variadic (get-in ctxt ['_ .other 'static-variadic-sites])
        ;;                      "\n" 'invoke (get-in ctxt ['_ .other 'invoke-sites])
        ;;                      "\n" 'dyn-fn (get-in ctxt ['_ .other 'dyn-fn-sites])
        ;;                      "\n" 'dyn-unknown (get-in ctxt ['_ .other 'dyn-unknown-sites])
        ;;                      "\n" 'type-known (get-in ctxt ['_ .other 'type-known-sites])
        ;;                      "\n" 'type-unknown (get-in ctxt ['_ .other 'type-unknown-sites])
        ;;                      "\n")))
        ;; wait for agents to clear their queues
        (let [waiter (promise)]
          (send ast-emitter (fn [_]
                              (send string-writer (fn [_]
                                                    (deliver waiter 'x)))))
          (extract waiter))))
