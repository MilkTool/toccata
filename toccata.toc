
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def UnknownType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, 1};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, 2};"))
(def SubStringType (inline-C Number "(Value *)&(Number){NumberType, -1, 5};"))
(def FnArityType (inline-C Number "(Value *)&(Number){NumberType, -1, 3};"))
(def FunctionType (inline-C Number "(Value *)&(Number){NumberType, -1, 4};"))
(def ListType (inline-C Number "(Value *)&(Number){NumberType, -1, 6};"))
(def MaybeType (inline-C Number "(Value *)&(Number){NumberType, -1, 7};"))
(def VectorType (inline-C Number "(Value *)&(Number){NumberType, -1, 8};"))
(def VectorNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 9};"))

(def core-types {'Integer IntegerType
                 'String StringType
                 'SubString SubStringType
                 'FnArity FnArityType
                 'Function FunctionType
                 'List ListType
                 'Maybe MaybeType
                 'Vector VectorType
                 })

(def BitmapIndexedType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def ArrayNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def HashCollisionNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))

(def sm-space (sm/state-maybe ""))
(def sm-gensym (sm/lift gensym))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang fn-context init-fn-context modules numbers
                        strings fns namespaces]
  ;; target-lang            language to compile to
  ;; fn-context             context for the fn currently being compiled
  ;; init-fn-context        context for the initialization code
  ;; modules                info for each module compiled
  ;; numbers                static numbers
  ;; strings                static strings
  ;; fns                    static functions
  ;; namespaces             current namespace map
)

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types]
  ;; path             path to file containing the modules source code
  ;; values           map of value symbols to defined values
  ;; protocols        set of protocol symbols
  ;; proto-fns        map of protocol fn symbols to fn information
  ;; types            map of type symbols to type definitions
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [var-count syms]
  ;; var-count     number of C variables already used in this fn
  ;; syms          the symbols local to the function that are currently interned
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn reset-fn-context
  ([] (reset-fn-context (FunctionArityContext 0 {})))
  ([new-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-context)]
     curr-fn-context)))

(defn new-module [path]
  ;; If a module for `path` has not been defined yet, initialize it
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {} {} {} core-types))))

;; information about a compiled expression(s)
(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (str type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] (c-code "" [] [] UnknownType {}))
  (comp* [c cs]
    (let [[c & cs] (reverse (cons c cs))]
      (reduce cs c
              (fn [result expr]
                (let [refs-map (merge-with + (.refs-map expr)
                                           (.refs-map result))
                      refs-map ((empty? (.init expr)) refs-map (assoc refs-map
                                                                 (.c-var expr) 0))]
                  (c-code (.c-var result)
                          (list (.init expr) (.init result))
                          (list (.decl expr) (.decl result))
                          (.type-num result)
                          refs-map)))))))

(def empty-c-code (c-code "" [] [] UnknownType {}))

(defn collapse-exprs [exprs]
  (let [[c & cs] (reverse (seq exprs))
        c (assoc-in c [.refs-map (.c-var c)] 1)
        cs (remove cs (fn [c] (and (empty? (.init c))
                                   (empty? (.decl c)))))]
    (reduce cs c
            (fn [result expr]
              (let [init (extract (or (and (or (= 'inline (.c-var result))
                                               (= "" (.c-var expr))
                                               (empty? (.init expr)))
                                           (maybe [(.init expr) (.init result)]))
                                      (for [ref (get (.refs-map result) (.c-var expr))
                                            :when (< 0 ref)]
                                        (list (.init expr)
                                              "\nincRef(" (.c-var expr) ", "
                                              (str (dec ref)) ");\n"
                                              (.init result)))
                                      (maybe (list (.init expr)
                                                   "\ndec_and_free(" (.c-var expr) ", 1);\n"
                                                   (.init result)))))
                    refs-map (merge-with + (.refs-map expr)
                                         (.refs-map result))
                    refs-map ((empty? (.init expr)) refs-map (assoc refs-map
                                                               (.c-var expr) 0))]
                (c-code (.c-var result)
                        init
                        (comp (.decl expr) (.decl result))
                        (.type-num result)
                        refs-map))))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
              _ (compilation-error "Duplicate protocol" (str "'" proto-sym "'") "at"
                                   (str (ast/file-name proto-sym) ":")
                                   (ast/line-number proto-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using the current file name
  ;; 3. using `'core` for protcols defined in the core
  (comp (for [ns-sym (sm/when (.ns proto-sym))
              protocol-path (sm/get-in-val [.namespaces ns-sym])
              result (sm/get-in-val [.modules protocol-path .protocols proto-sym])]
          result)
        (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
        (sm/get-in-val [.modules 'core .protocols proto-sym])))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym])]
          (print-err "Duplicate protocol function" (str "'" fn-sym "'") "at"
                     (str (ast/file-name fn-sym) ":") (ast/line-number fn-sym)))
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function 'fn-sym' declared in module at 'path'
  (map (sm/get-in-val [.modules path .proto-fns fn-sym])
       (fn [_] path)))

(defprotocol FindProtoPath
  (find-protocol-path [fn-sym]
    (comp (for [sym-ns (sm/when (.ns fn-sym))
                namespace (sm/get-in-val [.namespaces sym-ns])
                path (lookup-protocol-path fn-sym namespace)]
            path)
          (lookup-protocol-path fn-sym (ast/file-name fn-sym))
          (lookup-protocol-path fn-sym 'core))))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym type-impls]
  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym]
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (for [protocol-path (find-protocol-path fn-sym)
        result (sm/get-in-val [.modules protocol-path .proto-fns fn-sym
                               .dispatchers num-args])]
    result))

(deftype ProtoImpl [dispatch-type c-code ast]
  Stringable
  (string-list [_] (list "<ProtoImpl " (str dispatch-type) ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type c-code ast]
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type c-code ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (for [protocol-path (find-protocol-path fn-name)
        impl-info (sm/get-in-val [.modules protocol-path .proto-fns fn-name
                                  .dispatchers arg-count .type-impls type-num])]
    impl-info))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))


(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_])

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym])

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(defn genlocal [pre]
  (for [sym-count (sm/get-in-val [.fn-context .var-count])
        _ (sm/assoc-in-val [.fn-context .var-count] (inc sym-count))]
    (symbol (str pre sym-count))))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (ast/file-name sym) .values sym]))

(defn lookup-sym [sym]
  (comp (sm/get-in-val [.fn-context .syms sym])
        (lookup-module-def sym)
        (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                           (str (ast/file-name sym) ":")
                           (ast/line-number sym))))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn new-static-arity [fn-var num-params arity-var type-num]
  (sm/assoc-in-val [.fns fn-var num-params]
                   (c-code arity-var [] [] type-num {})))


(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))

  (emit-defined-value [_ _] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe [])))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-val .strings) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.strings str-val]
                             (c-code str-ptr [] [] StringType {}))]
      (c-code str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .values defined-sym]
                             (c-code (.c-var value) [] [] (.type-num value) {}))]
      [(assoc value .c-var "")])))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-val .numbers) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-code num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Number
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.numbers num])
          (make-static-num num)))
  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .values defined-sym] (.c-var value))]
      [(assoc value .c-var "")])))


(extend-type rdr/tagged-symbol
  Emitter
  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .values defined-sym] value)]
      [(assoc value .c-var "")])))


(defn get-type [type-symbol]
  (sm/state-maybe 0))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (lookup-module-def defined-sym)
                      (global-var "var"))
          _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .values defined-sym] c-var)]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [] [(.txt ast)] type-num {}))))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-code result-sym
                               ["\n// call-vector\n// #line " (str (ast/line-number target))
                                " " "\""
                                (ast/file-name target) "\"\n"
                                "Vector *" vect-sym " = empty_vect;\n"
                                (map args
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [vect-sym " = mutateVectConj(" vect-sym ", "
                                          arg-sym ");\n"])))
                                "Value *" result-sym " = (Value *)" vect-sym ";\n"]
                               [] VectorType {})]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-code result-sym
                                ["\n// call-list\n// #line "
                                 (str (ast/line-number target)) " " "\""
                                 (ast/file-name target) "\"\n"
                                 "List *" list-sym " = empty_list;\n"
                                 (map (reverse args)
                                      (fn [arg]
                                        (let [arg-sym (.c-var arg)]
                                          [list-sym " = listCons(" "(Value *)" arg-sym
                                           ", " list-sym ");\n"])))
                                 "Value *" result-sym " = (Value *)" list-sym ";\n"]
                                [] ListType {})]))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        result-sym (genlocal "rslt")]
    (c-code result-sym
            ["\n// static-fixed\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq arg-vars)) ", ") ");\n"]
            [] (.type-num arity-info) {})))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [args (emit (.args ast))
            call-site (comp (call-vector (.call-target ast) args)
                            (call-list (.call-target ast) args)
                            (for [target (emit (.call-target ast))
                                  call-site (call-static-fixed target (map args .c-var)
                                                               file-name line-number)]
                              (comp* target (comp args [call-site]))))]
        call-site)))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (global-var "var")
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .values defined-sym]
                             (c-code var [] [] (.type-num value) (.refs-map value)))]
      [(c-code var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(defprotocol Bindings
  (bind [binding])
  (bind [binding evalled])
  (gen-binding-syms [param]
    ;; generate bindings for symbols and tagged-symbols
    (for [param-var (genlocal "arg")
          :let [var-info (c-code param-var ["//" (str param) " " (str param-var) "\n"] []
                                 UnknownType {param-var 1})]
          _ (sm/assoc-in-val [.fn-context .syms param] var-info)]
      var-info)))

(extend-type rdr/tagged-symbol
  Bindings
  (bind [binding]
    (for [arg-var (genlocal "arg")
          :let [arg (c-code arg-var [] [] UnknownType {})]
          _ (sm/assoc-in-val [.fn-context .syms binding] arg)]
      [arg]))

  (bind [binding evalled]
    (for [_ (sm/assoc-in-val [.fn-context .syms binding]
                             (c-code (.c-var evalled) [] [] (.type-num evalled)
                                     {(.c-var evalled) 1}))]
      [evalled])))

(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(defn unpack-arg-list* [list-sym arg-syms file-name line-num]
  (comp (sm/when (for [arg (first arg-syms)
                       :when (= 1 (count arg-syms))]
                   [(c-code (.c-var arg)
                            ["Value *" (.c-var arg) " = (Value *)"
                             list-sym ";\n" (.init arg)]
                            (.decl arg)
                            (.type-num arg)
                            (.refs-map arg))]))
        (for [arg-syms (traverse arg-syms sm/state-maybe
                                 (fn [arg]
                                   (comp (for [_ (sm/when (= "" (.c-var arg)))
                                               arg-sym (genlocal "arg")]
                                           (c-code arg-sym [""] [] UnknownType {}))
                                         (sm/state-maybe (assoc arg .init [""])))))
              ;; the [""] above signals that these expressions are where these values are created
              ;; It's an ugly hack that should be represented by a type.
              destructArgs (genlocal "destArgs_")]
          (let [len-sym (gensym "len_")]
            (cons (c-code ""
                          [(map arg-syms (fn [arg] ["Value *" (.c-var arg) ";\n"]))
                           "Value **" destructArgs "[" (count arg-syms) "] = {"
                           (interpose (map arg-syms (fn [arg] ["&" (.c-var arg)])) ", ")
                           "};\n" "destructValue(\"" file-name "\", \"" line-num
                           "\", (Value *)" list-sym ", " (count arg-syms) ", "
                           destructArgs ");\n"]
                          [] UnknownType {list-sym 1})
                  arg-syms)))))

(extend-type ast/params-ast
  Bindings
  (gen-binding-syms [params]
    (map (traverse (.fixed params) sm/state-maybe bind) (fn [xs]
                                                          (seq (flatten xs)))))
  (bind [params]
    (for [arg-var (genlocal "arg")
          arg-syms (gen-binding-syms params)
          tail (gen-binding-syms 'tail)
          :let [arg-syms (comp arg-syms [tail])]
          args-list (unpack-arg-list* arg-var arg-syms
                                      (ast/file-name params)
                                      (ast/line-number params))]
      [(comp (apply comp args-list) (c-code arg-var [] [] UnknownType {}))]))

  (bind [params evalled]
    (for [arg-syms (gen-binding-syms params)
          tail (gen-binding-syms 'tail)
          :let [arg-syms (comp arg-syms [tail])]
          args-list (unpack-arg-list* (.c-var evalled) arg-syms
                                      (ast/file-name params)
                                      (ast/line-number params))
          evalled (sm/when (or (and (empty? (.init evalled))
                                    (maybe empty-c-code))
                               (maybe evalled)))]
      (cons evalled args-list))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals (sm/get-in-val [.fn-context .syms])
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          _ (sm/get-in-val [.fn-context .syms] locals)]
      (collapse-exprs (comp (flatten bindings) body-exprs))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (global-var "var")
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .values defined-sym]
                             (c-code var [] [] (.type-num value) (.refs-map value)))]
      [(c-code var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [and-result (genlocal "andRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce
                            evalled-clauses [[] total-refs]
                            (fn [[init remaining-refs] clause]
                              (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                  (partial < 0)))
                                    remaining-refs (reduce
                                                    clause-refs
                                                    remaining-refs
                                                    (fn [remaining-refs [k v]]
                                                      (extract
                                                       (or (update-in remaining-refs [k]
                                                                      (fn [remaining]
                                                                        (- remaining v)))
                                                           (maybe remaining-refs)))))]
                                [(conj (vec init)
                                       ["// and clause\n"
                                        (.init clause)
                                        and-result " = " (.c-var clause) ";\n"
                                        "if (isNothing(" and-result ")) {\n"
                                        (map (seq (filter-vals remaining-refs (partial < 0)))
                                             (fn [[c-sym remaining]]
                                               ["dec_and_free(" c-sym ", "
                                                remaining ");\n"]))
                                        "} "])
                                 remaining-refs])))]
        (c-code and-result
                ["Value *" and-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" and-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                Maybe total-refs)))))


(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (for [or-result (genlocal "orRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce evalled-clauses [[] total-refs]
                                   (fn [[init remaining-refs] clause]
                                     (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                         (partial < 0)))
                                           remaining-refs (reduce
                                                           clause-refs
                                                           remaining-refs
                                                           (fn [remaining-refs [k v]]
                                                             (extract
                                                              (or
                                                               (update-in remaining-refs [k]
                                                                          (fn [remaining]
                                                                            (- remaining v)))
                                                               (maybe remaining-refs)))))]
                                       [(conj init
                                              ["// or clause\n"
                                               (.init clause)
                                               or-result " = " (.c-var clause) ";\n"
                                               "if (!isNothing(" or-result ")) {\n"
                                               (map (seq (filter-vals remaining-refs
                                                                      (partial < 0)))
                                                    (fn [[c-sym remaining]]
                                                      ["dec_and_free(" c-sym ", "
                                                       remaining ");\n"]))
                                               "} "])
                                        remaining-refs])))]
        (c-code or-result
                ["Value *" or-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" or-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                Maybe total-refs)))))


(extend-type ast/assert-ast
  Emitter
  (emit [ast]
    (sm/state-maybe empty-c-code)))


(extend-type ast/returns-ast
  Emitter
  (emit [ast]
    (sm/state-maybe empty-c-code)))


(deftype StaticArity [arity-fn-var param-count var-info]
  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info))))

(defn emit-static-arity [params body]
  (let [param-count (count params)]
    (for [arity-fn-var (global-var "arityImpl")
          arity-var (global-var "fnArity")
          fn-context (reset-fn-context)
          param-syms (gen-binding-syms params)
          body-exprs (emit body)
          :let [body (collapse-exprs body-exprs)]
          :when-not (and (empty? (.init body))
                         (empty? (.decl body)))
          _ (sm/set-val .fn-context fn-context)]
      (let [param-decls (map param-syms (fn [param]
                                          (str "Value *" (.c-var param))))
            fn-expr (comp* (c-code "" []
                                   ["Value *" arity-fn-var "("
                                    (interpose (cons "List *closures" param-decls) ", ")
                                    ") {\n"]
                                   FnArityType {})
                           param-syms)
            fn-result (extract (or (and (= "" (.c-var body))
                                        (maybe "nothing"))
                                   (maybe (.c-var body))))]
        (StaticArity arity-fn-var param-count
                     (c-code (str "&" arity-var)
                             []
                             [(.decl body)
                              (.decl fn-expr)
                              (.init fn-expr)
                              (.init body)
                              "\nreturn(" fn-result ");\n};\n\n"
                              "FnArity " arity-var " = {FnArityType, -1, " param-count
                              ", (List *)0, " "0" ", " arity-fn-var "};\n"]
                             FnArityType {}))))))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [fn-arity (emit-static-arity (.params ast) (.body ast))
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [num-args (count (.params prototype))]
    (for [arity-fn-var (sm-gensym "protoDisp")
          impls-sym (sm-gensym "protoImpls")
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var UnknownType)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-static-arity (.params prototype) default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.var-info static-arity) default-body)]
            (.decl (.var-info static-arity)))

          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (sm-gensym "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] FunctionType {}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities sm/state-maybe
                                   (partial declare-proto-dispatch-arity
                                            fn-name dispatch-fn-sym))
        default-fns (traverse arities sm/state-maybe
                              (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (apply merge-with comp
                               (map (.prototypes ast)
                                    (fn [prototype]
                                      {(.fn-name prototype) [prototype]})))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map) sm/state-maybe
                        (partial create-dispatcher proto-name))]
        [(c-code "" [] decl UnknownType {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-static-arity (.params ast) (.body ast))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (let [fn-name (.fn-sym ast)]
      (for [struct-var (global-var "fnStruct")
            fn-var (global-var "fn")
            arities-info (emit (.arities ast))
            emitted-arities (traverse arities-info sm/state-maybe
                                      (fn [static-arity]
                                        (for [_ (new-static-arity
                                                 fn-var
                                                 (.param-count static-arity)
                                                 (.arity-fn-var static-arity)
                                                 (.type-num (.var-info static-arity)))]
                                          (.var-info static-arity))))]
        (let [arity-count (count emitted-arities)
              arity-vars (map emitted-arities .c-var)]
          (c-code fn-var []
                  ["\n// --------- " fn-name " --------------\n"
                   "Value *" fn-var ";\n"
                   (map emitted-arities .decl)
                   "\n// --------- " fn-name " declaration --------------\n"
                   "Function " struct-var " = {FunctionType, -1, \""
                   fn-name "\", " arity-count ", "
                   "{" (to-str (interpose arity-vars ", ")) "}};\n"
                   "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
                  FunctionType {})))))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .values defined-sym]
                             (c-code (.c-var value) [] []
                                     (.type-num value)
                                     (.refs-map value)))]
      [(assoc value .c-var "")])))

(defn extend-type* [ast type-num]
  (for [_ (traverse (keys (.impls ast)) sm/state-maybe
                    (fn [protocol-name]
                      (comp (get-protocol protocol-name)
                            (compilation-error "Invalid protocol:" protocol-name "in"
                                               (str (ast/file-name fn-name) ",")
                                               (ast/line-number protocol-name)))))
        ext-fns (traverse (for [impl-fns (vals (.impls ast))
                                [fn-name arities] (seq impl-fns)
                                impl-arity arities]
                            [fn-name impl-arity])
                          sm/state-maybe
                          (fn [[fn-name arity-ast]]
                            (let [num-args (count (.params arity-ast))]
                              (for [_ (comp (get-protocol-dispatcher fn-name num-args)
                                            (compilation-error "Invalid protocol fn:"
                                                               fn-name "in"
                                                               (str (ast/file-name fn-name)
                                                                    ",")
                                                               (ast/line-number fn-name)))
                                    ext-fn (emit (assoc arity-ast .param-types [type-num]))
                                    _ (new-proto-impl fn-name num-args type-num
                                                      (.var-info ext-fn) arity-ast)]
                                (.var-info ext-fn)))))]
    ext-fns))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (sm/when (or (and (= type-sym 'HashMap)
                                              (maybe (list BitmapIndexedType
                                                           ArrayNodeType
                                                           HashCollisionNodeType)))
                                         (and (= type-sym 'String)
                                              (maybe (list StringType
                                                           SubStringType)))))
                  fns (map (traverse type-nums sm/state-maybe (partial extend-type* ast))
                           flatten)]
              fns)
            (for [type-num (comp (for [ns-path (comp (for [ns-sym (sm/when (.ns (.type ast)))
                                                           ns-path (sm/get-in-val
                                                                    [.namespaces ns-sym])]
                                                       ns-path)
                                                     (sm/state-maybe (ast/file-name ast))) 
                                       type-num (sm/get-in-val [.modules ns-path
                                                                .types type-sym])]
                                   type-num)
                                 (sm/get-in-val [.modules 'core .types type-sym])
                                 (compilation-error "Trying to extend unknown type: "
                                                    type-sym "at"
                                                    (str (.file-name (.type ast)) ":")
                                                    (ast/line-number (.type ast))))
                  fn (extend-type* ast type-num)]
              fn)))))

(def global-context (GlobalContext 'C
                                   (FunctionArityContext 0 {})
                                   (FunctionArityContext 0 {})
                                   {}                       ;; map for module info
                                   {}                       ;; map for const numbers
                                   {}                       ;; map for const strings
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   ))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defn emit-main [vals]
  (for [main-fn (lookup-static-arity 'main 1)]
    [(c-code "" []
             ["\nint main (int argc, char **argv) {\n"
              "outstream = stdout;\n"
              (map vals .init) "\n"
              "Value *the_final_answer = " (.c-var main-fn) "((List *)0, (Value *)0);\n\n"
              "#ifdef CHECK_MEM_LEAK\n"
              (map vals (fn [val]
                          [(.c-var val) "->refs = 1;\n"
                           "freeGlobal(" (.c-var val) ");\n"]))
              "  dec_and_free(the_final_answer, 1);\n"
              "  freeAll();\n"
              "  if (malloc_count - free_count != 0)\n"
              "     return(1);\n"
              "#endif\n"
              "    return(0);\n};\n"]
             0 {})]))

(defprotocol SymFileInfo
  (symbol-file-info [_]))

(extend-type rdr/tagged-symbol
  SymFileInfo
  (symbol-file-info [sym]
    (sm/state-maybe [(ast/file-name sym) (ast/line-number sym)])))

(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity
                    (str "&" arity-sym) num-args
                    (c-code (str "&" arity-sym)
                            []
                            ["\n// " fn-name " " num-args " args\n"
                             "ProtoImpls " impls-sym " = {"
                             (count impls) ", {"
                             (rest (flat-map (vals impls)
                                             ;; [type arity-sym fn-sym]
                                             (fn [type-impl]
                                               [", " "{" (.dispatch-type type-impl)
                                                ", (Value *)" (.c-var (.c-code type-impl))
                                                "}"])))
                             "}};\n"
                             "Value *" (.dispatch-sym proto-disp) "("
                             (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                              "List *closures")
                                        ", ")
                             ") {\n"
                             "  return(proto" num-args "Arg(&" impls-sym ", \""
                             fn-name "\", " (interpose
                                             (comp args
                                                   [(str "\"" (ast/file-name fn-name) "\"")
                                                    (ast/line-number fn-name)])
                                             ", ")
                             "));\n}\n"
                             "FnArity " arity-sym " = {FnArityType, -1, "
                             num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                            FnArityType {}))]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn)) sm/state-maybe
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              UnknownType {}))))

(defn finalize-protocols []
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              sm/state-maybe
                              emit-proto-fn)]
    dispatchers))

(defn get-proto-dispatch-sym [fn-name num-args]
  (sm/get-in-val [.modules "" .proto-fns (rdr/tag fn-name "" 0)
                  .dispatchers num-args .dispatch-sym]))

(defn fixup-native-symbols []
  (apply-to (fn [decl]
              (c-code "" [] decl UnknownType {}))
            (map (get-proto-dispatch-sym 'type-name 1)
                 (fn [arity-sym]
                   ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))))

(main [params]
      (let [[_ file-name] params]
        (println)
        (for [core-file (fio/file-in "core.toc")
              core-asts (analyze-forms (cache core-file))
              in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (comp (for [_ (new-module "")
                                          emitted-core (traverse core-asts sm/state-maybe
                                                                 emit-definition)
                                          emitted (traverse asts sm/state-maybe
                                                            emit-definition)
                                          main-fn (emit-main (remove (flatten emitted)
                                                                     (fn [val]
                                                                       (= "" (.c-var val)))))
                                          dispatchers (finalize-protocols)
                                          fixups (fixup-native-symbols)]
                                      (flatten (comp emitted-core emitted [main-fn]
                                                     [dispatchers] [[fixups]])))
                                    (compilation-error "Could not compile"))]
              [emitted-exprs] (emit-code global-context)]
          (let [_ (write-str "\n#include \"core.h\"\n")]
            (map emitted-exprs
                 (fn [emitted]
                   (write-str (.decl emitted))))))))
