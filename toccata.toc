
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "3a195b6"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "c89ab00"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "7690cd3"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "40c1c4d"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "ecde30b"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e7a489b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ba18227"))

(def Tagged (comp ast/SymbolOrString
                  rdr/tagged-symbol))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "")

(defn line-macro [ast marker]
  (let [file-name (ast/file-name ast)]
    (sm/state-maybe (either (= "" file-name)
                            ["\n" marker "\n#line "
                             (str (ast/line-number ast)) " " "\""
                             (either (and (= 'core file-name)
                                          (maybe path-to-core))
                                     file-name)
                             "\"\n"]))))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringBufferType "String"
                 SubStringType "String"
                 FnArityType "FnArity"
                 FunctionType "Function"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"
                 UnknownType "UnknownType"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-type-nums {'Integer IntegerType
                     'StringBuffer StringBufferType
                     'SubString SubStringType
                     'FnArity FnArityType
                     'Function FunctionType
                     'List ListType
                     'Maybe MaybeType
                     'Vector VectorType
                     'Symbol SymbolType
                     'BitmapIndexedNode BitmapIndexedType
                     'ArrayNode ArrayNodeType
                     'HashCollisionNode HashCollisionNodeType
                     'Promise PromiseType
                     'Future FutureType
                     'Agent AgentType
                     'Opaque OpaqueType
                     'TypeCount TypeCount})

(deftype TypeInfo [sym type-map])

(def core-types {IntegerType (TypeInfo 'Integer {IntegerType #{}})
                 StringBufferType (TypeInfo 'StringBuffer {StringBufferType #{}})
                 SubStringType (TypeInfo 'SubString {SubStringType #{}})
                 FnArityType (TypeInfo 'FnArity {FnArityType #{}})
                 FunctionType (TypeInfo 'Function {FunctionType #{}})
                 ListType (TypeInfo 'List {ListType #{}})
                 MaybeType (TypeInfo 'Maybe {MaybeType #{}})
                 VectorType (TypeInfo 'Vector {VectorType #{}})
                 SymbolType (TypeInfo 'Symbol {SymbolType #{}})
                 BitmapIndexedType (TypeInfo 'BitmapIndexedNode {BitmapIndexedType #{}})
                 ArrayNodeType (TypeInfo 'ArrayNode {ArrayNodeType #{}})
                 HashCollisionNodeType (TypeInfo 'HashCollisionNode {HashCollisionNodeType #{}})
                 PromiseType (TypeInfo 'Promise {PromiseType #{}})
                 FutureType (TypeInfo 'Future {FutureType #{}})
                 AgentType (TypeInfo 'Agent {AgentType #{}})
                 OpaqueType (TypeInfo 'Opaque {OpaqueType #{}})})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defn format-path* [path desired-len]
  (either (empty? path)
          (let [path (map path
                          (fn [[file line]]
                            (str file ": " line)))
                max-width (reduce path 0 (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                path (either (and (< (count path) desired-len)
                                  (maybe (comp path (repeat (- desired-len (count path))
                                                            (spaces max-width)))))
                             path)]
            (map path
                 (fn [x]
                   (str x (spaces (- max-width (count x)))))))))

(deftype StaticLengthConstraint [length path sym var])
(deftype StaticIntConstraint [val path sym var])
(deftype StaticStrConstraint [val path sym var])

(def StaticConstraints (comp StaticLengthConstraint
                             StaticStrConstraint
                             StaticIntConstraint))

(defprotocol Constraint
  (format-path [x n])

  (intersect [c1 c2])
  (restrict-types [c type-map]
    type-map)

  (extract-type-map [_]
    (assert-result r (instance? Maybe r))
    nothing)

  (extract-items-constraints [_]
    (assert-result r (instance? List r))
    empty-list)

  (update-path [constraint file-name line-number]
    constraint)

  (update-sym [tc new-sym]
    (assert (instance? Tagged new-sym))
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (assert (instance? String new-var))
    (.var tc new-var))

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))
    nothing)

  (runtime-check [constraint value-info file-name line-number]
    ;; generated code must preserve ref counts
    []))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "<NoValues>"))

  Constraint
  (intersect [nv _] nv)
  (update-sym [x _] x)
  (update-var [x _] x)

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (.path c)))) n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c max-len)))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (< (count (.constraints x)) (count (.constraints y)))
                  (maybe y))
             (maybe x))))

  Composition
  (comp* [nv-type _]
    nv-type))

(def bottom-type (NoValues []))

(deftype AllValues []
  Stringable
  (string-list [_]
    (list "<AllValues>"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (intersect [_ c] c)
  (update-sym [x _] x)
  (update-var [x _] x)

  Composition
  (comp* [av-type constraints]
    (either (map (first constraints)
                 (fn [constraint]
                   (comp* constraint (rest constraints))))
            av-type)))


(def top-type (AllValues))

(deftype MultiConstraint [constraints]
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_] (list "<MultiConstraint \n" (to-str (interpose constraints "\n-- ")) ">"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (= constraints (.constraints y))
         (maybe x)))

  Collection
  (conj [mc c]
    (either (or (= bottom-type c)
                (and (some constraints (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj constraints c))))

  Constraint
  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (.path c)))) n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  (update-sym [mc sym]
    (.constraints mc (map constraints (fn [c]
                                        (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map constraints (fn [c]
                                        (update-var c var)))))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number)))))

  (intersect [mc c]
    (either (or (and (instance? MultiConstraint c)
                     (maybe (reduce (.constraints c) mc
                                    (fn [cs new-c]
                                      (either (= cs bottom-type)
                                              (intersect new-c cs))))))
                (= bottom-type (intersect c mc))
                (and (some constraints (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj constraints c)))))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params result-constraint])

  ;; Does 'ast' produce any executable code when emitted?
  (produces-code? [ast]
    (assert-result x (instance? Maybe x))
    (maybe ast))

  ;; Emit a call expression if the call target is a tagged-symbol. Otherwise, fail
  (emit-call-expr [target-ast args call-expr-ast]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; produce a constraint from an assertion ast
  (to-constraint [ast]
    (sm/state-maybe top-type))

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x)))

  ;; unpack the 'list-var' and bind the items to the 'elem-vars'
  (bind-list [list-var params]
    (assert (instance? ast/params-ast params)))

  ;; get the constraints for a symbol or params-ast
  (get-param-constraints [_ constraint-map]
    (assert-result x (instance? sm/new-sm x)))

  ;; update the constraint map for symbol
  (constrain-sym [sym constraint]
    (sm/state-maybe constraint)))

(defprotocol Assertion
  (assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (return-assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (assert-type [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (assert-return-type [ast]
    (assert-result x (instance? Maybe x))
    nothing))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? HashMap type-maps))
  (assert (instance? List path))
  (assert (instance? Tagged type-sym))
  (assert (instance? Maybe sym))
  ;; (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "<TypeConstraint " (str type-sym) " " (str type-maps)
          " " (str sym) " '" (str var) "'>"))

  Eq
  (=* [x y]
    (and (instance? TypeConstraint y)
         (= type-maps (.type-maps y))
         (maybe x)))

  Constraint
  (satisfied-by [c info]
    (map (extract-type-map info)
         (fn [value-type-map]
           (subset (set (keys type-maps))
                   (set (keys value-type-map))))))

  (extract-type-map [_]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "'" type-sym "' From") ""]
                        path)
                  desired-len))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (satisfied-by constraint value-info)
                 (maybe ""))
            (let [file-name (either (and (= file-name 'core)
                                         (maybe "$TOCCATA_DIR/core.toc"))
                                    file-name)
                  sym-location (either (= "" file-name)
                                       (str " at " file-name ", line " line-number))]
              ["switch (" var "->type) {" line-sep
               (map (keys type-maps) (fn [type-num]
                                       ["case " type-num ": " line-sep]))
               "break;" line-sep " default:"
               "\n#ifndef EMBEDDED\n"
               "fprintf(stderr, \"Invalid type of value for '"
               (either sym "<unknown>") "'" sym-location "\\n\");\n"
               "fprintf(stderr, \"Needed " (str type-sym)
               ", got %s\\n\", extractStr(type_name(empty_list, " var ")));" line-sep
               "fprintf(stderr, \""
               (interpose (format-path constraint (inc (count path))) "\\n")
               "\\n\");"
               "\n#endif\n"
               "abort();" line-sep
               "}" line-sep]))))

(def fn-constraint (TypeConstraint {FunctionType #{}} empty-list 'Function nothing ""))
(def sym-constraint (TypeConstraint {SymbolType #{}} empty-list 'Symbol nothing ""))

(extend-type StaticLengthConstraint
  (assert (instance? Integer length))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Eq
  (=* [x y]
    (and (instance? StaticLengthConstraint y)
         (= (.length x) (.length y))
         (maybe x)))

  Stringable
  (string-list [c]
    (list "<StaticLengthConstraint " (str (.length c)) " " (str (.sym c)) "\n"
          (to-str (interpose (seq (.path c)) "\n")) ">"))

  Constraint
  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                        (.path x))
                  desired-len)))

(defn destruct-seq [seq-c-var elem-c-vars dest-args file-name line-num]
  (assert (instance? Tagged seq-c-var))
  (assert (instance? Tagged dest-args))

  (let [elem-count (count elem-c-vars)]
    [(map elem-c-vars (fn [var]
                        ["Value *" var ";" line-sep]))
     "Value **" dest-args "[" elem-count "] = {"
     (interpose (map elem-c-vars (fn [var] ["&" var])) ", ")
     "};" line-sep "destructValue(\"" file-name "\", \"" line-num
     "\", (Value *)" seq-c-var ", " elem-count ", "
     dest-args ");" line-sep]))

(deftype ItemsConstraint [items-constraints path sym var]
  (assert (instance? List items-constraints))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Container
  (empty? [_]
    (every items-constraints empty?))

  Eq
  (=* [x y]
    (and (instance? ItemsConstraint y)
         (= items-constraints (.items-constraints y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<ItemsConstraint " (str items-constraints) " " (str sym) ">"))

  Constraint
  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  (extract-items-constraints [_]
    items-constraints)

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (satisfied-by constraint value-info)
                 (maybe ""))
            (let [file-name (either (and (= file-name 'core)
                                         (maybe "$TOCCATA_DIR/core.toc"))
                                    file-name)]
              (either (and (empty? items-constraints)
                           (maybe []))
                      [(-> (TypeConstraint {ListType #{} VectorType #{}} path 'Sequence sym var)
                           (runtime-check value-info file-name line-number))
                       (let [sym-location (either (= "" file-name)
                                                  (str " at " file-name ", line " line-number))
                             min-count (str (count items-constraints))]
                         ["if (countSeq(incRef(" var ", 1)) < " min-count ") {"
                          "\n#ifndef EMBEDDED\n"
                          "fprintf(stderr, \"Insufficient values" sym-location "\\n\");\n"
                          "fprintf(stderr, \"Needed " min-count
                          ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, " var "))->numVal);" line-sep
                          "fprintf(stderr, \"From: \\n"
                          (interpose (format-path constraint (inc (count path))) "\\n")
                          "\\n\");"
                          "\n#endif\n"
                          "abort();" line-sep
                          "}\n"])
                       "if (1) {\n // TODO: I'm sure this is awful\n"
                       "incRef(" var ", 1);" line-sep
                       (let [items (map (range (inc (count items-constraints)))
                                        (partial str var "_"))]
                         [(destruct-seq var items (str var "_args") file-name line-number)
                          (for [[constraints item] (zip-lists items-constraints items)]
                            (runtime-check (update-var constraints item) value-info file-name line-number))
                          (map items (fn [item]
                                       (str "dec_and_free(" item ", 1);" line-sep)))])
                       "}" line-sep])))))

(def empty-items-constraint (ItemsConstraint empty-list empty-list nothing ""))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Tagged field))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Eq
  (=* [x y]
    (and (instance? FieldConstraint y)
         (= field (.field y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<FieldConstraint " (str field) " " (str sym)
          ;; "\n" (str (interpose path "\n"))
          ">"))

  Constraint
  (restrict-types [c type-map]
    (reduce (seq type-map) {}
            (fn [type-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc type-map type-num field-set)))
                      type-map))))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (satisfied-by constraint value-info)
                 (maybe ""))
            (let [file-name (either (and (= file-name 'core)
                                         (maybe "$TOCCATA_DIR/core.toc"))
                                    file-name)
                  sym-location (either (= "" file-name)
                                       (str " at " file-name ", line " line-number))]
              ["if(1) {\n"
               "Value *dork = hasField(empty_list, incRef(" var ", 1), " field-var ");\n"
               "if (isNothing(dork,\"\",0)) {"
               "\n#ifndef EMBEDDED\n"
               "fprintf(stderr, \"Value of type '%s' does not have field '"
               field "'" sym-location "\\n\", extractStr(type_name(empty_list, " var ")));\n" line-sep
               "fprintf(stderr, \""
               (interpose (format-path constraint (inc (count path))) "\\n")
               "\\n\");"
               "\n#endif\n"
               "abort();" line-sep
               "}\ndec_and_free(dork, 1);\n}\n"])))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len)))

(def SymbolConstraints (comp TypeConstraint
                             StaticLengthConstraint
                             StaticIntConstraint
                             StaticStrConstraint
                             ItemsConstraint
                             FieldConstraint))

(extend-type SymbolConstraints
  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint (cons [(str file-name ":") line-number]
                                      (.path constraint)))))))

(extend-type TypeConstraint
  Constraint
  (intersect [tc c]
    (either (or (= tc c)
                (= c bottom-type)
                (and (= c top-type) (maybe tc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) tc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c tc))))
                (and (instance? ItemsConstraint c)
                     (let [types-map (select-keys (.type-maps tc) [ListType VectorType])]
                       (and (empty? types-map)
                            (maybe (NoValues [tc c])))))
                (and (instance? FieldConstraint c)
                     (let [field (.field c)]
                       (and (empty? (filter (vals (.type-maps tc)) (fn [fields]
                                                                     (fields field))))
                            (maybe (NoValues [tc c])))))
                (and (instance? TypeConstraint c)
                     (let [types-map (select-keys (.type-maps tc) (keys (.type-maps c)))]
                       (and (empty? types-map)
                            (maybe (NoValues [tc c]))))))
            (MultiConstraint [tc (update-var c (.var tc))]))))

(extend-type FieldConstraint
  Constraint
  (satisfied-by [c info]
    (let [type-map (extract-type-map info)]
      (or (flat-map type-map
                    (fn [type-map]
                      (first (seq (restrict-types c type-map)))))
          (and (= nothing type-map)
               (or (and (instance? FieldConstraint info)
                        (= (.field c) (.field info)))
                   (and (instance? MultiConstraint info)
                        (some (.constraints info)
                              (partial satisfied-by c))))))))

  (intersect [fc c]
    (either (or (= fc c)
                (= c bottom-type)
                (and (= c top-type) (maybe fc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) fc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c fc))))
                (and (instance? ItemsConstraint c)
                     (maybe (NoValues [fc c])))
                (and (instance? TypeConstraint c)
                     (let [field (.field fc)]
                       (and (empty? (filter (vals (.type-maps c)) (fn [fields]
                                                                    (fields field))))
                            (maybe (NoValues [fc c]))))))
            (MultiConstraint [fc (update-var c (.var fc))]))))

(extend-type ItemsConstraint
  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (ItemsConstraint (map (.items-constraints constraint)
                            (fn [constraints]
                              (update-path constraints file-name line-number)))
                       (cons [file-name line-number] (.path constraint))
                       (.sym constraint) (.var constraint))))

  (intersect [ic c]
    (either (or (= ic c)
                (= c bottom-type)
                (and (= c top-type) (maybe ic))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) ic
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c ic))))
                (and (instance? TypeConstraint c)
                     (let [types-map (select-keys (.type-maps c) [ListType VectorType])]
                       (and (empty? types-map)
                            (maybe (NoValues [ic c])))))
                (and (instance? StaticLengthConstraint c)
                     (< (.length c) (count (.items-constraints ic)))
                     (maybe (NoValues [ic c])))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [ic c])))
                (and (instance? ItemsConstraint c)
                     (= bottom-type
                        (reduce (zip-lists (.items-constraints ic) (.items-constraints c))
                                top-type
                                (fn [final-c [c1 c2]]
                                  (either (= bottom-type final-c)
                                          (intersect c1 c2)))))))
            (MultiConstraint [ic (update-var c (.var ic))]))))

(extend-type StaticLengthConstraint
  Constraint
  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c])))
                (and (instance? ItemsConstraint c)
                     (< (.length slc) (count (.items-constraints c)))
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(extend-type StaticIntConstraint
  Constraint
  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(extend-type StaticStrConstraint
  Constraint
  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(def Constraints (comp AllValues
                       NoValues
                       MultiConstraint
                       SymbolConstraints))

(extend-type Constraints
  Composition
  (comp* [mc cs]
    (reduce cs mc intersect)))

(extend-type MultiConstraint
  Constraint
  (satisfied-by [c info]
    (let [type-map (extract-type-map c)]
      (or (flat-map type-map
                    (fn [type-map]
                      (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                    info)))
          (and (= nothing type-map)
               (every (.constraints c)
                      (fn [inner-c]
                        (satisfied-by inner-c info)))))))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (or (some (.constraints constraint)
                           (partial instance? StaticConstraints))
                     (satisfied-by constraint value-info))
                 (maybe ""))
            (do
              ;; TODO: minimize the runtime checks
              (map (.constraints constraint)
                   (fn [c]
                     (runtime-check c value-info file-name line-number))))))

  (extract-type-map [mc]
    (reduce (.constraints mc) nothing
            (fn [type-map c]
              (or (map type-map (partial restrict-types c))
                  (extract-type-map c)))))

  (extract-items-constraints [mc]
    (-> (.constraints mc)
        (filter (partial instance? ItemsConstraint))
        (map .items-constraints)
        ((fn [ls]
           (let [max-len (reduce ls 0 (fn [max l]
                                        (either (> (count l) max)
                                                max)))]
             (map ls (fn [l]
                       (either (and (< (count l) max-len)
                                    (maybe (comp l (repeat (- max-len (count l))
                                                           top-type))))
                               l))))))
        (list-zipper empty-list)
        (map (fn [[c & cs]] (comp* c cs)))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number))))))


(defprotocol C-Code
  (expr-constraints [expr]
    (assert-result x (instance? Constraints x)))
  (collapse-expressions* [x y]))

(defn expr-type-num [expr]
  (either (-> expr
              expr-constraints
              extract-type-map
              (flat-map (fn [type-map]
                          (let [type-nums (keys type-map)]
                            (and (= 1 (count type-nums))
                                 (first type-nums))))))
          UnknownType))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; refs-map: map of C variables that are used in 'init' and how many times

(deftype empty-code [c-var init decl refs-map constraints]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def empty-c-code (empty-code "" [] [] {} {}))

(defn conflicting-assertions [constraints file-name line-number]
  (apply print-err "Conflicting assertions"
         (either (= "" file-name)
                 (str " at " file-name ": " line-number))
         "\n"
         (format-path (MultiConstraint constraints) 0))
  (abort))

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (comp* x (list y))]
    (and (= bottom-type z)
         (let [constraints (either (and (< 1 (count (.constraints z)))
                                        (maybe (.constraints z)))
                                   [x y])]
           (maybe (conflicting-assertions constraints file-name line-number))))
    z))

(deftype c-code [c-var init decl refs-map constraints]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c]
    (and (empty? init)
         (empty? decl)
         (empty? constraints)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but defines a function parameter
(deftype c-param [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? ast/SymbolOrString c-var))
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Param " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def C-expr (comp empty-code
                  c-code
                  c-param
                  c-init))

(defn add-constraint [expr constraint file-name line-number]
  (let [constraints (either (get-in expr [.constraints (.c-var expr)])
                            top-type)]
    (.constraints expr {(.c-var expr) (compose-constraints file-name line-number constraints constraint)})))

(extend-type empty-code
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (comp* y (rest xs))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    y))

(extend-type c-param
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (collapse-expressions* x y))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [init (either (or (for [refs (get-in y [.refs-map (.c-var x)])]
                             [(.init x)
                              (either (and (< refs 2)
                                           (maybe ""))
                                      ["incRef(" (.c-var x) ", " (dec refs) ");" line-sep])
                              (.init y)])
                           (and (= "" (.c-var x))
                                (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" (.c-var x) ", 1);" line-sep
                        (.init y)])
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           (.c-var x))
          refs-map (assoc refs-map (.c-var x) 0)]
      (c-code (.c-var y)
              init [(.decl x) (.decl y)] refs-map
              (merge-with (partial compose-constraints (.file-name x) (.line-number x))
                          (.constraints x) (.constraints y))))))

(extend-type c-init
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))]
                     (collapse-expressions* x y))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          init [(.init x)
                (either (for [constraint (get (.constraints y) c-var)
                              value-info (or (get (.constraints x) c-var)
                                             (maybe top-type))]
                          (-> constraint
                              (update-var c-var)
                              (runtime-check value-info file-name line-number)))
                        "")
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [((< refs 2) "" ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          constraints-map (merge-with (partial compose-constraints file-name line-number)
                                      (.constraints x) (.constraints y))]
      (-> y
          (.init init)
          (.decl [(.decl x) (.decl y)])
          (.refs-map refs-map)
          (.constraints constraints-map)))))

(extend-type c-code
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (-> y
                         (.init [(.init x) (.init y)])
                         (.decl [(.decl x) (.decl y)])
                         (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
                         (.constraints (merge-with comp (.constraints x) (.constraints y)))))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [x (either (and (empty? (.init x))
                         (maybe (.refs-map x {})))
                    x)]
      (-> y
          (.init [(.init x) (.init y)])
          (.decl [(.decl x) (.decl y)])
          (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
          (.constraints (merge-with comp (.constraints x) (.constraints y)))))))

(defn collapse-expressions [cs]
  (either (or (and (empty? cs)
                   (maybe empty-c-code))
              (and (empty? (rest cs))
                   (first cs)))
          (let [[c & cs] cs]
            (collapse-expressions* c (collapse-expressions cs)))))

(deftype Closures [closures refs-map constraints]
  (assert (instance? Vector closures))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints)))

(def empty-closures (Closures [] {} {}))

(deftype ConstantValues [numbers strings symbols type-names]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names)))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count syms context-syms closed-over]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  ;;                    hash-map from Symbol to SymbolInfo
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types declarations]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; proto-fns        map of protocol fn symbols to fn information
  (assert (instance? HashMap proto-fns))
  ;; types            map of type symbols to type definitions
  (assert (instance? HashMap types))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [fn-context rt-init modules fns namespaces constants reify-fn-index type-maps]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit rt-init))
  ;; modules                info for each module compiled
  (assert (instance? HashMap modules))
  ;; fns                    static functions
  (assert (instance? HashMap fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))

  Stringable
  (string-list [_] (list "<GlobalContext>")))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      new-context (comp (-> curr-fn-context .context-syms)
                                        (-> curr-fn-context .syms))]
                  (maybe [curr-fn-context
                          (.fn-context s (FunctionArityContext {} 0 {} new-context empty-closures))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.fn-context s) (.fn-context s new-fn-context)])))))

(defn extract-sym-path [s sym]
  (let [file-name (ast/file-name sym)]
    (flat-map (rdr/namespace sym)
              (fn [ns-sym]
                (or (get-in (.namespaces s) [file-name ns-sym])
                    (get-in (.namespaces s) [file-name (rdr/tag ns-sym)]))))))

(defn sym-ns-path [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (map (extract-sym-path s sym) (fn [path]
                                                   [path s]))
                   (maybe [(ast/file-name sym) s])))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (sm/new-sm (fn [s]
                     (assert (instance? GlobalContext s))
                     (-> (.modules s)
                         (get (ast/file-name proto-sym))
                         (flat-map (fn [module]
                                     (map (get (.protocols module) proto-sym)
                                          (fn [proto-info]
                                            (print-err  "Duplicate protocol"
                                                        (str "'" proto-sym "'") "at"
                                                        (str (ast/file-name proto-sym) ":")
                                                        (ast/line-number proto-sym))
                                            (abort))))))))
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [path (either (extract-sym-path s proto-sym)
                                      (ast/file-name proto-sym))]
                     (for [proto-info (-> (.modules s)
                                          (get path)
                                          (flat-map (fn [module]
                                                      (get (.protocols module) proto-sym))))]
                       [proto-info s]))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.protocols module) proto-sym))))]
                     [proto-info s])))))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  (assert (instance? Tagged fn-sym))
  (assert (instance? Symbol disp-sym))
  (assert (instance? HashMap dispatchers))

  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (sm/new-sm (fn [s]
                     (assert (instance? GlobalContext s))
                     (-> (.modules s)
                         (get (ast/file-name fn-sym))
                         (flat-map (fn [module]
                                     (map (get (.proto-fns module) fn-sym)
                                          (fn [proto-info]
                                            (print-err "Duplicate protocol function"
                                                       (str "'" fn-sym "'") "at"
                                                       (str (ast/file-name fn-sym) ":")
                                                       (ast/line-number fn-sym))
                                            (abort))))))))
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (and (-> (.modules s)
                        (get path)
                        (flat-map (fn [module]
                                    (get (.proto-fns module) fn-sym))))
                    (maybe [path s])))))

(defn find-protocol-path [fn-sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [namespace (either (extract-sym-path s fn-sym)
                                           (ast/file-name fn-sym))]
                     (and (-> (.modules s)
                              (get namespace)
                              (flat-map (fn [module]
                                          (get (.proto-fns module) fn-sym))))
                          (maybe [namespace s])))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.proto-fns module) fn-sym))))]
                     ['core s])))))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym return-assertions return-constraint
                             param-constraints type-impls]
  (assert (instance? Integer arg-count))
  (assert (instance? Symbol dispatch-sym))
  (assert (instance? Symbol impls-sym))
  (assert (instance? Vector return-assertions))
  (assert (instance? Constraints return-constraint))
  (assert (instance? ItemsConstraint param-constraints))
  (assert (instance? HashMap type-impls))

  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) " " (str return-constraint) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym return-assertions
                            return-constraint param-constraints]
  (assert (instance? ItemsConstraint param-constraints))
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym return-assertions
                                       return-constraint param-constraints {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [namespace (either (extract-sym-path s fn-sym)
                                           (ast/file-name fn-sym))]
                     (for [module (get (.modules s) namespace)
                           proto-fn (get (.proto-fns module) fn-sym)
                           dispatcher (get (.dispatchers proto-fn) num-args)]
                       [dispatcher s]))
                   (for [module (get (.modules s) 'core)
                         proto-fn (get (.proto-fns module) fn-sym)
                         dispatcher (get (.dispatchers proto-fn) num-args)]
                     [dispatcher s])))))

(defn get-proto-impls-sym [fn-sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [namespace (either (extract-sym-path s fn-sym)
                                           (ast/file-name fn-sym))]
                     (for [module (get (.modules s) namespace)
                           proto-fn (get (.proto-fns module) fn-sym)
                           dispatcher (get (.dispatchers proto-fn) num-args)
                           impls-sym (get dispatcher .impls-sym)]
                       [impls-sym s]))
                   (for [module (get (.modules s) 'core)
                         proto-fn (get (.proto-fns module) fn-sym)
                         dispatcher (get (.dispatchers proto-fn) num-args)
                         impls-sym (get dispatcher .impls-sym)]
                     [impls-sym s])))))

(deftype ProtoImpl [dispatch-type c-var ast]
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/SymbolOrString c-var))

  Stringable
  (string-list [_] (list "<ProtoImpl type: " (target-type-name dispatch-type) " " (str c-var) ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type var ast]
  (assert (instance? Integer dispatch-type))
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type var ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [proto-path (either (extract-sym-path s fn-name)
                                            (ast/file-name fn-name))]
                     (for [module (get (.modules s) proto-path)
                           proto-fn (get (.proto-fns module) fn-name)
                           dispatcher (get (.dispatchers proto-fn) arg-count)
                           impl-info (get (.type-impls dispatcher) type-num)]
                       [impl-info s]))
                   (for [module (get (.modules s) 'core)
                         proto-fn (get (.proto-fns module) fn-name)
                         dispatcher (get (.dispatchers proto-fn) arg-count)
                         impl-info (get (.type-impls dispatcher) type-num)]
                     [impl-info s])))))


(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str start (seq remaining)))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (either (check-C-var (str sym "_"))
                                       arg-name)
                               sym-count)
                          new-ctxt]))))))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(deftype ParamBinding [vars destruct]
  (assert (instance? Vector vars))
  (assert (instance? Vector destruct))

  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (vec (cons x xs))]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn traverse [asts f]
  (assert-result x (instance? sm/new-sm x))

  ;; TODO: use a vector instead
  (reduce (reverse asts) (sm/state-maybe empty-list)
            (fn [l ast]
              (flat-map (f ast)
                        (fn [emitted]
                          (map l (fn [x]
                                   (cons emitted x))))))))

(extend-type List
  Emitter
  (tail-call [asts args result-constraint]
    (let [asts (reverse asts)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args result-constraint)
                    (cons init)
                    reverse))))))

(extend-type Vector
  Emitter
  (tail-call [asts params result-constraint]
    (extract (or (empty? asts)
                 (flat-map (last asts)
                           (fn [tail]
                             (store asts (dec (count asts))
                                    (tail-call tail params result-constraint))))))))

;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name] (sm/state-maybe (gensym arg-name)))
  ([sym arg-name]
   (sm/state-maybe (gensym (either (check-C-var (str sym "_"))
                                   arg-name)))))


(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.modules s)
                   (get (ast/file-name sym))
                   (flat-map (fn [module]
                               (map (get-in (.declarations module) [sym '_])
                                    (fn [expr]
                                      [expr s]))))))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn get-sym [sym]
  (flat-map get-syms (fn [syms]
                       (sm/when (get syms sym)))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

;; This is so hideous on purpose. It's called *A LOT* so I unwound it for performance's sake
(defn lookup-sym [sym]
  (let [sym-file (ast/file-name sym)]
    (comp (sm/new-sm
           (fn [s]
             (assert (instance? GlobalContext s))
             (let [ctxt (.fn-context s)
                   syms (.syms ctxt)
                   modules (.modules s)
                   closed-over (.closed-over ctxt)
                   closures (.closures closed-over)
                   refs-map (.refs-map closed-over)]
               (or (map (or (and (rdr/namespace sym)
                                 (or (-> (flat-map (extract-sym-path s sym)
                                                   (partial get modules))
                                         (flat-map (fn [module]
                                                     (let [values (.values module)]
                                                       (or (get values (.base sym))
                                                           (get values (rdr/tag (.base sym))))))))
                                     (do
                                       (print-err "Undefined symbol" (str "'" sym "'") "at"
                                                  (str sym-file ":")
                                                  (ast/line-number sym))
                                       (maybe (abort)))))
                            (get syms sym))
                        (fn [expr]
                          [expr s]))
                   (map (-> ctxt .context-syms (get sym))
                        (fn [sym-info]
                          (either (some closures
                                        (fn [[closure-var sym-literal]]
                                          (and (= sym sym-literal)
                                               (map (get refs-map closure-var)
                                                    (fn [refs-count]
                                                      (let [new-refs-map (assoc refs-map closure-var (inc refs-count))
                                                            new-closed-over (.refs-map closed-over new-refs-map)
                                                            new-ctxt (.closed-over ctxt new-closed-over)]
                                                        [(c-code closure-var [] [] {closure-var 1}
                                                                 {closure-var (expr-constraints sym-info)})
                                                         (.fn-context s new-ctxt)]))))))
                                  (let [sym-count (.sym-count ctxt)
                                        closure-var (str "val" sym-count)
                                        new-sym-count (inc sym-count)
                                        new-closures (conj closures [closure-var sym (expr-constraints sym-info)])
                                        new-refs-map (assoc refs-map closure-var 1)
                                        new-closed-over (-> closed-over
                                                            (.closures new-closures)
                                                            (.refs-map new-refs-map))
                                        new-ctxt (-> ctxt
                                                     (.sym-count new-sym-count)
                                                     (.closed-over new-closed-over))]
                                    [(c-code closure-var [] [] {closure-var 1}
                                             {closure-var (expr-constraints sym-info)})
                                     (.fn-context s new-ctxt)]))))
                   (map (or (flat-map (get modules sym-file)
                                      (fn [module]
                                        (or (get (.values module) sym)
                                            (get-in (.declarations module) [sym '_]))))
                            (flat-map (get modules 'core)
                                      (fn [module]
                                        (get (.values module) sym))))
                        (fn [expr] [expr s]))
                   (do
                     (print-err "Undefined symbol" (str "'" sym "'") "at"
                                (str sym-file ":")
                                (ast/line-number sym))
                     (abort)))))))))

(extend-type SymbolConstraints
  Emitter
  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (for [sym-info (lookup-sym sym)
                         :let [var (.constraints sym-info (merge-with (partial compose-constraints "" 0)
                                                                      (.constraints sym-info)
                                                                      {(.c-var sym-info)
                                                                       (update-var constraint (.c-var sym-info))}))]
                         _ (set-sym sym var)]
                     (.refs-map var (dissoc (.refs-map sym-info) (.c-var sym-info))))))
            (sm/state-maybe empty-c-code))))

(extend-type MultiConstraint
  Emitter
  (emit [constraint]
    (map (traverse (.constraints constraint) emit)
         (fn [[expr & exprs]]
           (comp* expr exprs)))))

(extend-type AllValues
  Emitter
  (emit [constraint]
    (sm/state-maybe empty-c-code)))

(deftype StaticArityInfo [c-info param-constraints]
  (assert (instance? C-expr c-info))
  (assert (instance? ItemsConstraint param-constraints)))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.fns s)
                   (get-in [fn-var num-params .c-info])
                   (map (fn [expr]
                          [expr s]))))))

(defn lookup-static-constraints [fn-var num-params]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [(either (get-in (.fns s) [fn-var num-params .param-constraints])
                               [])
                       s]))))

(defn lookup-core-fn-arity [sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [module (get (.modules s) 'core)
                     fn-sym (get (.values module) sym)
                     expr (get-in (.fns s) [(.c-var fn-sym) num-args .c-info])]
                 [expr s]))))


(extend-type ast/block-comment-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] {} {})))

  (emit-defined-value [_ x] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe []))

  (tail-call [ast params result-constraint] ast))

(defn make-static-string [str-val]
  ;; TODO: when adding meta data, make sure to update this as well
  (let [str-len (count str-val)]
    (for [str-idx (sm/new-sm (fn [s]
                               (assert (instance? GlobalContext s))
                               (-> s
                                   .constants
                                   .strings
                                   count
                                   (vector s)
                                   maybe)))
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.constants .strings str-val]
                             (c-code str-ptr [] [] {}
                                     {str-ptr (TypeConstraint {StringBufferType #{}} empty-list
                                                              'String nothing str-ptr)}))]
      (c-init str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringBufferType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              {} {str-ptr (TypeConstraint {StringBufferType #{}} empty-list 'String nothing str-ptr)}
              "" 0))))

(defn make-c-code [value]
  (c-code (.c-var value) (.init value) (.decl value)
          (.refs-map value) (.constraints value)))

(defn get-type-info [path type-symbol]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [modules (.modules s)]
                 (for [type-num (or (flat-map (get modules path)
                                              (fn [module]
                                                (get (.types module) type-symbol)))
                                    (flat-map (get modules 'core)
                                              (fn [module]
                                                (get (.types module) type-symbol))))
                       type-map (get-in s [.type-maps type-num .type-map])]
                   [type-map s])))))

(defn get-type-sym-info [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-info (get-type-info ns-path type-symbol)]
          type-info)
        (sm/state-maybe {})))

(defn type-constraint [type-num file-name line-number]
  (comp (for [type-info (sm/get-in-val [.type-maps type-num])]
          (either (and (empty? (.type-map type-info))
                       (maybe top-type))
                  (-> (.type-map type-info)
                      (TypeConstraint empty-list (.sym type-info) nothing "")
                      (update-path file-name line-number))))
        (sm/state-maybe top-type)))

(defn get-type-numbers [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-info ns-path type-symbol)]
          (set (keys type-nums)))
        (sm/state-maybe #{})))

(defn get-type-number [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-info ns-path type-symbol)]
          (either (and (= 1 (count type-nums))
                       (first (keys type-nums)))
                  UnknownType))
        (sm/state-maybe UnknownType)))

;; TODO: only used in commented code
;; (defn get-asserted-types [type-symbol file-name line-number]
;;   (comp (for [ns-path (sym-ns-path type-symbol)
;;               type-nums (get-type-info ns-path type-symbol)]
;;           (set (keys type-nums)))
;;         (compilation-error "Unknown type"
;;                            (str "'" type-symbol "'")
;;                            "in assertion at"
;;                            (str file-name ":")
;;                            line-number)))

;; TODO: line numbering starts to go wrong here

(extend-type ast/assert-ast
  Assertion
  (assertion? [ast]
    (maybe ast))

  (assert-type [ast]
    (assert-type (.assertion ast)))

  Emitter
  (replace-bound-vars [ast subs]
    (ast/assert-ast (replace-bound-vars (.assertion ast) subs)))

  (replace-syms [ast subs]
    (map (replace-syms (.assertion ast) subs)
         (fn [assertion]
           (ast/assert-ast assertion))))

  (produces-code? [ast]
    nothing)

  (emit [ast]
    (-> (.assertion ast)
        (update-path (ast/file-name ast) (ast/line-number ast))
        emit))

  (tail-call [ast params result-constraint] ast))


(extend-type ast/type-assertion
  Emitter
  (replace-bound-vars [ast subs]
    (.sym ast (either (get subs (.sym ast))
                      (.sym ast))))

  (replace-syms [ast subs]
    (sm/state-maybe (.sym ast (either (get subs (.sym ast))
                                      (.sym ast)))))

  (to-constraint [ast]
    (let [sym (.type-sym ast)
          file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (comp (map (get-type-sym-info (maybe sym))
                 (fn [type-info]
                   (either (and (empty? type-info)
                                (maybe top-type))
                           (-> type-info
                               (TypeConstraint empty-list sym nothing "")
                               (update-path file-name line-number)))))
            (sm/state-maybe top-type))))

  (emit [ast]
    (for [constraint (to-constraint ast)
          constraint (constrain-sym (.sym ast) constraint)
          var (lookup-sym (.sym ast))]
      (c-code "" [] [] {} (.constraints var))))

  ;; Ooof. so having this as the last thing in the previous 'emit' impl' causes an incRef error
    ;; TODO:  move this to the c-init comp* fn
  ;; (for [type-nums (get-asserted-types (.type-sym ast) (ast/file-name ast) (ast/line-number ast))
  ;;       var (lookup-sym (.sym ast))]
  ;;   (c-code ""
  ;;           ["switch (" (.c-var var) "->type) {" line-sep
  ;;            (map (seq type-nums) (fn [type-num]
  ;;                                   ["case " type-num ": " line-sep]))
  ;;            "break;" line-sep " default: " line-sep
  ;;            "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
  ;;            (ast/file-name ast) "\"," (ast/line-number ast)
  ;;            ");" line-sep
  ;;            "fprintf(stderr, \"Expected %s, got %s\\n\", \""
  ;;            (str (.type-sym ast)) "\", extractStr(type_name(empty_list, " (.c-var var)
  ;;            ")));" line-sep
  ;;            "abort();" line-sep
  ;;            "}" line-sep]
  ;;           [] UnknownType {} {}))


  Assertion
  (assert-type [ast]
    (maybe (.type-sym ast))))

(extend-type ast/min-count-assertion
  Emitter
  (to-constraint [ast]
    (sm/state-maybe (ItemsConstraint (repeat (.len ast) top-type)
                                     (list [(ast/file-name ast) (ast/line-number ast)])
                                     nothing
                                     "")))

  (emit [ast]
    (for [var (lookup-sym (.sym ast))
          constraint (to-constraint ast)]
      (c-code "" [] [] {}
              {(.c-var var) (-> constraint
                                (update-var (.c-var var))
                                (update-sym (.sym ast)))}))))

(extend-type ast/result-ast
  Assertion
  (return-assertion? [ast] (maybe ast))

  (assert-return-type [ast]
    (for [type-sym (assert-type (.assertion ast))
          _ (= (.sym ast) (.sym (.assertion ast)))]
      type-sym))

  Emitter
  (produces-code? [ast] nothing)

  (to-constraint [ast]
    (to-constraint (.assertion ast)))

  (emit [ast]
    (sm/state-maybe empty-c-code))

  (tail-call [ast params result-constraint] ast))

(defn emit-tail-expr [ast result-constraint expr]
  (do
    ;; TODO: periodically enable this to check on things
    ;; (print-err 'check (some return-assertions assert-return-type) return-type
    ;;            (ast/file-name ast) (ast/line-number ast))
    (merge-with (partial compose-constraints "" 0)
                (.constraints expr)
                {(.c-var expr) result-constraint})
    (collapse-expressions [expr
                           (c-code (.c-var expr)
                                   ["return(" (.c-var expr) ");" line-sep]
                                   [] {(.c-var expr) 1}
                                   {(.c-var expr) result-constraint})])))

(deftype TailCall [ast params result-constraint]
  (assert (instance? Vector params))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) " " (string-list result-constraint) " "
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))
  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (or (instance? Symbol (.call-target ast))
                                    (instance? rdr/tagged-symbol (.call-target ast)))))
                target (emit (.call-target ast))
                _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (filter produces-code?)
                         (traverse emit))
                line (line-macro ast "// recursive-fixed")]
            (comp* empty-c-code (comp args
                                      [(c-code ""
                                               [line
                                                (map (zip-lists params (map args .c-var))
                                                     (fn [[param arg]]
                                                       [param " = " arg ";" line-sep]))]
                                               [] {} {})])))
          (map (emit ast)
               (fn [expr]
                 (let [expr (either (and (instance? Tagged ast)
                                         (maybe (.refs-map expr {})))
                                    expr)]
                   (emit-tail-expr ast result-constraint expr)))))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.constants .strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                (.constraints value)))]
      [(make-c-code value)]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint)))


(defn make-static-num [num]
  (for [num-idx (sm/new-sm (fn [s]
                               (assert (instance? GlobalContext s))
                               (-> s
                                   .constants
                                   .numbers
                                   count
                                   (vector s)
                                   maybe)))
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-code num-ptr [] [] {}
                                   {num-ptr (TypeConstraint {IntegerType #{}} empty-list 'Integer nothing
                                                            num-ptr)}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            {} {num-ptr (TypeConstraint {IntegerType #{}} empty-list 'Integer nothing
                                        num-ptr)}
            "" 0)))

(extend-type Integer
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                (.constraints value)))]
      [(make-c-code value)]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint)))


(extend-type ast/quoted-ast
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)
                        constraint (update-path sym-constraint
                                                (ast/file-name ast) (ast/line-number ast))]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-code sym-ptr [] [] {}
                                             {sym-ptr constraint}))]
              (c-code sym-ptr
                      []
                      ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                       ", 0, 0, \"" sym "\"};\n"
                       "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                      {} {sym-ptr constraint})))))

  (emit-defined-value [ast defined-sym]
    (for [quoted (emit ast)
          _ (new-module-def defined-sym (c-code (.c-var quoted) [] [] {}
                                                {(.c-var quoted) (update-path sym-constraint
                                                                              (ast/file-name ast)
                                                                              (ast/line-number ast))}))]
      [(make-c-code quoted)]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint)))


(def vect-constraint (TypeConstraint {VectorType #{}} empty-list 'Vector nothing ""))

(defn call-vector [target args arg-asts]
  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [_ (sm/when (= target 'vector))
          vect-sym (genlocal "newVect")
          result-sym (genlocal "rslt")
          line (line-macro target "// call-vector")]
      (let [arg-constraints (.constraints (collapse-expressions args))
            constraints (comp vect-constraint
                              (StaticLengthConstraint (count args)
                                                      empty-list
                                                      nothing
                                                      result-sym)
                              (ItemsConstraint (map args (fn [arg]
                                                           (either (get arg-constraints (.c-var arg))
                                                                   top-type)))
                                               empty-list
                                               nothing
                                               result-sym))]
        (comp* empty-c-code
               (comp args
                     [(c-init result-sym
                              [line
                               "Vector *" vect-sym " = empty_vect;" line-sep
                               (map args
                                    (fn [arg]
                                      (let [arg-sym (.c-var arg)]
                                        [vect-sym " = mutateVectConj(" vect-sym ", "
                                         arg-sym ");" line-sep])))
                               "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
                              [] {}
                              {result-sym (update-path constraints file-name line-number)}
                              file-name line-number)]))))))

(def list-constraint (TypeConstraint {ListType #{}} empty-list 'List nothing ""))

(defn call-list [target args arg-asts]
  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [_ (sm/when (= target 'list))
          line (line-macro target "// call-list")
          list-sym (genlocal "newList")
          result-sym (genlocal "rslt")]
      (let [arg-constraints (.constraints (collapse-expressions args))
            constraints (comp list-constraint
                              (StaticLengthConstraint (count args)
                                                      empty-list
                                                      nothing
                                                      result-sym)
                              (ItemsConstraint (map args (fn [arg]
                                                           (either (get arg-constraints (.c-var arg))
                                                                   top-type)))
                                               empty-list
                                               nothing
                                               result-sym))]
        (comp* empty-c-code
               (comp args
                     [(c-init result-sym
                              [line "List *" list-sym " = empty_list;" line-sep
                               (map (reverse args)
                                    (fn [arg]
                                      (let [arg-sym (.c-var arg)]
                                        [list-sym " = listCons(" "(Value *)" arg-sym
                                         ", " list-sym ");" line-sep])))
                               "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
                              [] {}
                              {result-sym (update-path constraints file-name line-number)}
                              file-name line-number)]))))))

(defn arg-constraints [arg-asts arg-vars constraints file-name line-number]
  (assert (instance? ItemsConstraint constraints))

  (for [constraint-maps (traverse (zip-lists (seq arg-asts)
                                             (seq arg-vars)
                                             (.items-constraints constraints))
                                  (fn [[ast var constraint]]
                                    (let [constraint (update-path constraint file-name line-number)
                                          new-const (compose-constraints file-name line-number
                                                                         constraint
                                                                         (update-path (expr-constraints var)
                                                                                      file-name line-number))]
                                      (comp (for [_ (constrain-sym ast constraint)]
                                              {(.c-var var) new-const})
                                            (sm/state-maybe {(.c-var var) new-const})))))]
    (comp* {} constraint-maps)))

(defn dispatch-type-known [target args ast]
  (either (for [dispatch-val (first args)]
            (let [num-args (count args)]
              (for [impl-info (get-proto-impl target num-args (expr-type-num dispatch-val))
                    arity-info (lookup-static-arity (.c-var impl-info) num-args)
                    constraints (lookup-static-constraints (.c-var impl-info) num-args)
                    constraints (arg-constraints (.args ast) args constraints
                                                 (ast/file-name ast) (ast/line-number ast))
                    ;; _ (comp (sm/update-in-val [.other 'type-known-sites] inc)
                    ;;         (sm/assoc-in-val [.other 'type-known-sites] 1))
                    result-var (genlocal "rslt")
                    line (line-macro target (str "// type-known for " target))]
                (comp* empty-c-code
                       (comp args
                             [(c-init result-var
                                      [line "Value *" result-var " = " (.c-var arity-info) "("
                                       (interpose (conj (map args .c-var) "empty_list")
                                                  ", ")
                                       ");" line-sep]
                                      [] {}
                                      (assoc constraints
                                        result-var (expr-constraints arity-info))
                                      (ast/file-name ast) (ast/line-number ast))])))))
          (zero sm/state-maybe)))

(defn dispatch-type-unknown [target args ast]
  (let [num-args (count args)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [disp-info (get-protocol-dispatcher target num-args)
          ;; _ (comp (sm/when (or (= (ast/file-name target) 'core)))
          ;;         (sm/update-in-val [.other 'type-unknown-sites] inc)
          ;;         (sm/assoc-in-val [.other 'type-unknown-sites] 1))
          result-var (genlocal "rslt")
          constraints (arg-constraints (.args ast) args (.param-constraints disp-info)
                                       file-name line-number)
          line (comp (map (sm/when (or (= (ast/file-name target) 'core)))
                          (fn [_] ""))
                     (line-macro target (str "// type-unknown " target)))
          field-constraint (comp (for [expr (sm/when (and (= "." (subs (str target) 0 1))
                                                          (first args)))
                                       dispatch-var (sm/get-in-val [.modules 'core .proto-fns target .disp-sym])]
                                   (let [fc (FieldConstraint target
                                                             dispatch-var
                                                             (list [file-name line-number])
                                                             nothing
                                                             result-var)]
                                     (either (and (= 2 num-args)
                                                  (maybe {(.c-var expr) fc
                                                          result-var (comp fc (expr-constraints expr))}))
                                             {(.c-var expr) fc})))
                                 (sm/state-maybe {}))]
      (comp* empty-c-code
             (comp args
                   [(c-init result-var
                            [line "Value *" result-var " = proto" num-args "Arg(&"
                             (.impls-sym disp-info)
                             ", \"" (.sym target) "\", "
                             (interpose (comp (map args .c-var)
                                              [(str "\"" (.file-name target) "\"")
                                               (ast/line-number target)])
                                        ", ")
                             ");" line-sep]
                            [] {}
                            (assoc (merge-with (partial compose-constraints file-name line-number)
                                               field-constraint
                                               constraints)
                              result-var (.return-constraint disp-info))
                            file-name line-number)])))))

(defn call-proto-impl [name args ast]
  (for [_ (sm/when (< 0 (count args)))
        call-info (comp (dispatch-type-known name args ast)
                        (dispatch-type-unknown name args ast))]
    call-info))

(defn inline-wrap-and-apply* [name args]
  ;; TODO: this is subtly broken in replacing syms/bound-vars. It breaks on:
  ;; (for [name (list 1 2 3 4)
  ;;       :let [name (str name)]
  ;;       :when-not (= "." (subs name 0 1))]
  ;;   name)

  ;; (let [[dispatch-ast & arg-asts] args]
  ;;   (for [dispatch-val (emit dispatch-ast)
  ;;         impl-ast (map (get-proto-impl name (count args)
  ;;                                       (expr-type-num dispatch-val))
  ;;                       .ast)
  ;;         expr (-> impl-ast
  ;;                  (replace-bound-vars {})
  ;;                  (inline-expr (cons dispatch-val arg-asts)))]
  ;;     expr))
  (zero sm/state-maybe)
  )


(defn inline-flat-map [name args]
  (let [[dispatch-ast f-ast] args]
    (for [dispatch-val (emit dispatch-ast)
          impl-ast (map (get-proto-impl name 2 (expr-type-num dispatch-val))
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (traverse (.body impl-ast)
                               (fn [ast]
                                 (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(extend-type rdr/tagged-symbol
  Emitter
  (constrain-sym [sym constraint]
    (for [var (sm/get-in-val [.fn-context .syms sym])
          :let [constraint (-> (compose-constraints (ast/file-name sym) (ast/line-number sym)
                                                    constraint (expr-constraints var))
                               (update-var (str (.c-var var)))
                               (update-sym sym))
                type-num (either (for [type-nums (extract-type-map constraint)
                                       :when (= 1 (count type-nums))
                                       type-num (first (keys type-nums))]
                                   type-num)
                                 UnknownType)]
          _ (set-sym sym (-> var
                             (.constraints {(.c-var var) constraint})))]
      constraint))

  (get-param-constraints [sym constraint-map]
    (for [expr (lookup-sym sym)]
      (-> (either (get constraint-map (.c-var expr))
                  top-type)
          (update-var (.c-var expr))
          (update-sym sym))))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] {arg-var 1} {})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                constraint (expr-constraints evalled)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.constraints (assoc (.constraints evalled)
                                            arg-var constraint))
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] []
                                    {(.c-var evalled) 1}
                                    {(.c-var evalled) constraint})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [(c-init (.c-var evalled) (.init evalled) (.decl evalled)
                                     (.refs-map evalled)
                                     (.constraints evalled)
                                     (ast/file-name binding) (ast/line-number binding))]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (new-module-def defined-sym value)]
      [(make-c-code value)]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (emit-call-expr [target-ast args call-expr-ast]
    (comp (call-vector target-ast args (.args call-expr-ast))
          (call-list target-ast args (.args call-expr-ast))
          (call-proto-impl target-ast args call-expr-ast)))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)
          num-args (count args)]
      (either (or (and (< 0 num-args)
                       (or (= name 'wrap)
                           (= name 'apply*))
                       (maybe (inline-wrap-and-apply* name args)))
                  (and (= 2 num-args)
                       (or (= name 'flat-map)
                           (= name 'map))
                       (maybe (inline-flat-map name args))))
              (zero sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type Symbol
  Emitter
  (constrain-sym [sym constraint]
    (for [var (sm/get-in-val [.fn-context .syms sym])
          :let [constraint (-> (compose-constraints (ast/file-name sym) (ast/line-number sym)
                                                    constraint (expr-constraints var))
                               (update-var (str (.c-var var)))
                               (update-sym sym))
                type-num (either (for [type-nums (extract-type-map constraint)
                                       :when (= 1 (count type-nums))
                                       type-num (first (keys type-nums))]
                                   type-num)
                                 UnknownType)]
          _ (set-sym sym (-> var
                             (.constraints {(.c-var var) constraint})))]
      constraint))

  (get-param-constraints [sym constraint-map]
    (for [expr (lookup-sym sym)]
      (-> (either (get constraint-map (.c-var expr))
                  top-type)
          (update-var (.c-var expr))
          (update-sym sym))))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] {arg-var 1} {})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                constraint (expr-constraints evalled)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.constraints (assoc (.constraints evalled)
                                            arg-var constraint))
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] []
                                    {(.c-var evalled) 1}
                                    {(.c-var evalled) constraint})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [(c-init (.c-var evalled) (.init evalled) (.decl evalled)
                                     (.refs-map evalled)
                                     (.constraints evalled)
                                     (ast/file-name binding) (ast/line-number binding))]))))

  (emit [sym]
    (lookup-sym sym))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)
          num-args (count args)]
      (either (or (and (< 0 num-args)
                       (or (= name 'wrap)
                           (= name 'apply*))
                       (maybe (inline-wrap-and-apply* name args)))
                  (and (= 2 num-args)
                       (or (= name 'flat-map)
                           (= name 'map))
                       (maybe (inline-flat-map name args))))
              (zero sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          c-var (genlocal "rslt")
          type-num (get-type-number (.result-type ast))
          constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))
          line-info (line-macro ast "// inline")]
      (c-code c-var [line-info (.txt ast) "\n#\n"] [] {}
              {c-var constraint})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] [] {}
                                                {(str c-var) constraint}))
          line-info (line-macro ast "// inline")]
      [(c-code c-var [] [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"]
               {} {c-var constraint})]))

  (emit-definition [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] {} {})]))

  (tail-call [ast params result-constraint]
    ;; TODO: statically verify the return type, if possible
    ast)

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (traverse (.value-exprs ast) (fn [ast]
                                          (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] {} {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              [(-> c-info
                   (.c-var "")
                   (.decl ["Value *" c-var ";\n"]))])))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
          constraints (lookup-static-constraints (.c-var target) (count arg-vars))
          constraints (arg-constraints (.args ast) arg-vars constraints file-name line-number)
          result-sym (genlocal "rslt")
          ;; _ (comp (sm/update-in-val [.other 'static-fixed-sites] inc)
          ;;         (sm/assoc-in-val [.other 'static-fixed-sites] 1))
          line (line-macro ast "// static-fixed")]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (cons "empty_list" (seq (map arg-vars .c-var))) ", ") ");" line-sep]
              [] {} (assoc constraints
                      result-sym (expr-constraints arity-info))
              file-name line-number))))

(defn call-static-variadic [target arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-info (lookup-static-arity (.c-var target) 'variadic)
          constraints (lookup-static-constraints (.c-var target) 'variadic)
          arg-consts (arg-constraints (.args ast) arg-vars constraints file-name line-number)
          ;; _ (comp (sm/update-in-val [.other 'static-variadic-sites] inc)
          ;;         (sm/assoc-in-val [.other 'static-variadic-sites] 1))
          args-list (call-list (rdr/tag 'list file-name line-number)
                               (map arg-vars (fn [arg]
                                               (.init arg [])))
                               (.args ast))
          result-sym (genlocal "rslt")
          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               line
               "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
               (.c-var args-list) ");" line-sep]
              [] {}
              (assoc-all arg-consts
                         (.c-var args-list) (compose-constraints file-name line-number
                                                                 constraints (expr-constraints args-list))
                         result-sym (expr-constraints arity-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn call-dyn-fn-value [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (expr-type-num target))
        ;; _ (comp (sm/update-in-val [.other 'dyn-fn-sites] inc)
        ;;         (sm/assoc-in-val [.other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              [] {} {}
              (ast/file-name ast) (ast/line-number ast)))))

(def symbols-sym (symbol "#symbols"))
(def types-sym (symbol "#types"))
(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type))
(def Function-sym (rdr/tag 'Function))
(def Container-sym (rdr/tag 'Container))
(def Stringable-sym (rdr/tag 'Stringable))
(def type-name-sym (rdr/tag 'type-name))
(def =*-sym (rdr/tag '=*))
(def apply*-sym (rdr/tag 'apply*))
(def get-type-sym (rdr/tag 'reified-get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def new-type-value-sym (rdr/tag 'new-type-value))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative))
(def get-symb (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode))
(def Hashable-sym (rdr/tag 'Hashable))
(def sha1-sym (rdr/tag 'sha1))
(def sha1-update-sym (rdr/tag 'sha1-update))
(def sha1-init-sym (rdr/tag 'sha1-init))
(def sha1-finalize-sym (rdr/tag 'sha1-finalize))
(def sha1-update-type-sym (rdr/tag 'sha1-update-type))
(def assoc*-sym (rdr/tag 'assoc*))
(def make-value-sym (rdr/tag 'make-value))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [num-args (count args)
        num-invoke-args (inc num-args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (map (lookup-core-fn-arity invoke-sym num-invoke-args)
                                .c-var)
          impls-sym (get-proto-impls-sym invoke-sym num-invoke-args)
          ;; _ (comp (sm/update-in-val [.other 'dyn-unknown-sites] inc)
          ;;         (sm/assoc-in-val [.other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                 "FnArity *_arity = (FnArity *)findProtoImpl(" (.c-var target)
                 "->type, &" impls-sym ");" line-sep
                 "if(_arity == (FnArity *)0) {" line-sep
                 "fprintf(stderr, \"\\n*** No implementation of 'invoke' with "
                 (str num-invoke-args) " arguments for type: %s (%\" PRId64 \") at "
                 (ast/file-name ast) ": " (str (ast/line-number ast)) "\\n\"," line-sep
                 "extractStr(type_name(empty_list, " (.c-var target) ")), " (.c-var target)
                 "->type);" line-sep
                 "abort();" line-sep
                 "}" line-sep
                 "FnType" num-invoke-args " *_fn = (FnType" num-invoke-args
                 " *)_arity->fn;" line-sep

                 result-sym " = _fn(_arity->closures, "
                 (to-str (interpose (conj args (.c-var target)) ", "))
                 ");" line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                 line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                [] {} {}
                (ast/file-name ast) (ast/line-number ast))))))

(defn call-invoke [target args ast]
  (let [num-args (inc (count args))]
    (for [invoke-info (get-proto-impl invoke-sym num-args
                                      (expr-type-num target))
          arity-info (lookup-static-arity (.c-var invoke-info) num-args)
          ;; _ (comp (sm/update-in-val [.other 'invoke-sites] inc)
          ;;         (sm/assoc-in-val [.other 'invoke-sites] 1))
          constraints (lookup-static-constraints (.c-var invoke-info) num-args)
          constraints (arg-constraints (cons target (seq (.args ast)))
                                       (cons target args)
                                       constraints
                                       (ast/file-name ast) (ast/line-number ast))
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (conj (cons (.c-var target) (map args .c-var))
                                "empty_list") ", ") ");" line-sep]
              [] {} (assoc constraints
                      result-sym (expr-constraints arity-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (filter produces-code?)
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse
                vec))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    ((instance? Symbol target-ast)
                                     (rdr/tag target-ast)
                                     target-ast))))]
      (comp (for [new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.refs-map call-site)
                      (.constraints call-site)
                      (ast/file-name ast) (ast/line-number ast)))
            (flat-map (-> (.args ast)
                          (filter produces-code?)
                          (traverse emit))
                      (fn [args]
                        (comp (emit-call-expr (.call-target ast) args ast)
                              (for [target (emit (.call-target ast))
                                    call-site (comp (call-static-fixed target args ast)
                                                    (call-static-variadic target args ast)
                                                    (call-invoke target args ast)
                                                    (call-dyn-fn-value target (map args .c-var) ast)
                                                    (call-dyn-unknown-type target (map args .c-var) ast))]
                                (comp* target (comp args [call-site])))
                              (compilation-error "Could not compile call site at:"
                                                 file-name line-number)))))))

  (emit-defined-value [fn-val defined-sym]
    (comp (for [[type-sym type-syms] (sm/when (and (= (.call-target fn-val) 'comp*)
                                                   (maybe (.args fn-val))))
                ns-path (sym-ns-path type-sym)
                type-info (get-type-info ns-path type-sym)
                :when-not (empty? type-info)
                other-types-info (traverse (.args type-syms)
                                           (fn [sym]
                                             (for [ns-path (sym-ns-path sym)
                                                   type-info (get-type-info ns-path sym)
                                                   :when-not (empty? type-info)]
                                               type-info)))
                :let [all-types-info (comp* type-info other-types-info)
                      reified-type-num (extract rdr/type-counter)]
                _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                                   reified-type-num)
                _ (sm/assoc-in-val [.type-maps reified-type-num] (TypeInfo defined-sym all-types-info))
                expr (emit-defined-value
                      (ast/reified
                       reified-type-num
                       {Type-sym
                        [[instance?-sym
                          [(ast/fn-arity-ast
                            (str defined-sym "_instance_QMARK_") ""
                            (ast/params ['x 'y]) ""
                            [(ast/call-ast (rdr/tag 'some)
                                           [(ast/call-ast list-sym (vec (keys all-types-info)))
                                            (ast/call-ast (rdr/tag 'partial)
                                                          [=*-sym
                                                           (ast/call-ast get-type-sym ['y])])])])]]]})
                      defined-sym)]
            expr)
          (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
                fn-context (reset-fn-context init-fn-context)
                value (emit fn-val)
                var (comp (map (lookup-declaration defined-sym) .c-var)
                          (global-var defined-sym "var"))
                init-fn-context (reset-fn-context fn-context)
                _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
                _ (new-module-def defined-sym (c-code var [] [] {}
                                                      {var (expr-constraints value)}))]
            [(c-init var [(.init value)
                          var " = " (.c-var value) ";" line-sep
                          var "->refs = -1;" line-sep "\n#\n"]
                     [(.decl value) "Value *" var ";\n"]
                     (.refs-map value)
                     (.constraints value)
                     (ast/file-name fn-val) (ast/line-number fn-val))])))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (traverse (.args ast) (fn [ast]
                                       (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= (.call-target ast) 'new-sm))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))

  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? Vector l))
    [ast]))

(extend-type C-expr
  C-Code
  (expr-constraints [expr]
    (either (get (.constraints expr) (.c-var expr))
            top-type))

  Emitter
  (bind-list [list-var params]
    (let [file-name (ast/file-name params)
          line-num (ast/line-number params)
          list-constraint (update-path list-constraint file-name line-num)
          fixed-count (count (.fixed params))
          tail-sym (either (.variadic params)
                           (rdr/tag "#tail"))
          items-constraints (extract-items-constraints (expr-constraints list-var))
          list-var (.refs-map list-var (dissoc (.refs-map list-var) (.c-var list-var)))]
      (for [tail-binding (bind tail-sym)
            _ (comp (sm/when (empty? (.init list-var)))
                    (set-sym (.c-var list-var) list-var))
            _ (constrain-sym tail-sym list-constraint)
            :let [tail-var (-> tail-binding .vars first extract)]
            r (comp (sm/when (and (= 0 fixed-count)
                                  (maybe (ParamBinding [(.c-var list-var)]
                                                       [list-var
                                                        (c-init tail-var ["Value *" tail-var " = seq(empty_list, "
                                                                          (.c-var list-var) ");" line-sep]
                                                                [] {(.c-var list-var) 1}
                                                                {tail-var list-constraint}
                                                                file-name line-num)]))))
                    (for [dest-args (genlocal "destArgs")
                          fixed-bindings (map (traverse (.fixed params) bind) vec)
                          :let [fixed-vars (flat-map fixed-bindings .vars)
                                fixed-exprs (map fixed-vars (fn [var]
                                                              (c-init var [] [] {} {}
                                                                      file-name line-num)))
                                tail-expr (c-init tail-var [] [] {} {tail-var list-constraint}
                                                  file-name line-num)]
                          _ (traverse fixed-exprs (fn [expr]
                                                    (set-sym (.c-var expr) expr)))
                          _ (set-sym tail-var tail-expr)]
                      (ParamBinding [(.c-var list-var)]
                                    (comp [list-var
                                           (c-code ""
                                                   (destruct-seq (.c-var list-var)
                                                                 (conj fixed-vars tail-var)
                                                                 dest-args file-name line-num)
                                                   [] {(.c-var list-var) 1} {})]
                                          (conj fixed-exprs tail-expr)
                                          (flat-map fixed-bindings .destruct)
                                          (.destruct tail-binding)))))]
        r))))

(extend-type ast/params-ast
  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  Emitter
  (get-param-constraints [params constraint-map]
    (map (traverse (.fixed params) (fn [param]
                                     (get-param-constraints param constraint-map)))
         (fn [items-constraints]
           (-> (ItemsConstraint empty-list empty-list nothing "")
               (update-path (ast/file-name params) (ast/line-number params))
               (.items-constraints items-constraints)))))

  (bind [params]
    (for [param-var (genlocal "arg")
          destruct (bind-list (c-code param-var [] [] {} {})
                              params)]
      destruct))

  (bind [params evalled]
    (bind-list evalled params))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (for [val-var (emit (.val ast))
          bound-var (bind (.binding ast) val-var)]
      bound-var)))

(defn merge-constraints [c1 c2]
  (comp c1 c2))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals get-syms
          bindings (traverse (.bindings ast) emit)
          body-exprs (traverse (.body ast) emit)
          :let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
          result-var (either (map (= "" (.c-var code)) sm/state-maybe)
                             (genlocal "rslt"))
          moar-constraints (traverse (zip-lists (.bindings ast) bindings)
                                     (fn [[binding-ast param-binding]]
                                       (for [binding-constraint (get-param-constraints (.binding binding-ast)
                                                                                       (.constraints code))]
                                         (either (and (instance? ItemsConstraint binding-constraint)
                                                      (let [[var] (.vars param-binding)]
                                                        (maybe {var binding-constraint})))
                                                 {}))))
          _ (set-syms locals)]
      (c-init result-var
              [(.init code)
               (either (= "" result-var)
                       [line-sep "Value *" result-var " = " (.c-var code) ";" line-sep])]
              (.decl code) (.refs-map code)
              (reduce moar-constraints (.constraints code)
                      (fn [m1 m2]
                        (merge-with (partial compose-constraints (ast/file-name ast) (ast/line-number ast))
                                    m1 m2)))
              (ast/file-name ast) (ast/line-number ast))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] {}
                                                {var (expr-constraints value)}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               [(.decl value) "Value *" var ";\n"]
               (.refs-map value)
               {var (expr-constraints value)}
               (ast/file-name ast) (ast/line-number ast))]))

  (tail-call [ast params result-constraint]
    (.body ast (-> ast
                   .body
                   (tail-call params result-constraint))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (sm/state-maybe new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (rdr/tag (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body))))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns file-name line-number]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = "
               (count impl-fns) ";" line-sep
               "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (map impl-fns .decl)
              (apply merge-with + (map impl-fns .refs-map))
              {reified-sym (TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>") nothing
                                           reified-sym)}
              file-name line-number))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-code reified-ptr
            []
            [(map impl-fns .decl)
             "ReifiedVal " reified-sym " = {"
             type-num ", -1, (Value *)0, 0, {}};" line-sep
             "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
            {} {reified-ptr (TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>") nothing
                                         reified-ptr)})))

(defprotocol ArityType
  (closure-arity? [_]
    (assert-result x (instance? Maybe x))
    nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (assert-result x (instance? sm/new-sm x))))

(defn new-static-arity
  ([fn-var num-params arity-var result-constraints]
   (assert (instance? Constraints result-constraints))
   (new-static-arity fn-var num-params arity-var result-constraints empty-items-constraint))
  ([fn-var num-params arity-var result-constraints param-constraints]
   (assert (instance? Constraints result-constraints))
   (sm/assoc-in-val [.fns fn-var num-params]
                    (StaticArityInfo (c-code arity-var [] [] {} {arity-var result-constraints})
                                     param-constraints))))

(deftype StaticArity [arity-fn-var param-count var-info param-constraints result-constraints]
  (assert (instance? String arity-fn-var))
  (assert (instance? C-expr var-info))
  (assert (instance? ItemsConstraint param-constraints))
  (assert (instance? Constraints result-constraints))

  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (for [_ (new-proto-impl fn-name param-count dispatch-type-num (.c-var var-info) arity-ast)
          _ (new-static-arity (.c-var var-info) param-count arity-fn-var
                              result-constraints param-constraints)]
      var-info)))

(deftype ClosureArity [arity-fn-var params var-info]
  (assert (instance? String arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))

  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl fn-name param-count dispatch-type-num (str "&" fn-arity-sym) arity-ast)
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                                  ")->impls["
                                  reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};" line-sep]
                                 {} {})]
          (comp reified-fn var-info))))))

(defn checking-fn [fn-sym params param-vars arity-fn-var constraints]
  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)
        constraints-list (.items-constraints constraints)]
    (for [dest-args (genlocal "destArgs")
          checking-fn-var (global-var fn-sym "paramChecker")]
      (either (or (and (.variadic params)
                       (maybe (c-code checking-fn-var
                                      ["Value *" checking-fn-var
                                       "(List *closures, Value *args) {\n"
                                       (destruct-seq 'args (.vars param-vars)
                                                     dest-args file-name line-number)
                                       "return(" arity-fn-var
                                       "(closures, args));\n};\n"]
                                      [] {} {})))
                  (and (every constraints-list (partial = top-type))
                       (maybe (c-code arity-fn-var [] [] {} {}))))
              (c-code checking-fn-var
                      ["Value *" checking-fn-var "("
                       (-> (.vars param-vars)
                           (map (fn [param] (str "Value *" param)))
                           (seq)
                           (conj "List *closures")
                           (interpose ", "))
                       ") {\n"
                       (for [[constraint var] (zip-lists constraints-list
                                                         (.vars param-vars))]
                         (-> constraint
                             (update-var var)
                             (runtime-check top-type file-name line-number)))
                       "return(" arity-fn-var "("
                       (-> (.vars param-vars)
                           (seq)
                           (conj "closures")
                           (interpose ", "))
                       "));\n};\n"]
                      [] {} {})))))

(defn destruct-closures [closure-info]
  (for [destArgs (genlocal "destArgs")]
    (let [closures (-> closure-info
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)]
      (cons (c-code ""
                    [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                     "incRef((Value *)closures, 1);" line-sep
                     "Value **" destArgs "[" closure-count "] = {"
                     (interpose (map closures (fn [arg] ["&" arg])) ", ")
                     "};" line-sep
                     "destructValue(\"\", \"\", (Value *)closures"
                     ", " closure-count ", " destArgs ");" line-sep]
                    [] {} {})
            (map (seq closure-info)
                 (fn [[arg _ constraint]]
                   (c-init arg [] [] {} {arg constraint} "" 0)))))))

(defn emit-closure-arity [fn-sym fn-context arity-fn-var params param-vars body-exprs]
  (for [closures (sm/new-sm (fn [s]
                              (assert (instance? GlobalContext s))
                              (let [closures (-> s .fn-context .closed-over .closures)]
                                (and (first closures)
                                     (maybe (vector closures s))))))
        closures-destruct (destruct-closures closures)
        :let [body (collapse-expressions (comp (.destruct param-vars)
                                               closures-destruct
                                               body-exprs))
              closure-constraints (.constraints body)]
        param-constraints (get-param-constraints params closure-constraints)
        _ (reset-fn-context fn-context)
        arity-var (genlocal fn-sym "dynArity")
        closure-vars (traverse closures (fn [[closed-over sym]]
                                          (for [closure (lookup-sym sym)]
                                            (let [new-constraint (either (get closure-constraints closed-over)
                                                                         top-type)]
                                              (c-code ""
                                                      [arity-var "->closures = listCons((Value *)"
                                                       (.c-var closure) ", (List *)" arity-var
                                                       "->closures);" line-sep]
                                                      [] {(.c-var closure) 1}
                                                      {arity-var (update-var list-constraint (str (.c-var closure)))
                                                       (.c-var closure) new-constraint})))))]
    (let [file-name (ast/file-name fn-sym)
          line-number (ast/line-number fn-sym)
          param-constraints (update-path param-constraints file-name line-number)
          arity-decl [(.decl body)
                      "Value *" arity-fn-var "("
                      (-> (.vars param-vars)
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\n"
                      "\nwhile (1) {\n"
                      (for [[constraint var] (zip-lists (.items-constraints param-constraints)
                                                         (.vars param-vars))]
                         (-> constraint
                             (update-var var)
                             (runtime-check top-type file-name line-number)))
                      (.init body)
                      line-sep "};};\n"]
          arity-init ["FnArity *" arity-var
                      " = malloc_fnArity();" line-sep
                      arity-var "->count = " (count (.vars param-vars))
                      ";" line-sep
                      arity-var "->variadic = "
                      ((.variadic params) "1" "0") ";" line-sep
                      arity-var "->fn = " arity-fn-var ";" line-sep
                      arity-var "->closures = empty_list;" line-sep]]
      (ClosureArity arity-fn-var params
                    (.constraints (comp* (c-code arity-var arity-init arity-decl {} {})
                                         (comp closure-vars
                                               [(c-init arity-var [] [] {} {}
                                                        file-name line-number)]))
                                  {})))))

(defn emit-static-arity [fn-sym fn-context arity-fn-var params param-vars result-constraint body-exprs]
  (assert (instance? ast/params-ast params))
  (assert (instance? ParamBinding param-vars))

  (let [body (collapse-expressions (comp (.destruct param-vars) body-exprs))
        result-constraint (compose-constraints (ast/file-name params) (ast/line-number params)
                                               (expr-constraints body)
                                               result-constraint)]
    (for [arity-var (global-var fn-sym "staticArity")
          param-constraints (get-param-constraints params (.constraints body))
          checker-fn (checking-fn fn-sym params param-vars arity-fn-var param-constraints)
          _ (reset-fn-context fn-context)]
      (do
        ;; TODO: use this to eliminate unknown return type values
        ;; (and (= UnknownType result-type)
        ;;      (maybe (print-err 'unknown-return-type fn-sym
        ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
        (StaticArity arity-fn-var ((.variadic params) 'variadic (count params))
                     (c-code (str "&" arity-var) []
                             [(.decl body)
                              "Value *" arity-fn-var "("
                              (-> (.vars param-vars)
                                  (map (fn [param] (str "Value *" param)))
                                  (seq)
                                  (conj "List *closures")
                                  (interpose ", "))
                              ") {\nwhile (1) {\n"
                              (.init body)
                              line-sep "};};\n"
                              (.init checker-fn)
                              "FnArity " arity-var " = {FnArityType, -1, "
                              (count (.vars param-vars))
                              ", (List *)0, " ((.variadic params) "1" "0")
                              ", " (.c-var checker-fn) "};" line-sep]
                             {} {})
                     param-constraints
                     result-constraint)))))

(defn bind-params [params fn-var arity-fn-var]
  (assert (instance? ast/params-ast params))

  (comp (for [_ (sm/when (.variadic params))
              param-var (genlocal "arg")
              destruct (bind-list (c-code param-var [] [] {} {}) params)]
          destruct)
        (for [vars (traverse (.fixed params) bind)
              :when-not (empty? vars)
              _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] arity-fn-var)]
          (let [[var & vars] vars
                param-vars (comp* var vars)]
            (ParamBinding (.vars param-vars)
                          (comp (map (.vars param-vars)
                                     (fn [var]
                                       (c-param var [] [] {} {}
                                                (ast/file-name params) (ast/line-number params))))
                                (.destruct param-vars)))))
        (for [_ (sm/assoc-in-val [.fn-context .recurse fn-var 0] arity-fn-var)]
          (ParamBinding [] []))))

(defn emit-fn-arity
  ([fn-sym fn-var params body]
   ;; TODO: this should be redundant
   ;; (assert (instance? String fn-var))
   (flat-map (global-var fn-sym "arityImpl")
             (fn [arity-fn-var]
               (emit-fn-arity fn-sym fn-var params body (str arity-fn-var)))))

  ([fn-sym fn-var params body arity-fn-var]
   ;; TODO: this should be redundant
   ;; (assert (instance? String fn-var))
   (assert (min-count body 1))
   (assert (instance? String arity-fn-var))

   (either (and (empty? (filter body produces-code?))
                (maybe (zero sm/state-maybe)))
           (let [file-name (ast/file-name body)
                 line-number (ast/line-number body)
                 param-asserts (filter body assertion?)]
             (for [fn-context (reset-fn-context)
                   result-constraint (map (-> body
                                              (filter return-assertion?)
                                              (map .assertion)
                                              (traverse to-constraint))
                                          (fn [constraints]
                                            (let [result-type (update-sym (comp* top-type constraints)
                                                                          "<result value>")]
                                              (and (= bottom-type result-type)
                                                   (do
                                                     (apply print-err "Conflicting result assertions"
                                                            (either (= "" file-name)
                                                                    (str " at " file-name ": " line-number))
                                                            "\n"
                                                            (format-path result-type 0))
                                                     (maybe (abort))))
                                              result-type)))
                   _ (comp (get-sym fn-sym)
                           (set-sym fn-sym (c-code fn-var [] [] {}
                                                   {fn-var fn-constraint})))
                   param-vars (bind-params params fn-var arity-fn-var)
                   :let [param-vars (either (and (some body (partial instance? ast/inline-ast))
                                                 (maybe (.destruct param-vars [])))
                                            param-vars)]
                   body-exprs (-> body
                                  (filter produces-code?)
                                  ((fn [body] (comp param-asserts body)))
                                  (tail-call (.vars param-vars) result-constraint)
                                  (traverse emit))
                   arity-info (comp (emit-closure-arity fn-sym fn-context arity-fn-var params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context arity-fn-var params
                                                       param-vars result-constraint body-exprs))]
               arity-info)))))

(defn validate-protocol-names [ast]
  (traverse (keys (.impls ast))
            (fn [protocol-name]
              (comp (get-protocol protocol-name)
                    (compilation-error "Invalid protocol:" protocol-name "in"
                                       (str (ast/file-name ast) ",")
                                       (ast/line-number protocol-name))))))

(defn validate-proto-fn-name [fn-name arg-count]
  (comp (get-protocol-dispatcher fn-name arg-count)
        (compilation-error "Invalid protocol fn:"
                           (str "'" fn-name "' in")
                           (str (ast/file-name fn-name) ",")
                           (ast/line-number fn-name))))

(deftype ProtoImplDeclaration [fn-name arity-ast arity-impl-var c-decl]
  (assert (instance? Tagged fn-name))
  (assert (instance? String arity-impl-var))
  (assert (instance? ast/fn-arity-ast arity-ast))
  (assert (instance? Vector c-decl)))

(defn declare-impl [type-str type-num [fn-name arity-ast]]
  (assert (instance? Integer type-num))
  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (map (global-var (str type-str fn-name) "arityImpl") str)
          dispatcher-info (validate-proto-fn-name fn-name num-args)
          _ (new-proto-impl fn-name num-args type-num impl-fn-var arity-ast)
          _ (new-static-arity impl-fn-var num-args arity-impl-var
                              (.return-constraint dispatcher-info))]
      (ProtoImplDeclaration fn-name arity-ast arity-impl-var
                            ["Value *" arity-impl-var "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"]))))

(defn update-param-constraint [constraint sym]
  ;; (assert (instance? Constraints constraint))
  (-> constraint
      (update-path (ast/file-name sym) (ast/line-number sym))
      (update-sym sym)))

(defn emit-impl [type-str type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))
  (let [[fn-name arity-ast arity-var] (type-args impl-decl)
        params (.params arity-ast)
        [disp-param] (.fixed params)
        num-args (count params)
        file-name (ast/file-name fn-name)
        line-number (ast/line-number fn-name)]
    (for [dispatcher-info (validate-proto-fn-name fn-name num-args)
          ;; _ (debug 'fn-name type-str fn-name num-args file-name line-number)
          disp-constraint (comp (for [_ (sm/get-in-val [.constants .type-names type-num])
                                      ;; TODO: this needs to be factored out
                                      constraint (type-constraint type-num file-name line-number)]
                                  (update-param-constraint constraint disp-param))
                                (sm/state-maybe top-type))
          :let [param-constraints (.items-constraints (.param-constraints dispatcher-info))
                constraints (-> (zip-lists (.fixed params) param-constraints)
                                (map (fn [[param constraints]]
                                       (update-param-constraint constraints param)))
                                (conj disp-constraint))]
          ext-fn (comp (emit-fn-arity (rdr/tag (str type-str fn-name))
                                      (.fn-var arity-ast)
                                      params
                                      (comp constraints
                                            (.return-assertions dispatcher-info)
                                            (.body arity-ast))
                                      arity-var)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-name "' in")
                                          (str (ast/file-name fn-name) ",")
                                          (ast/line-number fn-name)))
          reified (reify-arity ext-fn type-num arity-ast fn-name)
          ;; _ (debug "---------")
          ]
      reified)))

(defn extend-type* [ast type-num]
  (assert (instance? Integer type-num))
  (let [impl-arities (for [impl-fns (vals (.impls ast))
                            [fn-name arities] (seq impl-fns)
                            impl-arity arities]
                       [fn-name impl-arity])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (sm/state-maybe (str "_" type-num "_")))
                _ (validate-protocol-names ast)
                impl-arities (traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns
                                                        (ast/file-name ast) (ast/line-number ast))
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-code (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                     (.c-var value) ";" line-sep]
                                     (.decl value) (.refs-map value)
                                     {(.c-var value) (expr-constraints value)})))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                {(.c-var value) (expr-constraints value)}))]
      [value]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (map (emit clause)
           (fn [expr]
             (either (and (or (= (expr-type-num expr)
                                 MaybeType)
                              (= "" (.c-var expr)))
                          (maybe expr))
                     (.init expr [(.init expr)
                                  "if (" (.c-var expr) "->type != MaybeType) {" line-sep
                                  "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
                                  file-name "\","
                                  (ast/line-number clause)
                                  ");" line-sep
                                  "fprintf(stderr, \"Expected Maybe, got %s\\n\", extractStr(type_name(empty_list, "
                                  (.c-var expr) ")));" line-sep
                                  "abort();" line-sep
                                  "}" line-sep])))))))

(extend-type rdr/tagged-symbol
  EmitCond
  (emit-cond-clause [clause]
    (for [expr (emit clause)
          constraint (type-constraint (expr-type-num expr)
                                      (ast/file-name clause) (ast/line-number clause))]
      (let [expr-c (expr-constraints expr)]
        (.constraints expr (assoc (.constraints expr)
                             (.c-var expr) (comp constraint expr-c)))))))

(extend-type Symbol
  EmitCond
  (emit-cond-clause [clause]
    (for [expr (emit clause)
          constraint (type-constraint (expr-type-num expr)
                                      (ast/file-name clause) (ast/line-number clause))]
      (let [expr-c (expr-constraints expr)]
        (.constraints expr (assoc (.constraints expr)
                             (.c-var expr) (comp constraint expr-c)))))))

(defn clause-refs [exprs]
  (let [clause-vars (-> exprs
                        (remove (fn [c] (empty? (.init c))))
                        (map .c-var)
                        set)
        refs-maps (map exprs .refs-map)]
    (-> (apply merge-with + refs-maps)
        (remove-keys clause-vars))))

(defn last-init [evalled-clauses result-var]
  (let [last-clause (either (last evalled-clauses)
                            (do
                              (print-err "Booom!!!")
                              (abort)))]
    ;; TODO: only check the constraints that haven't been checked yet
    [(map (seq (.constraints last-clause))
          (fn [[var constraint]]
            (either (and (get (.refs-map last-clause) var)
                         (maybe (runtime-check (update-var constraint (str var)) top-type "" 0)))
                    "")))
     ((= "" (.c-var last-clause))
      (.init last-clause)
      [(.init last-clause)
       result-var " = " (.c-var last-clause) ";" line-sep])]))

(defn cond-clause-init [cond-test result-var [init refs-map] clause]
  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs))]
    [(conj (vec init)
           ;; TODO: only check the constraints that haven't been checked yet
           [(map (seq (.constraints clause))
                 (fn [[var constraint]]
                   (either (and (get (.refs-map clause) var)
                                (maybe (runtime-check (update-var constraint (str var)) top-type "" 0)))
                           "")))
            (.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            cond-test result-var ",\"\",0)) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  (either (and (= 0 remaining)
                                               (maybe ""))
                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))])
     refs-map]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits] (reduce (butlast evalled-clauses)
                               [[] refs-map]
                               (partial cond-clause-init cond-test result-var))]
    clause-inits))

(defn emit-cond-expr [cond-test result-var clauses tail-return]
  (map (-> clauses
           (filter produces-code?)
           (traverse emit-cond-clause))
       (fn [evalled-clauses]
         (let [refs-map (clause-refs evalled-clauses)
               [first-clause] evalled-clauses]
           (c-init result-var
                   ["Value *" result-var ";" line-sep
                    (-> evalled-clauses
                        (clause-inits cond-test refs-map result-var)
                        (conj (last-init evalled-clauses result-var))
                        (interpose [tail-return "} else {" line-sep
                                    "dec_and_free(" result-var ", 1);" line-sep]))
                    (-> (count evalled-clauses)
                        (dec)
                        (repeat (str "}" line-sep)))]
                   (map evalled-clauses .decl) refs-map
                   (assoc (.constraints first-clause)
                     result-var (TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing result-var))
                   (ast/file-name clauses) (ast/line-number clauses))))))

(deftype TailAnd [clauses]
  (assert (instance? List clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr "if (isNothing(" result-var
                               (.clauses ast) (str "return(nothing);" line-sep))]
      expr)))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (either (and (empty? clauses)
                   (maybe (sm/state-maybe empty-c-code)))
              (for [result-var (genlocal "andRslt")
                    expr (emit-cond-expr "if (isNothing(" result-var clauses "")]
                expr))))

  (tail-call [ast params result-constraint]
    (let [clauses (-> (.clauses ast)
                      (filter produces-code?)
                      seq
                      reverse)]
      (either (map (first clauses)
                   (fn [last-clause]
                     (TailAnd (-> (tail-call last-clause params result-constraint)
                                  (cons (rest clauses))
                                  reverse))))
              (TailAnd empty-list))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast (vec new-clauses))))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr "if (!isNothing(" result-var (.clauses ast)
                               (str "return(" result-var ");" line-sep))]
      expr)))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (either (and (empty? clauses)
                   (maybe (sm/state-maybe empty-c-code)))
              (flat-map (genlocal "orRslt")
                        (fn [result-var]
                          (emit-cond-expr "if (!isNothing(" result-var clauses
                                          line-sep))))))

  (tail-call [ast params result-constraint]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (TailOr (either (flat-map (last clauses)
                                (fn [last-clause]
                                  (store clauses (dec (count clauses))
                                         (tail-call last-clause params result-constraint))))
                      []))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs))))))

(deftype TailEither [clause alt result-constraint]

  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (for [cond-val (emit clause)
          alt-val (map (emit alt)
                       (fn [expr]
                         (let [expr (either (and (instance? Tagged alt)
                                                 (maybe (.refs-map expr {})))
                                            expr)]
                           (emit-tail-expr alt result-constraint expr))))
          result-var (genlocal "rslt")]
      (let [cond-rslt (.c-var cond-val)
            refs-map (merge-with + (.refs-map cond-val) (.refs-map alt-val))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                refs-map
                {result-var result-constraint
                 (.c-var cond-val) (TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing (.c-var cond-val))})))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          cond-val (emit (.clause ast))
          alt-val (emit (.alt ast))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val)) refs-map
                {(.c-var cond-val) (TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing (.c-var cond-val))}
                (ast/file-name ast) (ast/line-number ast)))))

  (tail-call [ast params result-constraint]
    (TailEither (.clause ast) (.alt ast) result-constraint))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs))))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug 'main-fn)
          fn-arity (emit-fn-arity (rdr/tag 'main) "" (.params ast) (.body ast))
          ;; _ (debug "=======")
          result-constraint (type-constraint IntegerType "" 0)
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) result-constraint)]
      [(c-code "" [] (.decl (.var-info fn-arity)) {} {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [params (.params prototype)
        num-args (count params)
        body (.default-body prototype)
        type-symbol (some body assert-return-type)
        return-assertions (filter body return-assertion?)
        assertions (filter body assertion?)]
    (for [curr-context (reset-fn-context)
          _ (bind-params params "" "")
          return-constraint (map (traverse return-assertions to-constraint)
                                 (partial comp* top-type))
          x (traverse assertions emit)
          constraints (get-param-constraints params (.constraints (collapse-expressions x)))

          _ (reset-fn-context curr-context)
          arity-fn-var (global-var fn-name "protoDisp")
          impls-sym (global-var (str fn-name "_Implementations") "protoImpls")
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym return-assertions
                                  return-constraint constraints)
          return-type (get-type-number type-symbol)
          result-constraint (type-constraint return-type "" 0)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var result-constraint)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-fn-arity (rdr/tag (str "Default_" fn-name)) ""
                                            (.params prototype) default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.c-var (.var-info static-arity)) default-body)]
            (.decl (.var-info static-arity)))
          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (global-var fn-name "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] {}
                                   {dispatch-fn-sym fn-constraint}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities
                                   (partial declare-proto-dispatch-arity fn-name
                                            dispatch-fn-sym))
        default-fns (traverse arities (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map)
                           (partial create-dispatcher proto-name))]
        [(c-code "" [] decl {} {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (either (and (= "" (.fn-sym ast))
                                (maybe (rdr/tag 'anon
                                                (ast/file-name (.params ast))
                                                (ast/line-number (.params ast)))))
                           (.fn-sym ast))
                   (.fn-var ast) (.params ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (sm/state-maybe (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (rdr/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (traverse arities
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.arity-fn-var static-arity)
                                                              (.result-constraints static-arity)
                                                              (.param-constraints static-arity))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              {} {fn-var fn-constraint}))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-init (str fn-var)
              [(map emitted-arities .init)
               line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
               struct-var "->name = \"" fn-sym "\";" line-sep
               struct-var "->arityCount = " arity-count ";" line-sep
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";" line-sep)))
               "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
              [(map emitted-arities .decl)] (apply merge-with + (map emitted-arities .refs-map))
              (assoc (.constraints (collapse-expressions emitted-arities))
                (str fn-var) fn-constraint)
              (ast/file-name fn-sym) (ast/line-number fn-sym)))))

(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug "=========")
                ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                arities (traverse (map (.arities ast) (fn [arity]
                                                        (-> arity
                                                            (.fn-sym fn-sym)
                                                            (.fn-var fn-var))))
                                  emit)
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                arities (traverse (.arities ast) emit)
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                {(.c-var value) fn-constraint}))]
      [(make-c-code value)]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (traverse (.arities ast)
                                (fn [arity]
                                  (replace-syms arity subs)))]
      (.arities ast (vec new-arities))))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [ns-path (sym-ns-path (.type ast))
                  type-nums (get-type-numbers (maybe type-sym))
                  fns (map (traverse (seq type-nums) (partial extend-type* ast))
                           flatten)]
              fns)
            (compilation-error "Trying to extend unknown type: "
                               type-sym "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(deftype constraint-ast [constraint ast]
  ;; TODO; re-enable
  ;; (assert (instance? SymbolConstraints constraint))

  Stringable
  (string-list [_]
    (list "<ExprConstraint " (str constraint) " " (str ast) ">"))

  Emitter
  (replace-syms [_ subs]
    (for [new-ast (replace-syms ast subs)]
      (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (update-sym constraint new-sym))
                                   constraint)]
        (constraint-ast new-constraint new-ast))))

  (replace-bound-vars [_ subs]
    (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (update-sym constraint new-sym))
                                 constraint)
          new-ast (replace-bound-vars ast subs)]
      (constraint-ast new-constraint new-ast)))

  (tail-call [_ params return-constraints]
    (constraint-ast constraint (tail-call ast params return-constraints)))

  (emit [_]
    (for [expr (emit ast)]
      (add-constraint expr (-> constraint
                               (update-path (ast/file-name ast) (ast/line-number ast)))
                      (ast/file-name ast) (ast/line-number ast)))))

(defn constructor-expr [new-type-name new-type-constraint type-val-sym fields assertions]
  (let [reified-type-num (extract rdr/type-counter)]
    (ast/definition new-type-name
      [(ast/reified reified-type-num
                    {Type-sym
                     [[type-name-sym
                       [(ast/fn-arity-ast (str new-type-name "_const_type_name") ""
                                          (ast/params ['_]) ""
                                          [(str "*" new-type-name " constructor*")])]]
                      [instance?-sym
                       [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") ""
                                          (ast/params ['x 'y]) ""
                                          [(ast/call-ast =*-sym
                                                         [(ast/call-ast get-type-sym [type-val-sym])
                                                          (ast/call-ast get-type-sym ['y])])])]]]

                     Function-sym
                     [[invoke-sym
                       [(ast/fn-arity-ast (str new-type-name "_invoke") ""
                                          (ast/params (vec (cons '_ (seq fields)))) ""
                                          (comp assertions
                                                [(constraint-ast
                                                  new-type-constraint
                                                  (ast/call-ast new-type-value-sym
                                                                [type-val-sym
                                                                 (ast/call-ast 'vector
                                                                               (vec fields))]))]))]]]

                     Container-sym
                     [[apply*-sym
                       [(ast/fn-arity-ast (str new-type-name "_apply_ST_") ""
                                          (ast/params ['_ 'fields]) ""
                                          ;; TODO: need field constraints here
                                          [(ast/call-ast new-type-value-sym
                                                          [type-val-sym
                                                           (ast/call-ast 'vec ['fields])])])]]]

                     Stringable-sym
                     [[string-list-sym
                       [(ast/fn-arity (ast/params ['z]) ""
                                      [(ast/call-ast list-sym
                                                     ["<TypeCon " (str new-type-name) " ["
                                                      (to-str (interpose fields ", ")) "]>"])])]]]})])))

(defn type-val-expr [type-sym type-num type-val-sym fields impls]
  (let [x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field* (rdr/tag "#field")
        ctxt* (rdr/tag "#ctxt")]
    (ast/definition type-val-sym
      [(ast/reified type-num
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") ""
                                                      (ast/params [x*]) ""
                                                      [(str type-sym)])]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") ""
                                     (ast/params [x* field*]) ""
                                     [(ast/or-ast
                                       (conj (map fields
                                                  (fn [field]
                                                    (ast/call-ast identical-sym
                                                                  [(rdr/tag (str "." field))
                                                                   field*])))
                                             (rdr/tag 'nothing)))])]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") ""
                                     (ast/params [x* y*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast
                                         =*-sym [(ast/call-ast get-type-sym [x*])
                                                 (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast
                                         =*-sym [(ast/call-ast reified-type-args-sym [x*])
                                                 (ast/call-ast reified-type-args-sym [y*])])
                                        (ast/call-ast maybe-sym [x*])])])]]]

                                 Associative-sym
                                 [[get-symb
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") ""
                                     (ast/params [x* field*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym
                                                      [(ast/call-ast field* [x*])])])])]]]

                                 HashMapNode-sym
                                 [[assoc*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_STAR_") ""
                                     (ast/params [x* field* 'new-value '_ '_]) ""
                                     [(ast/call-ast
                                       extract-sym
                                       [(ast/or-ast
                                         [(ast/and-ast
                                           [(ast/call-ast has-field-sym [x* field*])
                                            (ast/call-ast
                                             maybe-sym
                                             [(ast/call-ast field* [x* 'new-value])])])
                                          (ast/call-ast maybe-sym [x*])])])])]]]

                                 Hashable-sym
                                 [[sha1-update-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1_update") ""
                                     (ast/params [x* ctxt*]) ""
                                     [(ast/call-ast sha1-update-type-sym [x* ctxt*])
                                      (ast/call-ast
                                       sha1-update-sym
                                       [(ast/call-ast reified-type-args-sym [x*]) ctxt*])])]]
                                  [sha1-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1") ""
                                     (ast/params [x*]) ""
                                     [(ast/call-ast
                                       sha1-finalize-sym
                                       [(ast/call-ast
                                         sha1-update-sym
                                         [x* (ast/call-ast sha1-init-sym [])])])])]]]}
                                impls))])))

(defn declare-getters [new-type-name fields]
  (traverse fields
            (fn [field]
              (let [getter-sym (rdr/tag (str "." field) 'core 0)]
                (comp (map (sm/get-in-val [.modules 'core .proto-fns getter-sym]) (fn [_] []))
                      (for [dispatch-fn-var (global-var "dispatchFnPtr")
                            arity-fn-var1 (global-var "protoImpl")
                            impls-sym1 (global-var "protoImpls")
                            arity-fn-var2 (global-var "protoImpl")
                            impls-sym2 (global-var "protoImpls")
                            _ (new-module-def getter-sym (c-code dispatch-fn-var [] []
                                                                 {} {dispatch-fn-var fn-constraint}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 1]
                                               (ProtocolDispatcher 1 arity-fn-var1 impls-sym1
                                                                   [] top-type empty-items-constraint {}))
                            _ (sm/assoc-in-val [.modules 'core .proto-fns getter-sym .dispatchers 2]
                                               (ProtocolDispatcher 2 arity-fn-var2 impls-sym2
                                                                   [] top-type empty-items-constraint {}))
                            _ (new-static-arity dispatch-fn-var 1 arity-fn-var1 top-type)
                            _ (new-static-arity dispatch-fn-var 2 arity-fn-var2 top-type)]
                        ["ProtoImpls " impls-sym1 ";\n"
                         "ProtoImpls " impls-sym2 ";\n"
                         "Value *" dispatch-fn-var ";\n"
                         "Value *" arity-fn-var1
                         "(List *closures, Value *arg);\n"
                         "Value *" arity-fn-var2
                         "(List *closures, Value *arg1, Value *arg2);\n"]))))))

(defn create-getters [sym constraint fields field-constraints]
  (let [type-value (rdr/tag "#value")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            (let [new-value (rdr/tag (str field))
                  extract-field (ast/call-ast extract-sym
                                              [(ast/call-ast nth-sym
                                                             [(ast/call-ast reified-type-args-sym
                                                                            [type-value])
                                                              field-index])])
                  extract-field (either (map (= top-type field-constraint)
                                             (fn [_]
                                               [extract-field]))
                                        [(constraint-ast field-constraint extract-field)])
                  set-field [(update-sym field-constraint field)
                             (constraint-ast constraint
                                             (ast/call-ast make-value-sym
                                                           [type-value
                                                            (ast/call-ast extract-sym
                                                                          [(ast/call-ast
                                                                            store-sym
                                                                            [(ast/call-ast
                                                                              reified-type-args-sym
                                                                              [type-value])
                                                                             field-index new-value])])]))]]
              [(rdr/tag (str "." field))
               [(ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value new-value]) ""
                                  set-field)
                (ast/fn-arity-ast (str sym "_" field) ""
                                  (ast/params [type-value]) ""
                                  extract-field)]])))}))

(defn destruct-impl-fields [sym ast field-types arity]
  (let [[type-value-parameter] (.fixed (.params arity))
        return-assertions (filter (.body arity) return-assertion?)
        new-body (comp return-assertions
                       [(ast/assert-type (.sym ast) type-value-parameter)]
                       (filter (.body arity) assertion?)
                       [(ast/let-ast [(ast/binding (.fields ast)
                                        (constraint-ast field-types (ast/call-ast
                                                                     reified-type-args-sym
                                                                     [type-value-parameter])))]
                                     (remove (.body arity) assertion?))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str sym "_" fn-name)))))

(defn destructure-fields [sym ast field-types]
  (let [impls (comp* {} (filter (.impls ast)
                                (partial instance? HashMap)))]
    (map-vals impls
              (fn [impl-arities]
                (map impl-arities
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields sym ast field-types))]))))))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            (either (and (= file-name 'core)
                                                         (maybe "$TOCCATA_DIR/core.toc"))
                                                    file-name)
                                            ", " line-number))]
              "")

            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym file-name line-number)
                        type-num (extract rdr/type-counter)
                        type-map {type-num (-> fields
                                               (map (fn [name]
                                                      (symbol
                                                       (str "." name))))
                                               set)}
                        new-type-constraint (TypeConstraint type-map (list [file-name line-number])
                                                            sym nothing "")]
                  _ (sm/assoc-in-val [.type-maps type-num] (TypeInfo sym type-map))
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)
                  _ (sm/assoc-in-val [.constants .type-names type-num] (str sym))
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition
                                    (constructor-expr sym new-type-constraint type-val-sym fields
                                                      (filter (.impls ast) assertion?)))
                  field-maps (traverse (filter (.impls ast) assertion?)
                                       (fn [assertion]
                                         (map (to-constraint (.assertion assertion))
                                              (fn [c]
                                                {(.sym (.assertion assertion)) c}))))
                  :let [field-map (reduce field-maps {} (fn [m field-map]
                                                          (merge-with (partial compose-constraints
                                                                               file-name line-number)
                                                                      m field-map)))
                        field-constraints (ItemsConstraint
                                           (map (seq fields) (fn [field]
                                                               (either (get field-map field)
                                                                       top-type)))
                                           empty-list (maybe (symbol (str sym "-field-constraints"))) "")
                        impls (merge-with comp
                                          (create-getters sym new-type-constraint fields
                                                          (.items-constraints field-constraints))
                                          (destructure-fields sym ast field-constraints))]
                  type-val-def (emit-definition (type-val-expr sym type-num type-val-sym
                                                               fields impls))

                  const-type-num (map (sm/get-in-val [.modules file-name .values sym])
                                      expr-type-num)
                  constructor-arity (map (get-proto-impl invoke-sym const-arity-index const-type-num)
                                         .c-var)
                  constructor-info (sm/get-in-val [.fns constructor-arity const-arity-index .c-info])
                  _ (sm/assoc-in-val [.fns constructor-arity const-arity-index .c-info]
                                     (-> constructor-info
                                         (.constraints {(.c-var constructor-info)
                                                        (-> new-type-constraint
                                                            (update-var (.c-var constructor-info)))})))]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) {} {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {} empty-closures)
                                   (RuntimeInit (FunctionArityContext {} 0 {} {} empty-closures)
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names)
                                   0                        ;; reify-fn-index
                                   core-types               ;; type-maps
                                   ))

(def string-writer (agent ""))

(def logger (agent ""))
(defn log [& msg]
  (send logger (fn [_]
                 (apply print-err msg))))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");" line-sep]))

(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))
(def emit-main*
  (for [main-fn (comp (lookup-static-arity 'main 1)
                      (compilation-error "'main' function is missing"))
        values (sm/get-in-val [.rt-init .exprs])
        modules (sm/get-in-val [.modules])]
    (write-strings ["\n#\n"
                    "\nint main (int argc, char **argv) {\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map values .init) "\n"
                    "#\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    (map (vals modules) (fn [module]
                                          (either (map (get-in module [.values symbols-sym])
                                                       (fn [expr]
                                                         (free-global (c-init (.c-var expr)
                                                                              [] [] {} {} "" 0))))
                                                  "")))
                    (map (vals modules) (fn [module]
                                          (either (map (get-in module [.values types-sym])
                                                       (fn [expr]
                                                         (free-global (c-init (.c-var expr)
                                                                              [] [] {} {} "" 0))))
                                                  "")))
                    (map values free-global) "\n"
                    "#\n"
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif\n"
                    "#\n"
                    "  return(0);\n};\n"])))

;; TODO: use 'switch' to dispatch proto fns
(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity (str "&" arity-sym) num-args
                                (c-code (str "&" arity-sym)
                                        []
                                        ["\n// " fn-name " " num-args " args\n"
                                         "ProtoImpls " impls-sym " = {"
                                         (count impls) ", {"
                                         (rest (flat-map (vals impls)
                                                         ;; [type arity-sym fn-sym]
                                                         (fn [type-impl]
                                                           [", " "{" (.dispatch-type type-impl)
                                                            ", (Value *)" (.c-var type-impl)
                                                            "}"])))
                                         "}};\n"
                                         "Value *" (.dispatch-sym proto-disp) "("
                                         (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                                          "List *closures")
                                                    ", ")
                                         ") {\n"
                                         "  return(proto" num-args "Arg(&" impls-sym ", \""
                                         fn-name "\", " (interpose
                                                         (comp args
                                                               [(str "\"" (ast/file-name fn-name) "\"")
                                                                (ast/line-number fn-name)])
                                                         ", ")
                                         "));\n}\n"
                                         "FnArity " arity-sym " = {FnArityType, -1, "
                                         num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                                        {} {})
                                empty-items-constraint
                                top-type)]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn))
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              {} {}))))

(defn get-proto-dispatch-sym [fn-name num-args]
  (sm/get-in-val [.modules 'core .proto-fns fn-name .dispatchers num-args .dispatch-sym]))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (sm/assoc-in-val [.modules module-name]
                                         (Module module-name {} {} {} core-type-nums {}))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [emitted (map emitted (fn [expr]
                                                           (write-strings (.decl expr))
                                                           (.decl expr [])))]
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))

(def finalize-protocols*
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              emit-proto-fn)]
    (map dispatchers (fn [expr] (write-strings (.decl expr))))))

(defn finalize-protocols [context]
  (update-context context
                  (comp finalize-protocols*
                        (compilation-error "Compilation error (Could not finalize protocols.)"))))

(def fixup-native-symbols*
  (apply* (sm/state-maybe (fn [& decl]
                            (write-strings decl)))
          (list (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                     (fn [arity-sym]
                       ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                     (fn [arity-sym]
                       ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                     (fn [arity-sym]
                       ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                     (fn [arity-sym]
                       ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                     (fn [arity-sym]
                       ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                     (fn [arity-sym]
                       ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                     (fn [arity-sym]
                       ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'seq) 1)
                     (fn [arity-sym]
                       ["Value *(*seq)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                     (fn [arity-sym]
                       ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'assoc*) 5)
                     (fn [arity-sym]
                       ["Value *(*assoc)(List *, Value*, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                     (fn [arity-sym]
                       ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'get*) 5)
                     (fn [arity-sym]
                       ["Value *(*get)(List *, Value*, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'has-field) 2)
                     (fn [arity-sym]
                       ["Value *(*hasField)(List *, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                     (fn [arity-sym]
                       ["Value *(*showFn)(List *, Value *) = " (.c-var arity-sym) ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'fn-apply) 2)
                     (fn [arity-sym]
                       ["Value *(*fn_apply)(List *, Value*, Value*) = "
                        (.c-var arity-sym) ";\n"]))
                )
          ))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(defn file-directory [src-file-name]
  (map (sys/realpath src-file-name)
       (fn [real-path]
         (let [[path-len] (reduce real-path [-1 0]
                                  (fn [[slash-pos c-pos] c]
                                    (let [c-pos (inc c-pos)]
                                      ((= c "/")
                                       [c-pos c-pos]
                                       [slash-pos c-pos]))))]
           (subs real-path 0 path-len)))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def clone-repo)
(def repo-cloner (agent {}))

(defn clone-repo* [ast root-dir proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sys/sh-proc "/usr/bin/git" (list "clone" "--branch" branch
                                                   (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sys/sh-proc "/usr/bin/git"
                                             (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter root-dir proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast root-dir proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter root-dir proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn gather-symbols [context file-name]
  (update-context context
                  (comp (for [symbols (sm/get-in-val [.modules file-name .values])
                              vect-sym (global-var "symbols_")
                              _ (sm/assoc-in-val [.modules file-name .values symbols-sym]
                                                 (c-code vect-sym [] [] {} {}))
                              assocs (traverse (seq symbols)
                                               (fn [[sym var]]
                                                 (for [sym-var (emit (ast/quoted-ast sym))]
                                                   (c-code ""
                                                           [vect-sym " = assoc((List *)0, (Value *)" vect-sym
                                                            ", incRef(" (.c-var sym-var) ", 1),"
                                                            " incRef(" (.c-var var) ", 1),"
                                                            " symbolSha1(incRef(" (.c-var sym-var) ", 1)),"
                                                            " const0Ptr);\n"]
                                                           (.decl sym-var) {} {}))))
                              :let [_ (write-strings (map assocs .decl))]
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs assocs
                                                                            [(c-code "" [vect-sym "->refs = -1;"]
                                                                                     [] {} {})])))]
                          '_)
                        (sm/state-maybe '_))))

(defn gather-types [context file-name]
  (update-context context
                  (comp (for [types (sm/get-in-val [.modules file-name .types])
                              vect-sym (global-var "types_")
                              _ (sm/assoc-in-val [.modules file-name .values types-sym]
                                                 (c-code vect-sym [] [] {} {}))
                              assocs (traverse (seq types)
                                               (fn [[sym var]]
                                                 (for [sym-var (emit (ast/quoted-ast sym))
                                                       expr (emit var)]
                                                   (c-code ""
                                                           [vect-sym " = assoc((List *)0, (Value *)" vect-sym
                                                            ", incRef(" (.c-var sym-var) ", 1),"
                                                            " incRef(" (.c-var expr) ", 1),"
                                                            " symbolSha1(incRef(" (.c-var sym-var) ", 1)),"
                                                            " const0Ptr);\n"]
                                                           [(.decl sym-var) (.decl expr)]
                                                           {} {}))))
                              :let [_ (write-strings (map assocs .decl))]
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs assocs
                                                                            [(c-code "" [vect-sym "->refs = -1;"]
                                                                                     [] {} {})])))]
                          '_)
                        (sm/state-maybe '_))))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (do
                  (send ast-emitter gather-symbols 'core)
                  (send ast-emitter gather-types 'core)
                  (send ast-emitter (fn [context]
                                      (update-context context
                                                      (for [symbols (sm/get-in-val [.modules 'core .values
                                                                                    symbols-sym])
                                                            _ (sm/assoc-in-val [.modules 'core .values
                                                                                (rdr/tag 'core-symbols)]
                                                                               symbols)
                                                            types (sm/get-in-val [.modules 'core .values
                                                                                  types-sym])
                                                            _ (sm/assoc-in-val [.modules 'core .values
                                                                                (rdr/tag 'core-types)]
                                                                               types)]
                                                        (do
                                                          (write-strings [["Value *" (.c-var symbols)
                                                                           " = (Value *)&emptyBMI;\n"]])
                                                          (write-strings [["Value *" (.c-var types)
                                                                           " = (Value *)&emptyBMI;\n"]])
                                                          '_)))))
                  (assoc modules 'core 'loaded))))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? HashMap loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (analyze-forms {'file-name file-name
                                                                 'root-directory root-dir
                                                                 'project-directory proj-dir
                                                                 'line-number 1}
                                                                (lazy-list file-in))))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(main [params]
      (let [[_ file-name] params
            waiter (promise)]
        (or (map (file-directory file-name)
                 (fn [root-dir]
                   (write-strings ["\n#define _XOPEN_SOURCE 600"
                                   "\n#include <stdlib.h>"
                                   "\n#include \"core.h\"\n"])
                   (send module-compiler compile-module file-name waiter root-dir root-dir)))
            (do
              (print-err "Could not find " (str "'" file-name "'"))
              (abort)))
        (extract waiter)
        (send ast-emitter emit-main)
        (send ast-emitter finalize-protocols)
        (send ast-emitter fixup-native-symbols)
        ;; (send ast-emitter (fn [ctxt]
        ;;                     (print-err
        ;;                      "\n" 'static-fixed (get-in ctxt ['_ .other 'static-fixed-sites])
        ;;                      "\n" 'static-variadic (get-in ctxt ['_ .other 'static-variadic-sites])
        ;;                      "\n" 'invoke (get-in ctxt ['_ .other 'invoke-sites])
        ;;                      "\n" 'dyn-fn (get-in ctxt ['_ .other 'dyn-fn-sites])
        ;;                      "\n" 'dyn-unknown (get-in ctxt ['_ .other 'dyn-unknown-sites])
        ;;                      "\n" 'type-known (get-in ctxt ['_ .other 'type-known-sites])
        ;;                      "\n" 'type-unknown (get-in ctxt ['_ .other 'type-unknown-sites])
        ;;                      "\n")))
        ;; wait for agents to clear their queues
        (let [waiter (promise)]
          (send ast-emitter (fn [_]
                              (send string-writer (fn [_]
                                                    (deliver waiter 'x)))))
          (extract waiter))))
