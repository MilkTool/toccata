
(add-ns c (module "constraints.toc"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "f7b5678"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "08058d6"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "d33cc65"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "872e590"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "cb55c51"))
(add-ns ev (git-dependency "https://github.com/Toccata-Lang/eval.git"
                           "eval.toc"
                           :sha "70e8f5f"))
(add-ns interp (git-dependency "https://github.com/Toccata-Lang/eval.git"
                               "interpreter.toc"
                               :sha "70e8f5f"))
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "6b65dea"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "ea738c4"))
(add-ns strm (git-dependency "https://github.com/Toccata-Lang/stream.git"
                             "stream.toc"
                             :sha "af43750"))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(def string-writer (agent ""))
(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def Tagged (comp ast/SymbolOrString
                  rdr/tagged-symbol))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "")

(defn line-marker [file-name line-number marker]
  (either (and (= "" file-name)
               (maybe "\n#\n"))
          ["\n" marker "\n#line "
           (str line-number) " " "\""
           (either (and (= 'core file-name)
                        (maybe path-to-core))
                   file-name)
           "\"\n"]))

(defn line-macro [ast marker]
  (sm/state-maybe (line-marker (ast/file-name ast) (ast/line-number ast) marker)))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringBufferType "String"
                 SubStringType "String"
                 FnArityType "FnArity"
                 FunctionType "Fn"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"
                 UnknownType "UnknownType"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-type-nums {'Integer IntegerType
                     'StringBuffer StringBufferType
                     'SubString SubStringType
                     'FnArity FnArityType
                     'Function FunctionType
                     'Fn FunctionType
                     'List ListType
                     'Maybe MaybeType
                     'Vector VectorType
                     'Symbol SymbolType
                     'BitmapIndexedNode BitmapIndexedType
                     'ArrayNode ArrayNodeType
                     'HashCollisionNode HashCollisionNodeType
                     'Promise PromiseType
                     'Future FutureType
                     'Agent AgentType
                     'Opaque OpaqueType
                     'TypeCount TypeCount})

(def fn-constraint (c/TypeConstraint {FunctionType #{}} empty-list 'Fn nothing ""))
(def sym-constraint (c/TypeConstraint {SymbolType #{}} empty-list 'Symbol nothing ""))
(def vect-constraint (c/TypeConstraint {VectorType #{}} empty-list 'Vector nothing ""))
(def list-constraint (c/TypeConstraint {ListType #{}} empty-list 'List nothing ""))

(deftype TypeInfo [sym type-map]
  (assert (instance? HashMap type-map))

  Stringable
  (string-list [_]
    (list "<TypeInfo " (str sym) ">"))

  Type
  (type-mapping [_]
    type-map))

(def core-types {IntegerType (TypeInfo 'Integer {IntegerType #{}})
                 StringBufferType (TypeInfo 'String {StringBufferType #{}})
                 SubStringType (TypeInfo 'String {SubStringType #{}})
                 FnArityType (TypeInfo 'FnArity {FnArityType #{}})
                 FunctionType (TypeInfo 'Fn {FunctionType #{}})
                 ListType (TypeInfo 'List {ListType #{}})
                 MaybeType (TypeInfo 'Maybe {MaybeType #{}})
                 VectorType (TypeInfo 'Vector {VectorType #{}})
                 SymbolType (TypeInfo 'Symbol {SymbolType #{}})
                 BitmapIndexedType (TypeInfo 'BitmapIndexedNode {BitmapIndexedType #{}})
                 ArrayNodeType (TypeInfo 'ArrayNode {ArrayNodeType #{}})
                 HashCollisionNodeType (TypeInfo 'HashCollisionNode {HashCollisionNodeType #{}})
                 PromiseType (TypeInfo 'Promise {PromiseType #{}})
                 FutureType (TypeInfo 'Future {FutureType #{}})
                 AgentType (TypeInfo 'Agent {AgentType #{}})
                 OpaqueType (TypeInfo 'Opaque {OpaqueType #{}})})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params result-constraint])

  ;; Does 'ast' produce any executable code when emitted?
  ;; TODO: eliminate this in favor of using sum types
  (produces-code? [ast]
    (assert-result x (instance? Maybe x))
    (maybe ast))

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; produce a constraint from an assertion ast
  (to-constraint [ast]
    (sm/state-maybe c/top-type))

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x)))

  ;; unpack the 'list-var' and bind the items to the 'elem-vars'
  (bind-list [list-var params]
    (assert (instance? ast/params-ast params)))

  ;; get the constraints for a symbol or params-ast
  (get-param-constraints [_ constraint-map]
    (assert-result x (instance? sm/new-sm x)))

  ;; update the constraint map for symbol
  (constrain-sym [sym constraint]
    (sm/state-maybe constraint))

  (update-call-site-count [_]
    (assert-result x (instance? sm/new-sm x)))

  (call-site-meta-data [c-var file-name line-number]
    (assert-result x (instance? sm/new-sm x)))

  ;; encode a static representation of a core data structure
  (encode [m]
    (emit m))
  (encode [m var-prefix])

  ;; encode a statically initialized representation of a core data structure
  (encode-static [m]
    ;; (print-err 'encode-static (get-type m) (type-name m) m)
    (zero sm/state-maybe))

  (runtime-check [constraint value-info file-name line-number]
    ;; generated code must preserve ref counts
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            (runtime-check constraint value-info
                           (either (= "\"\"" file-name)
                                   (str "\"at " file-name ": " line-number "\"")))))

  (runtime-check [constraint value-info sym-location]))

(defprotocol Assertion
  (assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (return-assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (assert-type [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (assert-return-type [ast]
    (assert-result x (instance? Maybe x))
    nothing))

(defn destruct-seq [seq-c-var elem-c-vars dest-args file-name line-num]
  (assert (instance? Tagged seq-c-var))
  (assert (instance? Tagged dest-args))

  (let [elem-count (count elem-c-vars)]
    [(map elem-c-vars (fn [var]
                        ["Value *" var ";" line-sep]))
     "Value **" dest-args "[" elem-count "] = {"
     (interpose (map elem-c-vars (fn [var] ["&" var])) ", ")
     "};" line-sep "destructValue(\"" file-name "\", \"" line-num
     "\", (Value *)" seq-c-var ", " elem-count ", "
     dest-args ");" line-sep]))

(deftype FnValPtr [var]
  ;; pointer to a Fn struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ArityValPtr [var struct]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype StaticFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ProtoDispFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(def CFnPtr (comp StaticFnPtr
                  ProtoDispFnPtr))

(def PointerVar (comp FnValPtr
                      ArityValPtr
                      CFnPtr))

(extend-type PointerVar
  Stringable
  (string-list [x]
    (list (str (.var x))))

  Hashable
  (sha1 [x]
    (sha1 (.var x)))

  (sha1-update [x context]
    (sha1-update (.var x) context)))

(defprotocol C-Code
  (expr-constraints [expr]
    (assert-result x (instance? c/Constraints x)))
  (collapse-expressions* [x y]))

(defn expr-type-num [expr]
  (either (-> expr
              expr-constraints
              c/extract-type-map
              (flat-map (fn [type-map]
                          (let [type-nums (keys type-map)]
                            (and (= 1 (count type-nums))
                                 (first type-nums))))))
          UnknownType))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; refs-map: map of C variables that are used in 'init' and how many times

(deftype empty-code [c-var init decl refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def empty-c-code (empty-code "" [] [] {} {}))

(defn conflicting-assertions [constraints file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (c/format-path (c/MultiConstraint constraints) 0)))
  (abort))

(defn compose-constraints [file-name line-number x y]
  (assert (instance? c/Constraints x))
  (assert (instance? c/Constraints y))

  (let [z (comp x y)]
    (and (= c/bottom-type z)
         (let [constraints (either (and (< 1 (count (.constraints z)))
                                        (maybe (.constraints z)))
                                   [x y])]
           (maybe (conflicting-assertions constraints file-name line-number))))
    z))

(deftype c-code [c-var init decl refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-reified [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Reified " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-str [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-String " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-int [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Int " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-static-sym [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Symbol " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ", " (str c-struct) ">")))

(deftype c-vector-fn [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Vector-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-list-fn [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-List-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-protocol-fn [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Protocol-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-fn [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Function " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(deftype c-static-val [c-var init decl refs-map constraints c-struct]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Static-Value " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">")))

(def C-Static-Value (comp c-static-int
                          c-static-str
                          c-static-sym
                          c-static-reified
                          c-list-fn
                          c-vector-fn
                          c-static-fn
                          c-protocol-fn
                          c-static-val))

(extend-type C-Static-Value
  Emitter
  (encode-static [x]
    (sm/state-maybe x)))

(def C-Value (comp c-code
                   C-Static-Value))

(extend-type C-Value
  Collection
  (empty? [c]
    (and (empty? (.init c))
         (empty? (.decl c))
         (empty? (.constraints c))))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing))

;; same as 'c-code', but defines a function parameter
(deftype c-param [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Param " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing))

(def C-expr (comp empty-code
                  C-Value
                  c-param
                  c-init))

(defn add-constraint [expr constraint file-name line-number]
  (let [constraints (either (get-in expr [.constraints (.c-var expr)])
                            c/top-type)]
    (.constraints expr {(.c-var expr) (compose-constraints file-name line-number constraints constraint)})))

(extend-type empty-code
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (comp* y (rest xs))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    y))

(extend-type c-param
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (collapse-expressions* x y))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [init (either (or (for [refs (get-in y [.refs-map (.c-var x)])]
                             [(.init x)
                              (either (and (< refs 2)
                                           (maybe ""))
                                      ["incRef(" (.c-var x) ", " (dec refs) ");" line-sep])
                              (.init y)])
                           (and (= "" (.c-var x))
                                (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" (.c-var x) ", 1);" line-sep
                        (.init y)])
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           (.c-var x))
          refs-map (assoc refs-map (.c-var x) 0)]
      (c-code (.c-var y)
              init [(.decl x) (.decl y)] refs-map
              (merge-with (partial compose-constraints (.file-name x) (.line-number x))
                          (.constraints x) (.constraints y))))))

(extend-type c-init
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))]
                     (collapse-expressions* x y))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          init [(.init x)
                (either (for [constraint (get (.constraints y) c-var)
                              value-info (or (get (.constraints x) c-var)
                                             (maybe c/top-type))]
                          (-> constraint
                              (c/update-var c-var)
                              (runtime-check value-info file-name line-number)))
                        "")
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [(either (and (< refs 2)
                                            (maybe ""))
                                       ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          constraints-map (merge-with (partial compose-constraints file-name line-number)
                                      (.constraints x) (.constraints y))]
      (-> y
          (.init init)
          (.decl [(.decl x) (.decl y)])
          (.refs-map refs-map)
          (.constraints constraints-map)))))

(extend-type C-Value
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (-> y
                         (.init [(.init x) (.init y)])
                         (.decl [(.decl x) (.decl y)])
                         (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
                         (.constraints (merge-with comp (.constraints x) (.constraints y)))))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [x (either (and (empty? (.init x))
                         (maybe (.refs-map x {})))
                    x)]
      (-> y
          (.init [(.init x) (.init y)])
          (.decl [(.decl x) (.decl y)])
          (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
          (.constraints (merge-with comp (.constraints x) (.constraints y)))))))

(defn collapse-expressions [cs]
  (either (or (and (empty? cs)
                   (maybe empty-c-code))
              (and (empty? (rest cs))
                   (first cs)))
          (let [[c & cs] cs]
            (collapse-expressions* c (collapse-expressions cs)))))

(deftype Closures [closures refs-map constraints]
  (assert (instance? Vector closures))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints)))

(def empty-closures (Closures [] {} {}))

(deftype ConstantValues [numbers strings symbols type-names other]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names)))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count syms context-syms closed-over]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols types declarations]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; types            map of type symbols to type definitions
  (assert (instance? HashMap types))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [fn-context rt-init modules fns namespaces constants reify-fn-index type-maps]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit rt-init))
  ;; modules                info for each module compiled
  (assert (instance? HashMap modules))
  ;; fns                    static functions
  (assert (instance? HashMap fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))

  Stringable
  (string-list [_] (list "<GlobalContext>")))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      new-context (comp (-> curr-fn-context .context-syms)
                                        (-> curr-fn-context .syms))]
                  (maybe [curr-fn-context
                          (.fn-context s (FunctionArityContext {} 0 {} new-context empty-closures))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.fn-context s) (.fn-context s new-fn-context)])))))

(defn extract-sym-path [s sym]
  (let [file-name (ast/file-name sym)]
    (flat-map (rdr/namespace sym)
              (fn [ns-sym]
                (or (get-in (.namespaces s) [file-name ns-sym])
                    (get-in (.namespaces s) [file-name (rdr/tag ns-sym)]))))))

(defn sym-ns-path [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (map (extract-sym-path s sym) (fn [path]
                                                   [path s]))
                   (maybe [(ast/file-name sym) s])))))

(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str (list* start (seq remaining))))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (either (check-C-var (str sym "_"))
                                       arg-name)
                               sym-count)
                          new-ctxt]))))))

(deftype ParamBinding [vars destruct]
  (assert (instance? Vector vars))
  (assert (instance? Vector destruct))

  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (vec (cons x xs))]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name] (sm/state-maybe (gensym (str "g_" arg-name))))
  ([sym arg-name]
   (sm/state-maybe (gensym (str "g_" (either (check-C-var (str sym "_"))
                                             arg-name))))))


(deftype ProtoImpl [dispatch-type c-var ast param-constraints result-constraints c-fn]
  (assert (instance? ArityValPtr c-var))
  (assert (instance? Integer dispatch-type))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ResultConstraint result-constraints))
  (assert (instance? CFnPtr c-fn))

  Stringable
  (string-list [_] (list "<ProtoImpl type: " (target-type-name dispatch-type) " " (str c-var) " "
                         (str c-fn) ">"))

  Emitter
  (encode [x]
    (encode-static x))

  (encode-static [_]
    (either (and (= "" (.var c-var))
                 (maybe (zero sm/state-maybe)))
            (sm/state-maybe (c-static-val (str "(Value *)" c-var) [] [] {} {} (.struct c-var))))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [protos (get-in s [.modules path .protocols])
                           _ (some (vals protos) (fn [proto] (get proto fn-sym)))]
                       [path s]))))

(defn find-protocol-path [fn-sym]
  (comp (for [path (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym path)]
          path)
        (lookup-protocol-path fn-sym 'core)))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(defn new-proto-impl [proto-sym fn-sym arg-count dispatch-type var ast param-constraints result-constraints c-fn]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-sym))
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/fn-arity-ast ast))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ResultConstraint result-constraints))
  (assert (instance? ArityValPtr var))
  (assert (instance? CFnPtr c-fn))

  (for [protocol-path (find-protocol-path fn-sym)
        _ (sm/assoc-in-val [.modules protocol-path .protocols proto-sym fn-sym arg-count dispatch-type]
                           (ProtoImpl dispatch-type var ast param-constraints result-constraints c-fn))]
    ""))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [path (either (extract-sym-path s proto-sym)
                                      (ast/file-name proto-sym))]
                     (for [proto-info (-> (.modules s)
                                          (get path)
                                          (flat-map (fn [module]
                                                      (get (.protocols module) proto-sym))))]
                       [proto-info s]))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.protocols module) proto-sym))))]
                     [proto-info s])))))

;; TODO: it feels like these 2 arities are too different
(defn get-proto-impl
  ([fn-name arg-count type-num]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (or (let [proto-path (either (extract-sym-path s fn-name)
                                             (ast/file-name fn-name))]
                      (for [protocols (get-in s [.modules proto-path .protocols])
                            impl-info (some (vals protocols)
                                            (fn [dispatchers]
                                              (get-in dispatchers [fn-name arg-count type-num])))]
                        [impl-info s]))
                    (for [protocols (get-in s [.modules 'core .protocols])
                          impl-info (some (seq protocols)
                                          (fn [[proto-name dispatchers]]
                                            (get-in dispatchers [fn-name arg-count type-num])))]
                      [impl-info s])))))
  ([proto-sym fn-sym arg-count type-num]
   (flat-map (sm/new-sm (fn [s]
                          (maybe [(either (extract-sym-path s proto-sym)
                                          (ast/file-name proto-sym))
                                  s])))
             (fn [proto-path]
               (comp (sm/get-in-val [.modules proto-path .protocols proto-sym fn-sym arg-count type-num])
                     (sm/get-in-val [.modules 'core .protocols proto-sym fn-sym arg-count type-num])
                     ;; (compilation-error "Invalid protocol fn:"
                     ;;                    (str "'" fn-sym "' in")
                     ;;                    (str (ast/file-name fn-sym) ",")
                     ;;                    (ast/line-number fn-sym))
                     )))))

(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.modules s)
                   (get (ast/file-name sym))
                   (flat-map (fn [module]
                               (map (get-in (.declarations module) [sym '_])
                                    (fn [expr]
                                      [expr s]))))))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

(defn find-global-sym [sym]
  ;; Attempt to look up the global (ie. not closed over) value given a symbol.
  (for [ns-path (sym-ns-path sym)
        expr (sm/get-in-val [.modules ns-path .values sym])]
    expr))

;; This is so hideous on purpose. It's called *A LOT* so I unwound it for performance's sake
(defn lookup-sym [sym]
  ;; Look up a value given a symbol. Will abort if the symbol cannot be found.
  (let [sym-file (ast/file-name sym)]
    (comp (sm/new-sm
           (fn [s]
             (assert (instance? GlobalContext s))
             (let [ctxt (.fn-context s)
                   syms (.syms ctxt)
                   modules (.modules s)
                   closed-over (.closed-over ctxt)
                   closures (.closures closed-over)
                   refs-map (.refs-map closed-over)]
               (or (map (or (and (rdr/namespace sym)
                                 (or (-> (flat-map (extract-sym-path s sym)
                                                   (fn [x]
                                                     (get modules x)))
                                         (flat-map (fn [module]
                                                     (let [values (.values module)]
                                                       (or (get values (.base sym))
                                                           (get values (rdr/tag (.base sym))))))))
                                     (do
                                       (print-err "Undefined symbol" (str "'" sym "'") "at"
                                                  (str sym-file ":")
                                                  (ast/line-number sym))
                                       (maybe (abort)))))
                            (get syms sym))
                        (fn [expr]
                          [expr s]))
                   (map (-> ctxt .context-syms (get sym))
                        (fn [sym-info]
                          (either (some closures
                                        (fn [[closure-var sym-literal]]
                                          (and (= sym sym-literal)
                                               (map (get refs-map closure-var)
                                                    (fn [refs-count]
                                                      (let [new-refs-map (assoc refs-map closure-var (inc refs-count))
                                                            new-closed-over (.refs-map closed-over new-refs-map)
                                                            new-ctxt (.closed-over ctxt new-closed-over)]
                                                        [(c-code closure-var [] [] {closure-var 1}
                                                                 {closure-var (expr-constraints sym-info)})
                                                         (.fn-context s new-ctxt)]))))))
                                  (let [sym-count (.sym-count ctxt)
                                        closure-var (str "val" sym-count)
                                        new-sym-count (inc sym-count)
                                        new-closures (conj closures [closure-var sym (expr-constraints sym-info)])
                                        new-refs-map (assoc refs-map closure-var 1)
                                        new-closed-over (-> closed-over
                                                            (.closures new-closures)
                                                            (.refs-map new-refs-map))
                                        new-ctxt (-> ctxt
                                                     (.sym-count new-sym-count)
                                                     (.closed-over new-closed-over))]
                                    [(c-code closure-var [] [] {closure-var 1}
                                             {closure-var (expr-constraints sym-info)})
                                     (.fn-context s new-ctxt)]))))
                   (map (or (flat-map (get modules sym-file)
                                      (fn [module]
                                        (or (get (.values module) sym)
                                            (get-in (.declarations module) [sym '_]))))
                            (flat-map (get modules 'core)
                                      (fn [module]
                                        (get (.values module) sym))))
                        (fn [expr] [expr s]))
                   (do
                     (print-err "Undefined symbol" (str "'" sym "'") "at"
                                (str sym-file ":")
                                (ast/line-number sym))
                     (abort)))))))))

(extend-type c/ItemsConstraint
  c/Constraint
  (c/extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            (either (and (empty? (.items-constraints constraint))
                         (maybe []))
                    [(-> (c/TypeConstraint {ListType #{} VectorType #{}} (.path constraint) 'Sequence
                                           (.sym constraint) (.var constraint))
                         (runtime-check value-info sym-location))
                     (let [min-count (str (count (.items-constraints constraint)))]
                       ["if (countSeq(incRef(" (.var constraint) ", 1)) < " min-count ") {"
                        "\n#ifndef EMBEDDED\n"
                        "fprintf(stderr, \"Insufficient values for '"
                        (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");\n"
                        "fprintf(stderr, \"Needed " min-count
                        ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, "
                        (.var constraint) "))->numVal);" line-sep
                        "fprintf(stderr, \"" (interpose (c/format-path constraint (inc (count (.path constraint))))
                                                        "\\n")
                        "\\n\");\n#endif\nabort();" line-sep "}\n"])
                     "if (1) {\n"
                     "incRef(" (.var constraint) ", 1);" line-sep
                     (let [items (map (range (inc (count (.items-constraints constraint))))
                                      (partial str (.var constraint) "_"))]
                       [(destruct-seq (.var constraint) items (str (.var constraint) "_args") "" 9999)
                        (for [[constraints item] (zip-lists (.items-constraints constraint) items)]
                          (let [constraints (either (map (.sym constraint) (fn [sym]
                                                                             (c/update-sym constraints sym)))
                                                    constraints)]
                            (-> constraints
                                (c/update-var item)
                                (runtime-check value-info sym-location))))
                        (map items (fn [item]
                                     (str "dec_and_free(" item ", 1);" line-sep)))])
                     "}" line-sep]))))

(extend-type c/NoValues
  Emitter
  (runtime-check [constraint value-info sym-location]
    ["abort();\n#\n"]))

(extend-type c/AllValues
  Emitter
  (emit [constraint]
    (sm/state-maybe empty-c-code))

  (runtime-check [constraint value-info sym-location]
    []))

(extend-type c/TypeConstraint
  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["switch (" (.var constraint) "->type) {" 
             (map (keys (.type-maps constraint)) (fn [type-num]
                                                   ["case " type-num ": " ]))
             "break; default:"
             "\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Invalid type of value for '"
             (either (.sym constraint) "<unknown>") "' %s\\n\", " sym-location ");\n"
             "fprintf(stderr, \"Needed " (str (.type-sym constraint))
             ", got %s\\n\", extractStr(type_name(empty_list, " (.var constraint) ")));" 
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             "\n#endif\nabort();" "}" ])))

(extend-type c/ResultConstraint
  Emitter
  (runtime-check [constraint value-info sym-location]
    ;; TODO: perhaps this should be implemented
    [])
  
  (produces-code? [ast] nothing)

  (to-constraint [ast]
    (sm/state-maybe ast))

  Assertion
  (return-assertion? [ast] (maybe ast)))

(extend-type c/SymbolConstraints
  Emitter
  (to-constraint [ast]
    (sm/state-maybe ast))

  (tail-call [constraint _ _] constraint)

  (produces-code? [_] nothing)

  (replace-syms [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs old-sym)]
              (sm/state-maybe (c/update-sym constraint new-sym)))
            (sm/state-maybe constraint)))

  (emit [constraint]
    (let [[file-name line-number] (either (first (.path constraint))
                                          ["" 0])]
      (either (map (.sym constraint)
                   (fn [sym]
                     (for [sym-info (lookup-sym sym)
                           :let [var (.constraints sym-info (merge-with (partial compose-constraints
                                                                                 file-name line-number)
                                                                        (.constraints sym-info)
                                                                        {(.c-var sym-info)
                                                                         (c/update-var constraint (.c-var sym-info))}))]
                           _ (set-sym sym var)]
                       (.refs-map var (dissoc (.refs-map sym-info) (.c-var sym-info))))))
              (sm/state-maybe empty-c-code))))

  Assertion
  (assertion? [constraint]
    (maybe constraint))

  c/Constraint
  (c/update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path)))))

(extend-type c/FieldConstraint
  Emitter
  (emit [constraint]
    (let [[file-name line-number] (either (first (.path constraint))
                                          ["" 0])]
      (either (map (.sym constraint)
                   (fn [sym]
                     (for [sym-info (lookup-sym sym)
                           field-var (lookup-sym (.field constraint))
                           :let [var (.constraints sym-info (merge-with (partial compose-constraints
                                                                                 file-name line-number)
                                                                        (.constraints sym-info)
                                                                        {(.c-var sym-info)
                                                                         (-> constraint
                                                                             (.field-var (.c-var field-var))
                                                                             (c/update-var (.c-var sym-info)))}))]
                           _ (set-sym sym var)]
                       (.refs-map var (dissoc (.refs-map sym-info) (.c-var sym-info))))))
              (sm/state-maybe empty-c-code))))

  (runtime-check [constraint value-info sym-location]
    (either (and (c/satisfied-by constraint value-info)
                 (maybe ""))
            ["if(1) {\n"
             "Value *dork = hasField(empty_list, incRef(" (.var constraint) ", 1), "
             (.field-var constraint) ");\n" "if (isNothing(dork,\"\",0)) {\n#ifndef EMBEDDED\n"
             "fprintf(stderr, \"Value '" (either (.sym constraint) "<unknown>")
             "' of type '%s' does not have field '"
             (.field constraint) "' %s\\n\", extractStr(type_name(empty_list, "
             (.var constraint) ")), " sym-location ");\n" 
             "fprintf(stderr, \""
             (interpose (c/format-path constraint (inc (count (.path constraint)))) "\\n")
             "\\n\");"
             "\n#endif\n"
             "abort();" 
             "}\ndec_and_free(dork, 1);\n}\n"])))

(extend-type c/MultiConstraint
  Emitter
  (runtime-check [constraint value-info sym-location]
    (either (and (or (some (.constraints constraint)
                           (partial instance? c/StaticConstraints))
                     (c/satisfied-by constraint value-info))
                 (maybe ""))
            (do
              ;; TODO: minimize the runtime checks
              ;; TODO: make this like ItemsConstraints
              (map (.constraints constraint)
                   (fn [c]
                     (runtime-check c value-info sym-location))))))

  (emit [constraint]
    (map (ev/traverse (.constraints constraint) emit)
         (fn [[expr & exprs]]
           (comp* expr exprs)))))

(extend-type List
  Emitter
  (tail-call [asts args result-constraint]
    (let [asts (reverse asts)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args result-constraint)
                    (cons init)
                    reverse))))))

(defn encodeVectorInfo [v]
  (inline C Vector "
  Vector *v = (Vector *)v_0;

  Vector *array = empty_vect;
  for (int i = 0; i < v->count; i++) {
    Value *val = v->tail[i];
    incRef(val, 1);
    array = mutateVectConj(array, val);
  }

  Vector *result = empty_vect;
  result = mutateVectConj(result, integerValue(v->shift));
  result = mutateVectConj(result, integerValue(v->tailOffset));
  if (v->root != (VectorNode *)0) {
    fprintf(stderr, \"Encode Vector root\\n\");
    abort();
  } else {
    result = mutateVectConj(result, nothing);
  }
  result = mutateVectConj(result, (Value *)array);

  dec_and_free(v_0, 1);
  return((Value *)result);
  "))

(def vector-array-len (inline C List "(Value *)&(Integer){IntegerType,-1,VECTOR_ARRAY_LEN}"))

(extend-type Vector
  Emitter
  (encode-static [v]
    (let [[shift offset root array] (encodeVectorInfo v)]
      (for [items (ev/traverse array encode-static)
            root (either (map root encode-static)
                         (sm/state-maybe (c-static-val "NULL" [] [] {} {} "NULL")))
            struct (global-var "vect_")
            var (global-var "vect_")]
        (comp* empty-c-code (comp items
                                  (let [items (either (and (empty? items)
                                                           (maybe "0"))
                                                      (interpose (map items
                                                                      (fn [expr]
                                                                        (str "(Value *)&" (.c-struct expr))))
                                                                 ", "))]
                                    [(c-static-val var []
                                                   ["Vector " struct " = {VectorType, -1, "
                                                    (str (count array))
                                                    ", " (str shift) ", " (str offset) ", "
                                                    (.c-struct root) ", " items
                                                    (map (range (- vector-array-len (count array))) (fn [_] ", 0"))
                                                    "};" line-sep
                                                    "Value *" var "= (Value *)&" struct ";" line-sep]
                                                   {} {} struct)]))))))

  (tail-call [asts params result-constraint]
    (either (flat-map (last asts)
                  (fn [tail]
                    (store asts (dec (count asts))
                           (tail-call tail params result-constraint))))
            asts)))

(deftype TailHashMap [m]
  Emitter
  (emit [_]
    (map (encode m)
         (fn [expr]
           (.init expr (comp (.init expr) ["return(" (.c-var expr) ");" line-sep]))))))

(defn bmiArray [m]
  (inline C Vector "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  int cnt = __builtin_popcount(node->bitmap);
  Vector *v = empty_vect;
  for (int i = 0; i < cnt * 2; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe(empty_list, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(defn bmiBitmap [m]
  (inline C Integer "
  BitmapIndexedNode *node = (BitmapIndexedNode *)m_0;
  Value *result = integerValue(node->bitmap);
  dec_and_free(m_0, 1);
  return((Value *)result);
  "))

(extend-type BitmapIndexedNode
  Emitter
  (encode-static [m]
    (for [items (ev/traverse (bmiArray m) (fn [v]
                                            (either (map v (fn [v]
                                                             (map (encode-static v) maybe)))
                                                    (sm/state-maybe nothing))))
          struct (global-var "bmi_")
          var (global-var "bmi_")]
      (comp* empty-c-code (comp (map items (fn [v] (either v empty-c-code)))
                                (let [items (either (and (empty? items)
                                                         (maybe "0"))
                                                    (interpose (map items
                                                                    (fn [v]
                                                                      (either (map v (fn [expr]
                                                                                       (str "(Value *)&"
                                                                                            (.c-struct expr))))
                                                                              "NULL")))
                                                               ", "))]
                                  [(c-static-val var []
                                                 ["BitmapIndexedNode " struct " = {BitmapIndexedType, -1, "
                                                  (str (bmiBitmap m))
                                                  ", " items
                                                  "};" line-sep
                                                  "Value *" var "= (Value *)&" struct ";" line-sep]
                                                 {} {} struct)]))))))

(defn arrayNodeArray [m]
  (inline C Vector "
  ArrayNode *node = (ArrayNode *)m_0;
  Vector *v = empty_vect;
  for (int i = 0; i < ARRAY_NODE_LEN; i++) {
    Value *val = node->array[i];
    if (val == (Value *)0)
      v = mutateVectConj(v, (Value *)nothing);
    else {
      incRef(val, 1);
      v = mutateVectConj(v, maybe(empty_list, (Value *)0, val));
    }
  }
  dec_and_free(m_0, 1);
  return((Value *)v);
  "))

(extend-type ArrayNode
  Emitter
  (encode-static [m]
    (for [items (ev/traverse (arrayNodeArray m) (fn [v]
                                                  (either (map v (fn [v]
                                                                   (map (encode-static v) maybe)))
                                                          (sm/state-maybe nothing))))
          struct (global-var "arrayNode_")
          var (global-var "arrayNode_")]
      (comp* empty-c-code (comp (map items (fn [v] (either v empty-c-code)))
                                (let [items (either (and (empty? items)
                                                         (maybe "0"))
                                                    (interpose (map items
                                                                    (fn [v]
                                                                      (either (map v (fn [expr]
                                                                                       (str "(Value *)&"
                                                                                            (.c-struct expr))))
                                                                              "NULL")))
                                                               ", "))]
                                  [(c-static-val var []
                                                 ["ArrayNode " struct " = {ArrayNodeType, -1, " items "};"
                                                  line-sep "Value *" var "= (Value *)&" struct ";" line-sep]
                                                 {} {} struct)]))))))

(extend-type HashMap
  Emitter
  (emit [m]
    (comp (encode-static m)
          (encode m)))

  (tail-call [m params result-constraint]
    (TailHashMap m))

  (encode [m] (encode m "var_"))

  (encode [m var-prefix]
    (comp (encode-static m)
          (for [map-var (global-var var-prefix)
                :let [_ (write-strings [["Value *" map-var " = (Value *)&emptyBMI;\n"]])]
                assocs (ev/traverse (seq m)
                                    (fn [[sym var]]
                                      (for [sym-var (either (and (instance? Tagged sym)
                                                                 (maybe (emit (ast/quoted-ast sym))))
                                                            (emit sym))
                                            expr (comp (encode-static var)
                                                       (encode var))]
                                        (do
                                          (write-strings [(.decl sym-var) (.decl expr)])
                                          [(.init sym-var) (.init expr)
                                           map-var " = hashMapAssoc((Value *)" map-var
                                           ", incRef(" (.c-var sym-var) ", 1), " (.c-var expr) ");\n"]))))]
            (c-code map-var
                    (comp* [] assocs)
                    [] {} {})))))


(deftype StaticArityInfo [c-var param-constraints result-constraint]
  (assert (instance? CFnPtr c-var))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ValueConstraint result-constraint))

  Stringable
  (string-list [_]
    (list "<StaticArityInfo " (str c-var) " " (str param-constraints) " " (str result-constraint) ">")))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity-info [fn-var num-params]
  (assert (instance? FnPTr fn-var))
  
  (sm/get-in-val [.fns fn-var num-params]))

(defn lookup-core-fn-arity [sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [module (get (.modules s) 'core)
                     fn-sym (get (.values module) sym)
                     expr (get-in (.fns s) [(.c-var fn-sym) num-args .c-var])]
                 [expr s]))))


(extend-type ast/block-comment-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] {} {})))

  (emit-defined-value [_ x] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe []))

  (tail-call [ast params result-constraint] ast))

(defn make-static-string [str-val]
  ;; TODO: when adding meta data, make sure to update this as well
  (let [str-len (count str-val)]
    (comp (sm/get-in-val [.constants .strings str-val])
          (for [str-idx (sm/new-sm (fn [s]
                                     (assert (instance? GlobalContext s))
                                     (-> s
                                         .constants
                                         .strings
                                         count
                                         (vector s)
                                         maybe)))
                :let [str-sym (str "str" str-idx)
                      str-ptr (str "strPtr" str-idx)]
                _ (sm/assoc-in-val [.constants .strings str-val]
                                   (c-static-str str-ptr [] [] {}
                                                 {str-ptr (c/TypeConstraint {StringBufferType #{}} empty-list
                                                                          'String nothing str-ptr)}
                                                 str-sym))]
            (c-static-str str-ptr
                          []
                          ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
                           (inc str-len)
                           "];\n} " str-sym " = {StringBufferType, -1, "
                           str-len ", 0, \"" (escape-chars str-val) "\"};\n"
                           "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
                          {} {str-ptr (c/TypeConstraint {StringBufferType #{}} empty-list 'String nothing str-ptr)}
                          str-sym)))))

(defn get-type-info [path type-symbol]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [modules (.modules s)]
                 (for [type-num (or (flat-map (get modules path)
                                              (fn [module]
                                                (get (.types module) type-symbol)))
                                    (flat-map (get modules 'core)
                                              (fn [module]
                                                (get (.types module) type-symbol))))
                       type-map (get-in s [.type-maps type-num .type-map])]
                   [type-map s])))))

(defn get-type-sym-info [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-info (get-type-info ns-path type-symbol)]
          type-info)
        (sm/state-maybe {})))

(defn type-constraint [type-num file-name line-number]
  (comp (for [type-info (sm/get-in-val [.type-maps type-num])]
          (either (and (empty? (.type-map type-info))
                       (maybe c/top-type))
                  (-> (.type-map type-info)
                      (c/TypeConstraint empty-list (.sym type-info) nothing "")
                      (c/update-path file-name line-number))))
        (sm/state-maybe c/top-type)))

(defn get-type-numbers [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-info ns-path type-symbol)]
          (set (keys type-nums)))
        (sm/state-maybe #{})))

(defn get-type-number [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-info ns-path type-symbol)]
          (either (and (= 1 (count type-nums))
                       (first (keys type-nums)))
                  UnknownType))
        (sm/state-maybe UnknownType)))

(extend-type HashSet
  Emitter
  (encode-static [hs]
    (for [m (encode-static [(.set-map hs)])
          type-num (get-type-number (maybe (rdr/tag 'HashSet)))
          :when-not (= 0 type-num)
          struct (global-var "set_")
          var (global-var "set_")]
      (comp m (c-static-val var []
                            ["ReifiedVal " struct " = {" (str type-num) ", -1, (Value *)&" (.c-struct m) ", 0, 0};\n"
                             "Value *" var " = (Value *)&" struct ";" line-sep]
                            {} {} struct))))

  (emit [hs]
    (for [expr (encode (.set-map hs))
          var (genlocal "set_")]
      (-> expr
          (.c-var var)
          (.init (comp (.init expr) ["Value *" var " = newHashSet(empty_list, " (.c-var expr) ");" line-sep]))))))

(extend-type ast/assert-ast
  Assertion
  (assertion? [ast]
    (maybe ast))

  (assert-type [ast]
    (assert-type (.assertion ast)))

  Emitter
  (replace-bound-vars [ast subs]
    (ast/assert-ast (replace-bound-vars (.assertion ast) subs)))

  (replace-syms [ast subs]
    (map (replace-syms (.assertion ast) subs)
         (fn [assertion]
           (ast/assert-ast assertion))))

  (produces-code? [ast]
    nothing)

  (emit [ast]
    (-> (.assertion ast)
        (c/update-path (ast/file-name ast) (ast/line-number ast))
        emit))

  (tail-call [ast params result-constraint] ast))

(extend-type ast/type-assertion
  Emitter
  (replace-bound-vars [ast subs]
    (.sym ast (either (get subs (.sym ast))
                      (.sym ast))))

  (replace-syms [ast subs]
    (sm/state-maybe (.sym ast (either (get subs (.sym ast))
                                      (.sym ast)))))

  (to-constraint [ast]
    (let [sym (.type-sym ast)
          file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (comp (map (get-type-sym-info (maybe sym))
                 (fn [type-info]
                   (either (and (empty? type-info)
                                (maybe c/top-type))
                           (-> type-info
                               (c/TypeConstraint empty-list sym nothing "")
                               (c/update-path file-name line-number)))))
            (sm/state-maybe c/top-type))))

  (emit [ast]
    (for [constraint (to-constraint ast)
          _ (constrain-sym (.sym ast) constraint)
          var (lookup-sym (.sym ast))]
      (c-code "" [] [] {} (.constraints var))))

  Assertion
  (assert-type [ast]
    (maybe (.type-sym ast))))

(extend-type ast/min-count-assertion
  Emitter
  (replace-bound-vars [ast subs]
    (.sym ast (either (get subs (.sym ast))
                      (.sym ast))))


  (replace-syms [ast subs]
    (sm/state-maybe (either (for [new-sym (get subs (.sym ast))]
                              (.sym ast new-sym))
                            ast)))

  (produces-code? [ast]
    nothing)

  (to-constraint [ast]
    (sm/state-maybe (c/ItemsConstraint (repeat (.len ast) c/top-type)
                                     (list [(ast/file-name ast) (ast/line-number ast)])
                                     nothing
                                     "")))

  (emit [ast]
    (for [var (lookup-sym (.sym ast))]
      (c-code "" [] [] {}
              {(.c-var var) (-> (c/ItemsConstraint (repeat (.len ast) c/top-type)
                                                 (list [(ast/file-name ast) (ast/line-number ast)])
                                                 nothing
                                                 "")
                                (c/update-var (.c-var var))
                                (c/update-sym (.sym ast)))}))))

(extend-type ast/result-ast
  Assertion
  (return-assertion? [ast] (maybe ast))

  Emitter
  (emit [ast]
    (sm/state-maybe empty-c-code))

  (produces-code? [ast] nothing)

  (to-constraint [ast]
    (to-constraint (.assertion ast))))

(defn emit-tail-expr [ast result-constraint expr]
  (do
    ;; TODO: periodically enable this to check on things
    ;; (print-err 'check (some return-assertions assert-return-type) return-type
    ;;            (ast/file-name ast) (ast/line-number ast))
    (merge-with (partial compose-constraints "" 0)
                (.constraints expr)
                {(.c-var expr) result-constraint})
    (collapse-expressions [expr
                           (c-code (.c-var expr)
                                   ["return(" (.c-var expr) ");" line-sep]
                                   [] {(.c-var expr) 1}
                                   {(.c-var expr) result-constraint})])))

(deftype TailCall [ast params result-constraint]
  (assert (instance? Vector params))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) " " (string-list result-constraint) " "
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))
  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (instance? Tagged (.call-target ast))))
                target (emit (.call-target ast))
                _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (filter produces-code?)
                         (ev/traverse emit))
                line (line-macro ast "// recursive-fixed")]
            (comp* empty-c-code (comp args
                                      [(c-code ""
                                               [line
                                                (map (zip-lists params (map args .c-var))
                                                     (fn [[param arg]]
                                                       [param " = " arg ";" line-sep]))]
                                               [] {} {})])))
          (map (emit ast)
               (fn [expr]
                 (let [expr (either (and (instance? Tagged ast)
                                         (maybe (.refs-map expr {})))
                                    expr)]
                   (emit-tail-expr ast result-constraint expr)))))))

(extend-type String
  Emitter
  (emit [str-val]
    (make-static-string str-val)))

(defn make-static-num [num]
  (for [num-idx (sm/new-sm (fn [s]
                               (assert (instance? GlobalContext s))
                               (-> s
                                   .constants
                                   .numbers
                                   count
                                   (vector s)
                                   maybe)))
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-static-int num-ptr [] [] {}
                                         {num-ptr (c/TypeConstraint {IntegerType #{}} empty-list 'Integer nothing
                                                                  num-ptr)}
                                         num-sym))]
    (c-static-int num-ptr []
                  ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
                   "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
                  {} {num-ptr (c/TypeConstraint {IntegerType #{}} empty-list 'Integer nothing
                                              num-ptr)}
                  num-sym)))

(extend-type Integer
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num))))

(extend-type ast/quoted-ast
  Emitter
  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)
                        constraint (c/update-path sym-constraint
                                                (ast/file-name ast) (ast/line-number ast))]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-static-sym sym-ptr [] [] {}
                                                   {sym-ptr constraint}
                                                   sym-var))]
              (c-static-sym sym-ptr
                            []
                            ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                             ", 0, 0, \"" sym "\"};\n"
                             "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                            {} {sym-ptr constraint} sym-var))))))


(def LiteralValues (comp Integer
                         ast/quoted-ast
                         String))

(extend-type LiteralValues
  Emitter
  (encode-static [n]
    (emit n))

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.decl [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint)))

(defn call-vector [target args]
  (assert (instance? Vector args))

  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [vect-sym (genlocal "newVect")
          result-sym (genlocal "rslt")
          line (line-macro target "// call-vector")]
      (let [arg-constraints (.constraints (collapse-expressions args))
            constraints (comp vect-constraint
                              (c/StaticLengthConstraint (count args)
                                                      empty-list
                                                      nothing
                                                      result-sym)
                              (c/ItemsConstraint (map args (fn [arg]
                                                           (either (get arg-constraints (.c-var arg))
                                                                   c/top-type)))
                                               empty-list
                                               nothing
                                               result-sym))]
        (c-init result-sym
                [line
                 "Vector *" vect-sym " = empty_vect;" line-sep
                 (map args
                      (fn [arg]
                        (let [arg-sym (.c-var arg)]
                          [vect-sym " = mutateVectConj(" vect-sym ", "
                           arg-sym ");" line-sep])))
                 "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
                [] {}
                {result-sym (c/update-path constraints file-name line-number)}
                file-name line-number)))))

(defn call-list [target args]
  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [line (line-macro target "// call-list")
          list-sym (genlocal "newList")
          result-sym (genlocal "rslt")]
      (let [arg-constraints (.constraints (collapse-expressions args))
            constraints (comp list-constraint
                              (c/StaticLengthConstraint (count args)
                                                        empty-list
                                                        nothing
                                                        result-sym)
                              (c/ItemsConstraint (map args (fn [arg]
                                                             (either (get arg-constraints (.c-var arg))
                                                                     c/top-type)))
                                                 empty-list
                                                 nothing
                                                 result-sym))]
        (c-init result-sym
                [line "List *" list-sym " = empty_list;" line-sep
                 (map (reverse args)
                      (fn [arg]
                        (let [arg-sym (.c-var arg)]
                          [list-sym " = listCons(" "(Value *)" arg-sym
                           ", " list-sym ");" line-sep])))
                 "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
                [] {}
                {result-sym (c/update-path constraints file-name line-number)}
                file-name line-number)))))

(defn arg-constraints [arg-asts arg-vars constraints file-name line-number]
  (assert (instance? c/ItemsConstraint constraints))

  (for [constraint-maps (ev/traverse (zip-lists (seq arg-asts)
                                                (seq arg-vars)
                                                (.items-constraints constraints))
                                     (fn [[ast var constraint]]
                                       (let [constraint (c/update-path constraint file-name line-number)
                                             constraints (c/update-path (expr-constraints var) file-name line-number)
                                             new-const (compose-constraints file-name line-number
                                                                            constraint
                                                                            constraints)]
                                         (comp (for [_ (constrain-sym ast constraint)]
                                                 {(.c-var var) new-const})
                                               (sm/state-maybe {(.c-var var) new-const})))))]
    (comp* {} constraint-maps)))

(defn call-proto-impl [target disp-type args ast]
  (let [num-args (count args)]
    (for [impl-info (get-proto-impl target num-args disp-type)
          constraints (arg-constraints (.args ast) args (.param-constraints impl-info)
                                       (ast/file-name ast) (ast/line-number ast))
          _ (comp (sm/update-in-val [.constants .other 'type-known-sites] inc)
                  (sm/assoc-in-val [.constants .other 'type-known-sites] 1))
          result-var (genlocal "rslt")
          line (line-macro target (str "// call proto fn " target))]
      (c-init result-var
              [line "Value *" result-var " = " (.c-fn impl-info) "("
               (interpose (list* "empty_list" (map args .c-var)) ", ")
               ");" line-sep]
              [] {}
              (assoc constraints
                result-var (.result-constraints impl-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn inline-wrap-and-apply [name args]
  ;; TODO: this is subtly broken in replacing syms/bound-vars. It breaks on:
  ;; (for [name (list 1 2 3 4)
  ;;       :let [name (str name)]
  ;;       :when-not (= "." (subs name 0 1))]
  ;;   name)

  ;; (let [[dispatch-ast & arg-asts] args]
  ;;   (for [dispatch-val (emit dispatch-ast)
  ;;         impl-ast (map (get-proto-impl name (count args)
  ;;                                       (expr-type-num dispatch-val))
  ;;                       .ast)
  ;;         expr (-> impl-ast
  ;;                  (replace-bound-vars {})
  ;;                  (inline-expr (cons dispatch-val arg-asts)))]
  ;;     expr))
  (zero sm/state-maybe)
  )


(defn inline-flat-map [name args]
  (let [[dispatch-ast f-ast] args]
    (for [dispatch-val (emit dispatch-ast)
          :let [dispatch-type (expr-type-num dispatch-val)]
          :when-not (= UnknownType dispatch-type)
          impl-ast (map (get-proto-impl name 2 dispatch-type)
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (ev/traverse (.body impl-ast)
                                  (fn [ast]
                                    (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(extend-type rdr/tagged-symbol
  Emitter
  (encode-static [x]
    (emit (ast/quoted-ast (.sym x))))

  (constrain-sym [sym constraint]
    (for [var (sm/get-in-val [.fn-context .syms sym])
          :let [constraint (-> (compose-constraints (ast/file-name sym) (ast/line-number sym)
                                                    constraint (expr-constraints var))
                               (c/update-var (str (.c-var var)))
                               (c/update-sym sym))]
          _ (set-sym sym (.constraints var {(.c-var var) constraint}))]
      constraint))

  (get-param-constraints [sym constraint-map]
    (for [expr (lookup-sym sym)]
      (-> (either (get constraint-map (.c-var expr))
                  c/top-type)
          (c/update-var (.c-var expr))
          (c/update-sym sym))))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] {arg-var 1} {})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                constraint (expr-constraints evalled)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.constraints (assoc (.constraints evalled)
                                            arg-var constraint))
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] []
                                    {(.c-var evalled) 1}
                                    {(.c-var evalled) constraint})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [(c-init (.c-var evalled) (.init evalled) (.decl evalled)
                                     (.refs-map evalled)
                                     (.constraints evalled)
                                     (ast/file-name binding) (ast/line-number binding))]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (emit sym)
          _ (new-module-def defined-sym value)]
      [value]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)
          num-args (count args)]
      (either (or (and (< 0 num-args)
                       (or (= name 'wrap)
                           (= name 'apply))
                       (maybe (inline-wrap-and-apply name args)))
                  (and (= 2 num-args)
                       (or (= name 'flat-map)
                           (= name 'map))
                       (maybe (inline-flat-map name args))))
              (zero sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type Symbol
  Emitter
  (encode-static [sym]
    (emit (ast/quoted-ast sym)))

  (constrain-sym [sym constraint]
    (for [var (sm/get-in-val [.fn-context .syms sym])
          :let [constraint (-> (compose-constraints (ast/file-name sym) (ast/line-number sym)
                                                    constraint (expr-constraints var))
                               (c/update-var (str (.c-var var)))
                               (c/update-sym sym))
                type-num (either (for [type-nums (c/extract-type-map constraint)
                                       :when (= 1 (count type-nums))
                                       type-num (first (keys type-nums))]
                                   type-num)
                                 UnknownType)]
          _ (set-sym sym (-> var
                             (.constraints {(.c-var var) constraint})))]
      constraint))

  (get-param-constraints [sym constraint-map]
    (for [expr (lookup-sym sym)]
      (-> (either (get constraint-map (.c-var expr))
                  c/top-type)
          (c/update-var (.c-var expr))
          (c/update-sym sym))))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] {arg-var 1} {})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                constraint (expr-constraints evalled)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.constraints (assoc (.constraints evalled)
                                            arg-var constraint))
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] []
                                    {(.c-var evalled) 1}
                                    {(.c-var evalled) constraint})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [(c-init (.c-var evalled) (.init evalled) (.decl evalled)
                                     (.refs-map evalled)
                                     (.constraints evalled)
                                     (ast/file-name binding) (ast/line-number binding))]))))

  (emit [sym]
    (lookup-sym sym))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)
          num-args (count args)]
      (either (or (and (< 0 num-args)
                       (or (= name 'wrap)
                           (= name 'apply))
                       (maybe (inline-wrap-and-apply name args)))
                  (and (= 2 num-args)
                       (or (= name 'flat-map)
                           (= name 'map))
                       (maybe (inline-flat-map name args))))
              (zero sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          line-info (line-macro ast "// inline")
          :let [init [line-info (.txt ast) "\n#\n"]]
          type-num (get-type-number (.result-type ast))
          expr (either (and (= UnknownType type-num)
                            (maybe (sm/state-maybe (c-code "" init [] {} {}))))
                       (for [c-var (genlocal "rslt")
                             constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))]
                         (c-code c-var init [] {} {c-var constraint})))]
      expr))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] [] {}
                                                {(str c-var) constraint}))
          line-info (line-macro ast "// inline")]
      [(c-code c-var [] [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"]
               {} {c-var constraint})]))

  (emit-definition [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] {} {})]))

  (tail-call [ast params result-constraint]
    ;; TODO: statically verify the return type, if possible
    ast)

  (replace-syms [ast _]
    (sm/state-maybe ast)))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (ev/traverse (.value-exprs ast) (fn [ast]
                                             (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] {} {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              [(-> c-info
                   (.c-var "")
                   (.decl ["Value *" c-var ";\n"]))])))))

(extend-type StaticFnPtr
  Emitter
  (call-site-meta-data [v f l]
    (sm/state-maybe (c-code "empty_list" [] [] {} {})))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'static-fixed-sites] inc)
          (sm/assoc-in-val [.constants .other 'static-fixed-sites] 1))))

(extend-type ProtoDispFnPtr
  Emitter
  (call-site-meta-data [_ file-name line-number]
    (let [str-val (str "at " file-name ": " line-number)]
      (map (make-static-string str-val)
           (fn [expr]
             (.c-var expr (str "(List *)" (.c-var expr)))))))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'proto-dispatch-sites] inc)
          (sm/assoc-in-val [.constants .other 'proto-dispatch-sites] 1))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arity-info arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [constraints (arg-constraints (.args ast) arg-vars (.param-constraints arity-info)
                                       file-name line-number)
          result-sym (genlocal "rslt")
          _ (update-call-site-count (.c-var arity-info))
          line (line-macro ast "// static-fixed")
          call-site-location (call-site-meta-data (.c-var arity-info) file-name line-number)]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (cons (.c-var call-site-location)
                                (seq (map arg-vars .c-var))) ", ") ");" line-sep]
              (.decl call-site-location)
              {} (assoc constraints
                   result-sym (.result-constraint arity-info))
              file-name line-number))))

(defn call-static-variadic [target arity-info arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arg-consts (arg-constraints (.args ast) arg-vars (.param-constraints arity-info)
                                      file-name line-number)
          _ (comp (sm/update-in-val [.constants .other 'static-variadic-sites] inc)
                  (sm/assoc-in-val [.constants .other 'static-variadic-sites] 1))
          args-list (call-list (rdr/tag 'list file-name line-number)
                               (map arg-vars (fn [arg]
                                               (.init arg []))))
          result-sym (genlocal "rslt")
          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               line
               "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
               (.c-var args-list) ");" line-sep]
              [] {}
              (assoc-all arg-consts
                         (.c-var args-list) (compose-constraints file-name line-number
                                                                 (.param-constraints arity-info)
                                                                 (expr-constraints args-list))
                         result-sym (.result-constraint arity-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn call-dyn-fn-value [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (expr-type-num target))
        _ (comp (sm/update-in-val [.constants .other 'dyn-fn-sites] inc)
                (sm/assoc-in-val [.constants .other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [arg-syms (comp [(str arity-sym "->closures")] args)
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              [] {} {}
              (ast/file-name ast) (ast/line-number ast)))))

(def symbols-sym (symbol "#symbols"))
(def types-sym (symbol "#types"))
(def protocols-sym (symbol "#protocols"))
(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type 'core 0))
(def Function-sym (rdr/tag 'Function 'core 0))
(def Container-sym (rdr/tag 'Container 'core 0))
(def Stringable-sym (rdr/tag 'Stringable 'core 0))
(def type-name-sym (rdr/tag 'type-name))
(def type-mapping-sym (rdr/tag 'type-mapping))
(def =*-sym (rdr/tag '=*))
(def apply-sym (rdr/tag 'apply))
(def get-type-sym (rdr/tag 'reified-get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def new-type-value-sym (rdr/tag 'new-type-value))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative 'core 0))
(def get-symb (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode 'core 0))
(def Hashable-sym (rdr/tag 'Hashable 'core 0))
(def sha1-sym (rdr/tag 'sha1))
(def sha1-update-sym (rdr/tag 'sha1-update))
(def sha1-init-sym (rdr/tag 'sha1-init))
(def sha1-finalize-sym (rdr/tag 'sha1-finalize))
(def sha1-update-type-sym (rdr/tag 'sha1-update-type))
(def assoc-sym (rdr/tag 'assoc))
(def make-value-sym (rdr/tag 'make-value))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [num-args (count args)
        num-invoke-args (inc num-args)
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (lookup-core-fn-arity invoke-sym num-invoke-args)
          _ (comp (sm/update-in-val [.constants .other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.constants .other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")
          sym-location (emit (either (= "\"\"" file-name)
                                     (str "\"at " file-name ": " line-number "\"")))]
      (let [arg-syms (comp [(str arity-sym "->closures")] args)]
        (comp sym-location
              (c-init result-sym
                      [line "Value *" result-sym ";" line-sep
                       "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                       result-sym " = " invoke-arity-sym "("
                       (interpose (list* (str "(List *)" (.c-var sym-location))
                                         (.c-var target) args) ", ") ");"
                       line-sep "} else {" line-sep

                       "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                       "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                       "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                       line-sep
                       result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                       "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                       "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                       "List *" variadic-sym " = empty_list;" line-sep
                       (map (reverse (rest arg-syms))
                            (fn [arg-sym]
                              (str variadic-sym " = (List *)listCons("
                                   arg-sym ", " variadic-sym ");" line-sep)))
                       result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                       variadic-sym ");" line-sep
                       "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                       "((Function *)" (.c-var target) ")->name"
                       ");" line-sep "  abort();" line-sep "}" line-sep
                       "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                      [] {} {}
                      file-name line-number))))))

(defn call-invoke [target args ast]
  (let [num-args (inc (count args))
        file-name (ast/file-name ast)
        line-number (ast/line-number ast)
        target-type (expr-type-num target)]
    (for [_ (sm/when-not (= UnknownType target-type))
          invoke-info (get-proto-impl Function-sym invoke-sym num-args target-type)
          _ (comp (sm/update-in-val [.constants .other 'invoke-sites] inc)
                  (sm/assoc-in-val [.constants .other 'invoke-sites] 1))
          constraints (arg-constraints (cons target (seq (.args ast)))
                                       (comp [target] args)
                                       (.param-constraints invoke-info)
                                       (ast/file-name ast) (ast/line-number ast))
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (do
        (c-init result-sym
                [line "Value *" result-sym " = " (.c-fn invoke-info) "("
                 (interpose (list* "empty_list" (.c-var target) (map args .c-var)) ", ")
                 ");" line-sep]
                [] {} (assoc constraints
                        result-sym (.result-constraints invoke-info))
                (ast/file-name ast) (ast/line-number ast))))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (filter produces-code?)
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse
                vec))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(defn define-sum-type [fn-val defined-sym]
  (for [[type-sym type-syms] (sm/when (and (= (.call-target fn-val) 'comp*)
                                           (maybe (.args fn-val))))
        ns-path (sym-ns-path type-sym)
        type-info (get-type-info ns-path type-sym)
        :when-not (empty? type-info)
        other-types-info (ev/traverse (.args type-syms)
                                      (fn [sym]
                                        (for [ns-path (sym-ns-path sym)
                                              type-info (get-type-info ns-path sym)
                                              :when-not (empty? type-info)]
                                          type-info)))
        :let [all-types-info (comp* type-info other-types-info)
              reified-type-num (extract rdr/type-counter)
              x* (rdr/tag "#x")
              y* (rdr/tag "#y")]
        _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                           reified-type-num)
        _ (sm/assoc-in-val [.type-maps reified-type-num] (TypeInfo defined-sym all-types-info))
        exprs (emit-defined-value
               (ast/reified
                reified-type-num
                {Type-sym
                 [[instance?-sym
                   [(ast/fn-arity-ast
                     (str defined-sym "_instance_QMARK_") (FnValPtr "")
                     (ast/params [x* y*]) ""
                     [(ast/and-ast
                       [(ast/call-ast (rdr/tag 'some)
                                      [(ast/call-ast list-sym (vec (keys all-types-info)))
                                       (ast/call-ast (rdr/tag 'partial)
                                                     [=*-sym
                                                      (ast/call-ast get-type-sym [y*])])])
                        (ast/call-ast maybe-sym [y*])])])]]

                  [type-mapping-sym
                   [(ast/fn-arity-ast
                     (str defined-sym "_type_mapping") (FnValPtr "")
                     (ast/params [x*]) ""
                     [(map-vals all-types-info (fn [field-set]
                                                 (map field-set ast/quoted-ast)))])]]]

                 Stringable-sym
                 [[string-list-sym
                   [(ast/fn-arity (ast/params [x*]) ""
                                  [(ast/call-ast list-sym ["<SumType " (str defined-sym) ">"])])]]]})
               defined-sym)]
    exprs))

(defn define-enum-type [fn-val defined-sym]
  (for [_ (sm/when (= (.call-target fn-val) 'enum))
        type-maps (comp (ev/traverse (.args fn-val)
                                     (fn [sym]
                                       (comp (flat-map (sm/get-in-val [.modules (ast/file-name sym) .types sym])
                                                       (fn [_]
                                                         (compilation-error "Invalid enum value " (str "'" sym "'")
                                                                            " at:" (ast/file-name defined-sym)
                                                                            (ast/line-number defined-sym))))
                                             (for [expr (comp (find-global-sym sym)
                                                              (compilation-error "Invalid enum value " (str "'" sym "'")
                                                                                 " at:" (ast/file-name defined-sym)
                                                                                 (ast/line-number defined-sym)))
                                                   :when (instance? c-static-reified expr)
                                                   type-map (sm/when (-> expr
                                                                         expr-constraints
                                                                         c/extract-type-map))]
                                               type-map))))
                        (compilation-error "Invalid enum values at:"
                                           (ast/file-name defined-sym) (ast/line-number defined-sym)))
        :let [type-map (comp* {} type-maps)
              reified-type-num (extract rdr/type-counter)
              x* (rdr/tag "#x")
              y* (rdr/tag "#y")]
        _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                           reified-type-num)
        _ (sm/assoc-in-val [.type-maps reified-type-num]
                           (TypeInfo defined-sym type-map))
        exprs (emit-defined-value
               (ast/reified
                reified-type-num
                {Type-sym
                 [[instance?-sym
                   [(ast/fn-arity-ast
                     (str defined-sym "_instance_QMARK_") (FnValPtr "")
                     (ast/params [x* y*]) ""
                     [(ast/and-ast
                       [(ast/call-ast (rdr/tag 'some)
                                      [(ast/call-ast list-sym (vec (keys type-map)))
                                       (ast/call-ast (rdr/tag 'partial)
                                                     [=*-sym (ast/call-ast get-type-sym [y*])])])
                        (ast/call-ast maybe-sym [y*])])])]]

                  [type-mapping-sym
                   [(ast/fn-arity-ast
                     (str defined-sym "_type_mapping") (FnValPtr "")
                     (ast/params [x*]) ""
                     [(map-vals type-map (fn [field-set]
                                           (map field-set ast/quoted-ast)))])]]]

                 Stringable-sym
                 [[string-list-sym
                   [(ast/fn-arity (ast/params ['z]) ""
                                  [(ast/call-ast list-sym
                                                 ["<SumType " (str defined-sym) ">"])])]]]})
               defined-sym)]
    exprs))

(defprotocol CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (call-dyn-fn-value target (map args .c-var) ast)
          (call-dyn-unknown-type target (map args .c-var) ast))))

(extend-type c-static-reified
  CallSite
  (emit-call-site [target args ast]
    (comp (call-invoke target args ast)
          (compilation-error "No implementation of 'Function/invoke' with"
                             (count args) "arguments"
                             (either (map (instance? Tagged (.call-target ast))
                                          (fn [sym]
                                            (str "for '" sym "'")))
                                     "")
                             "at:" (ast/file-name ast) (ast/line-number ast)))))

(defn static-call-site [target args ast]
  (comp (for [fn-info (sm/get-in-val [.fns (.c-var target)])
              site (either (or (map (get fn-info (count args))
                                    (fn [arity-info]
                                      (call-static-fixed target arity-info args ast)))
                               (map (get fn-info 'variadic)
                                    (fn [arity-info]
                                      (call-static-variadic target arity-info args ast))))
                           (zero sm/state-maybe))]
          site)
        (compilation-error "No arity with" (count args) "arguments found"
                           (either (map (instance? Tagged (.call-target ast))
                                        (fn [sym]
                                          (str "for '" sym "'")))
                                   "")
                           "at:" (ast/file-name ast) (ast/line-number ast))))

(extend-type c-list-fn
  CallSite
  (emit-call-site [target args ast]
    (call-list (.call-target ast) args)))

(extend-type c-vector-fn
  CallSite
  (emit-call-site [target args ast]
    (call-vector (.call-target ast) args)))

(extend-type c-static-fn
  CallSite
  (emit-call-site [target args ast]
    (static-call-site target args ast)))

(extend-type c-protocol-fn
  CallSite
  (emit-call-site [target args ast]
    (either (for [dispatch-val (first args)
                  :let [disp-type (expr-type-num dispatch-val)]
                  :when-not (= UnknownType disp-type)]
              (comp (call-proto-impl (.call-target ast) disp-type args ast)
                    (static-call-site target args ast)))
            (static-call-site target args ast))))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    (either (and (instance? Symbol target-ast)
                                                 (maybe (rdr/tag target-ast)))
                                            target-ast))))]
      (comp (for [new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.refs-map call-site)
                      (.constraints call-site)
                      (ast/file-name ast) (ast/line-number ast)))
            (flat-map (-> (.args ast)
                          (filter produces-code?)
                          (ev/traverse emit))
                      (fn [args]
                        (comp (for [target (emit (.call-target ast))
                                    call-site (emit-call-site target args ast)]
                                (comp* target (comp args [call-site])))
                              (compilation-error "Could not compile call site at:"
                                                 file-name line-number)))))))

  (emit-defined-value [fn-val defined-sym]
    (comp (define-sum-type fn-val defined-sym)
          (define-enum-type fn-val defined-sym)
          (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
                fn-context (reset-fn-context init-fn-context)
                value (emit fn-val)
                var (comp (map (lookup-declaration defined-sym) .c-var)
                          (global-var defined-sym "var"))
                init-fn-context (reset-fn-context fn-context)
                _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
                _ (new-module-def defined-sym (c-code var [] [] {}
                                                      {var (expr-constraints value)}))]
            [(c-init var [(.init value)
                          var " = " (.c-var value) ";" line-sep
                          var "->refs = -1;" line-sep "\n#\n"]
                     [(.decl value) "Value *" var ";\n"]
                     (.refs-map value)
                     (.constraints value)
                     (ast/file-name fn-val) (ast/line-number fn-val))])))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (ev/traverse (.args ast) (fn [ast]
                                          (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= (.call-target ast) 'new-sm))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))

  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? Vector l))
    [ast]))

(extend-type C-expr
  C-Code
  (expr-constraints [expr]
    (either (get (.constraints expr) (.c-var expr))
            c/top-type))

  Emitter
  (emit [x]
    (sm/state-maybe x))

  (bind-list [list-var params]
    (let [file-name (ast/file-name params)
          line-num (ast/line-number params)
          list-constraint (c/update-path list-constraint file-name line-num)
          fixed-count (count (.fixed params))
          tail-sym (either (.variadic params)
                           (rdr/tag "#tail"))
          items-constraints (c/extract-items-constraints (expr-constraints list-var))
          list-var (.refs-map list-var (dissoc (.refs-map list-var) (.c-var list-var)))]
      (for [tail-binding (bind tail-sym)
            _ (comp (sm/when (empty? (.init list-var)))
                    (set-sym (.c-var list-var) list-var))
            _ (constrain-sym tail-sym list-constraint)
            :let [tail-var (-> tail-binding .vars first extract)]
            r (comp (sm/when (and (= 0 fixed-count)
                                  (maybe (ParamBinding [(.c-var list-var)]
                                                       [list-var
                                                        (c-init tail-var ["Value *" tail-var " = seq(empty_list, "
                                                                          (.c-var list-var) ");" line-sep]
                                                                [] {(.c-var list-var) 1}
                                                                {tail-var list-constraint}
                                                                file-name line-num)]))))
                    (for [dest-args (genlocal "destArgs")
                          fixed-bindings (map (ev/traverse (.fixed params) bind) vec)
                          :let [fixed-vars (flat-map fixed-bindings .vars)
                                fixed-exprs (map fixed-vars (fn [var]
                                                              (c-init var [] [] {} {}
                                                                      file-name line-num)))
                                tail-expr (c-init tail-var [] [] {} {tail-var list-constraint}
                                                  file-name line-num)]
                          _ (ev/traverse fixed-exprs (fn [expr]
                                                       (set-sym (.c-var expr) expr)))
                          _ (set-sym tail-var tail-expr)]
                      (ParamBinding [(.c-var list-var)]
                                    (comp [list-var
                                           (c-code ""
                                                   (destruct-seq (.c-var list-var)
                                                                 (conj fixed-vars tail-var)
                                                                 dest-args file-name line-num)
                                                   [] {(.c-var list-var) 1} {})]
                                          (conj fixed-exprs tail-expr)
                                          (flat-map fixed-bindings .destruct)
                                          (.destruct tail-binding)))))]
        r))))

(extend-type ast/params-ast
  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  Emitter
  (get-param-constraints [params constraint-map]
    (map (ev/traverse (.fixed params) (fn [param]
                                        (get-param-constraints param constraint-map)))
         (fn [items-constraints]
           (-> (c/ItemsConstraint [] empty-list nothing "")
               (c/update-path (ast/file-name params) (ast/line-number params))
               (.items-constraints items-constraints)))))

  (bind [params]
    (for [param-var (genlocal "arg")
          destruct (bind-list (c-code param-var [] [] {} {})
                              params)]
      destruct))

  (bind [params evalled]
    (bind-list evalled params))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (for [val-var (emit (.val ast))
          bound-var (bind (.binding ast) val-var)]
      bound-var)))

(defn merge-constraints [c1 c2]
  (comp c1 c2))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals get-syms
          bindings (ev/traverse (.bindings ast) emit)
          body-exprs (ev/traverse (.body ast) emit)
          :let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
          result-var (either (map (= "" (.c-var code)) sm/state-maybe)
                             (genlocal "let_rslt"))
          moar-constraints (ev/traverse (zip-lists (.bindings ast) bindings)
                                        (fn [[binding-ast param-binding]]
                                          (for [binding-constraint (get-param-constraints (.binding binding-ast)
                                                                                          (.constraints code))]
                                            (either (and (instance? c/ItemsConstraint binding-constraint)
                                                         (let [[var] (.vars param-binding)]
                                                           (maybe {var binding-constraint})))
                                                    {}))))
          _ (set-syms locals)]
      (let [constraints (reduce moar-constraints (.constraints code)
                                (fn [m1 m2]
                                  (merge-with (partial compose-constraints (ast/file-name ast) (ast/line-number ast))
                                              m1 m2)))]
        (c-init result-var
                [(.init code)
                 (either (= "" result-var)
                         [line-sep "Value *" result-var " = " (.c-var code) ";" line-sep])]
                (.decl code) (.refs-map code)
                (assoc constraints result-var (expr-constraints code))
                (ast/file-name ast) (ast/line-number ast)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] {}
                                                {var (expr-constraints value)}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               [(.decl value) "Value *" var ";\n"]
               (.refs-map value)
               {var (expr-constraints value)}
               (ast/file-name ast) (ast/line-number ast))]))

  (tail-call [ast params result-constraint]
    (.body ast (-> ast
                   .body
                   (tail-call params result-constraint))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (sm/state-maybe new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (rdr/tag (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body))))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns file-name line-number]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = "
               (count impl-fns) ";" line-sep
               "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (map impl-fns .decl)
              (apply merge-with (list* + (map impl-fns .refs-map)))
              {reified-sym (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>") nothing
                                           reified-sym)}
              file-name line-number))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-static-reified reified-ptr
                      []
                      [(map impl-fns .decl)
                       "ReifiedVal " reified-sym " = {"
                       type-num ", -1, (Value *)0, 0, {}};" line-sep
                       "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
                      {} {reified-ptr (c/TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>")
                                                      nothing (str reified-ptr))}
                      reified-sym)))

(defprotocol ArityType
  (closure-arity? [_]
    (assert-result x (instance? Maybe x))
    nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (assert-result x (instance? sm/new-sm x))))

(defn new-static-arity
  ([fn-ptr num-params arity-var result-constraints]
   (assert (instance? FnValPtr fn-ptr))
   (assert (instance? c/ResultConstraint result-constraints))
   (assert (instance? CFnPtr arity-var))

   (new-static-arity fn-ptr num-params arity-var result-constraints c/empty-items-constraint))

  ([fn-ptr num-params arity-var result-constraints param-constraints]
   (assert (instance? FnValPtr fn-ptr))
   (assert (instance? c/ResultConstraint result-constraints))
   (assert (instance? CFnPtr arity-var))

   (sm/assoc-in-val [.fns fn-ptr num-params]
                    (StaticArityInfo arity-var
                                     param-constraints
                                     (.assertion result-constraints)))))

(deftype StaticArity [arity-fn-var c-fn param-count var-info param-constraints result-constraints]
  (assert (instance? FnValPtr arity-fn-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ItemsConstraint param-constraints))
  (assert (instance? c/ResultConstraint result-constraints))

  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info) " " (str result-constraints) ">"))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (for [_ (new-proto-impl proto-sym fn-name param-count dispatch-type-num (.c-var var-info) arity-ast
                            param-constraints result-constraints c-fn)]
      var-info)))

(deftype ClosureArity [arity-fn-var params var-info result-constraint]
  (assert (instance? CFnPtr arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))
  (assert (instance? c/ResultConstraint result-constraint))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))

  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (ev/traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num
                              (ArityValPtr (str "&" fn-arity-sym) fn-arity-sym) arity-ast
                              c/empty-items-constraint result-constraint
                              (StaticFnPtr (str impl-fn-sym)))
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                                  ")->impls["
                                  reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};" line-sep]
                                 {} {})]
          (comp reified-fn var-info))))))

(defn checking-fn [fn-sym params param-vars arity-fn-var constraints]
  (let [file-name (ast/file-name params)
        line-number (ast/line-number params)
        constraints-list (.items-constraints constraints)]
    (for [dest-args (genlocal "destArgs")
          checking-fn-var (global-var fn-sym "paramChecker")
          line (line-macro fn-sym "// paramChecker")]
      (either (or (and (.variadic params)
                       (maybe (c-code checking-fn-var
                                      ["Value *" checking-fn-var
                                       "(List *closures, Value *args) {\n"
                                       line
                                       (destruct-seq 'args (.vars param-vars)
                                                     dest-args file-name line-number)
                                       "return(" arity-fn-var
                                       "(closures, args));\n};\n"]
                                      [] {} {})))
                  (and (every constraints-list (partial = c/top-type))
                       (maybe (c-code arity-fn-var [] [] {} {}))))
              (c-code checking-fn-var
                      ["Value *" checking-fn-var "("
                       (-> (.vars param-vars)
                           (map (fn [param] (str "Value *" param)))
                           (seq)
                           (conj "List *closures")
                           (interpose ", "))
                       ") {\n"
                       (for [[constraint var] (zip-lists constraints-list
                                                         (.vars param-vars))]
                         (-> constraint
                             (c/update-var var)
                             (runtime-check c/top-type file-name line-number)))
                       "return(" arity-fn-var "("
                       (-> (.vars param-vars)
                           (seq)
                           (conj "closures")
                           (interpose ", "))
                       "));\n};\n"]
                      [] {} {})))))

(defn destruct-closures [closure-info]
  (for [destArgs (genlocal "destArgs")]
    (let [closures (-> closure-info
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)]
      (cons (c-code ""
                    [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                     "incRef((Value *)closures, 1);" line-sep
                     "Value **" destArgs "[" closure-count "] = {"
                     (interpose (map closures (fn [arg] ["&" arg])) ", ")
                     "};" line-sep
                     "destructValue(\"\", \"\", (Value *)closures"
                     ", " closure-count ", " destArgs ");" line-sep]
                    [] {} {})
            (map (seq closure-info)
                 (fn [[arg _ constraint]]
                   (c-init arg [] [] {} {arg constraint} "" 0)))))))

(defn emit-closure-arity [fn-sym fn-context c-fn params param-vars body-exprs]
  (assert (instance? CFnPtr c-fn))

  (for [closures (sm/new-sm (fn [s]
                              (assert (instance? GlobalContext s))
                              (let [closures (-> s .fn-context .closed-over .closures)]
                                (and (first closures)
                                     (maybe [closures s])))))
        closures-destruct (destruct-closures closures)
        :let [body (collapse-expressions (comp (.destruct param-vars)
                                               closures-destruct
                                               body-exprs))
              closure-constraints (.constraints body)]
        param-constraints (get-param-constraints params closure-constraints)
        _ (reset-fn-context fn-context)
        arity-var (genlocal fn-sym "dynArity")
        closure-vars (ev/traverse closures (fn [[closed-over sym]]
                                             (for [closure (lookup-sym sym)]
                                               (let [new-constraint (either (get closure-constraints closed-over)
                                                                            c/top-type)]
                                                 (c-code ""
                                                         [arity-var "->closures = listCons((Value *)"
                                                          (.c-var closure) ", (List *)" arity-var
                                                          "->closures);" line-sep]
                                                         [] {(.c-var closure) 1}
                                                         {arity-var (c/update-var list-constraint (str (.c-var closure)))
                                                          (.c-var closure) new-constraint})))))]
    (let [file-name (ast/file-name fn-sym)
          line-number (ast/line-number fn-sym)
          param-constraints (c/update-path param-constraints file-name line-number)
          result-constraint (expr-constraints body)
          result-constraint (either (instance? c/ResultConstraint result-constraint)
                                    (c/ResultConstraint result-constraint))
          arity-decl [(.decl body)
                      "Value *" c-fn "("
                      (-> (.vars param-vars)
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\n"
                      "\nwhile (1) {\n"
                      (for [[constraint var] (zip-lists (.items-constraints param-constraints)
                                                        (.vars param-vars))]
                        (-> constraint
                            (c/update-var var)
                            (runtime-check c/top-type file-name line-number)))
                      (.init body)
                      line-sep "};};\n"]
          arity-init ["FnArity *" arity-var
                      " = malloc_fnArity();" line-sep
                      arity-var "->count = " (count (.vars param-vars))
                      ";" line-sep
                      arity-var "->variadic = "
                      (either (and (.variadic params)
                                   (maybe "1"))
                              "0")
                      ";" line-sep
                      arity-var "->fn = " c-fn ";" line-sep
                      arity-var "->closures = empty_list;" line-sep]]
      (ClosureArity c-fn params
                    (.constraints (comp* (c-code arity-var arity-init arity-decl {} {})
                                         (comp closure-vars
                                               [(c-init arity-var [] [] {} {}
                                                        file-name line-number)]))
                                  {})
                    result-constraint))))

(defn emit-static-arity [fn-sym fn-context fn-var c-fn params param-vars result-constraint body-exprs]
  (assert (instance? FnValPtr fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? ParamBinding param-vars))
  (assert (instance? CFnPtr c-fn))

  (let [body (collapse-expressions (comp (.destruct param-vars) body-exprs))
        result-constraint (expr-constraints body)
        result-constraint (either (instance? c/ResultConstraint result-constraint)
                                  (c/ResultConstraint result-constraint))]
    (for [arity-var (global-var fn-sym "staticArity")
          param-constraints (get-param-constraints params (.constraints body))
          checker-fn (checking-fn fn-sym params param-vars c-fn param-constraints)
          _ (reset-fn-context fn-context)]
      (do
        ;; TODO: use this to eliminate unknown return type values
        ;; (and (= UnknownType result-type)
        ;;      (maybe (print-err 'unknown-return-type fn-sym
        ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
        (StaticArity fn-var c-fn (either (and (.variadic params)
                                              (maybe'variadic))
                                         (count params))
                     (c-code (ArityValPtr (str "&" arity-var) arity-var) []
                             [(.decl body)
                              "Value *" c-fn "("
                              (-> (.vars param-vars)
                                  (map (fn [param] (str "Value *" param)))
                                  (seq)
                                  (conj "List *closures")
                                  (interpose ", "))
                              ") {\nwhile (1) {\n"
                              (.init body)
                              line-sep "};};\n"
                              (.init checker-fn)
                              "FnArity " arity-var " = {FnArityType, -1, "
                              (count (.vars param-vars))
                              ", (List *)0, " (either (and (.variadic params)
                                                           (maybe "1"))
                                                      "0")
                              ", " (.c-var checker-fn) "};" line-sep]
                             {} {})
                     param-constraints
                     result-constraint)))))

(defn bind-params [params fn-var]
  (assert (instance? ast/params-ast params))

  (comp (for [_ (sm/when (.variadic params))
              param-var (genlocal "arg")
              destruct (bind-list (c-code param-var [] [] {} {}) params)]
          destruct)
        (for [vars (ev/traverse (.fixed params) bind)
              :when-not (empty? vars)
              _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] '_)]
          (let [[var & vars] vars
                param-vars (comp* var vars)]
            (ParamBinding (.vars param-vars)
                          (comp (map (.vars param-vars)
                                     (fn [var]
                                       (c-param var [] [] {} {}
                                                (ast/file-name params) (ast/line-number params))))
                                (.destruct param-vars)))))
        (for [_ (sm/assoc-in-val [.fn-context .recurse fn-var 0] '_)]
          (ParamBinding [] []))))

(defn emit-fn-arity
  ([fn-sym fn-var params body]
   (assert (instance? FnValPtr fn-var))

   (flat-map (global-var fn-sym "arityImpl")
             (fn [c-fn]
               (emit-fn-arity fn-sym fn-var params body (StaticFnPtr c-fn)))))

  ([fn-sym fn-var params body c-fn]
   (assert (instance? FnValPtr fn-var))
   (assert (instance? CFnPtr c-fn))
   (assert (min-count body 1))

   (either (and (empty? (filter body produces-code?))
                (maybe (zero sm/state-maybe)))
           (let [file-name (ast/file-name body)
                 line-number (ast/line-number body)
                 param-asserts (filter body assertion?)
                 fn-sym (rdr/tag fn-sym file-name line-number)]
             (for [fn-context (reset-fn-context)
                   result-constraint (map (-> body
                                              (filter return-assertion?)
                                              (map .assertion)
                                              (ev/traverse to-constraint))
                                          (fn [constraints]
                                            (let [result-type (c/update-sym (comp* c/top-type constraints)
                                                                          "<result value>")]
                                              (and (= c/bottom-type result-type)
                                                   (do
                                                     (apply print-err
                                                            (list* "Conflicting result assertions"
                                                                   (either (= "" file-name)
                                                                           (str " at " file-name ": "
                                                                                line-number))
                                                                   "\n"
                                                                   (c/format-path result-type 0)))
                                                     (maybe (abort))))
                                              result-type)))
                   syms get-syms
                   _ (either (map (get syms fn-sym) sm/state-maybe)
                             (set-sym fn-sym (c-code fn-var [] [] {}
                                                     {fn-var fn-constraint})))
                   param-vars (bind-params params fn-var)
                   :let [param-vars (either (and (some body (partial instance? ast/inline-ast))
                                                 (maybe (.destruct param-vars [])))
                                            param-vars)]
                   body-exprs (-> body
                                  (filter produces-code?)
                                  ((fn [body] (comp param-asserts body)))
                                  (tail-call (.vars param-vars) result-constraint)
                                  (ev/traverse emit))
                   arity-info (comp (emit-closure-arity fn-sym fn-context c-fn params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context fn-var c-fn params
                                                       param-vars result-constraint body-exprs))]
               arity-info)))))

(deftype ProtoImplDeclaration [proto-sym fn-name arity-ast arity-var c-fn c-decl]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-name))
  (assert (instance? ArityValPtr arity-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/fn-arity-ast arity-ast))
  (assert (instance? Vector c-decl))

  Stringable
  (string-list [_]
    (list "<ProtoImplDeclaration " (str proto-sym) " " (str fn-name) ">")))

(defn declare-impl [type-str type-num [proto-sym fn-name arity-ast]]
  (assert (instance? Integer type-num))

  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (global-var (str type-str fn-name) "arityImpl")
          c-fn (global-var (str type-str fn-name) "arityFn")
          :let [impl-fn-var (FnValPtr impl-fn-var)
                arity-impl-var (ArityValPtr arity-impl-var "")
                c-fn (ProtoDispFnPtr c-fn)]
          dispatcher-info (get-proto-impl proto-sym fn-name num-args 0)
          :let [sym-map (reduce (zip-lists (-> dispatcher-info .ast .params .fixed)
                                           (-> arity-ast .params .fixed))
                                {} (fn [m [old-sym new-sym]]
                                     (assoc m old-sym new-sym)))
                result-assertions (-> dispatcher-info
                                      .ast
                                      .body
                                      (filter return-assertion?))]
          param-assertions (-> dispatcher-info
                               .ast
                               .body
                               (filter assertion?)
                               (ev/traverse (fn [ast]
                                              (replace-syms ast sym-map))))
          :let [arity-ast (.body arity-ast (comp [] param-assertions result-assertions (.body arity-ast)))]
          _ (new-static-arity impl-fn-var num-args c-fn
                              (.result-constraints dispatcher-info))
          _ (new-proto-impl proto-sym fn-name num-args type-num arity-impl-var arity-ast
                            c/empty-items-constraint
                            (.result-constraints dispatcher-info) c-fn)]
      (ProtoImplDeclaration proto-sym fn-name
                            arity-ast
                            arity-impl-var c-fn
                            ["Value *" c-fn "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"
                             "FnArity *" arity-impl-var ";\n"]))))

(defn update-param-constraint [constraint sym]
  ;; (assert (instance? c/Constraints constraint))
  (-> constraint
      (c/update-path (ast/file-name sym) (ast/line-number sym))
      (c/update-sym sym)))

(defn emit-impl [type-str type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))

  (let [[proto-sym fn-sym arity-ast arity-var c-fn] (type-args impl-decl)
        params (.params arity-ast)
        [disp-param] (.fixed params)
        num-args (count params)
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [
          ;; _ (debug 'impl type-str fn-sym num-args file-name line-number)
          disp-constraint (comp (for [_ (sm/get-in-val [.constants .type-names type-num])
                                      ;; TODO: this needs to be factored out
                                      ;; also, this should not be a type-constraint, it should only set
                                      ;; the type of the first parameter
                                      constraint (type-constraint type-num file-name line-number)]
                                  (update-param-constraint constraint disp-param))
                                (sm/state-maybe c/top-type))
          ext-fn (comp (emit-fn-arity (rdr/tag (str type-str fn-sym))
                                      (.fn-var arity-ast)
                                      params
                                      (comp [disp-constraint]
                                            (.body arity-ast))
                                      c-fn)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-sym "' in")
                                          (str file-name ",") line-number))
          reified (reify-arity ext-fn type-num arity-ast fn-sym proto-sym)
          ;; _ (debug "---------")
          ]
      (-> reified
          (.c-var arity-var)
          (.init (either (or (empty? (.init reified))
                             (and (instance? StaticArity ext-fn)
                                  (maybe (.init reified))))
                         [(.init reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))
          (.decl (either (or (empty? (.decl reified))
                             (and (instance? ClosureArity ext-fn)
                                  (maybe (.decl reified))))
                         [(.decl reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))))))

(defn extend-type* [ast type-num]
  (assert (instance? Integer type-num))
  (let [impl-arities (for [[proto-sym impl-fns] (seq (.impls ast))
                           [fn-name arities] (seq impl-fns)
                           impl-arity arities]
                       [proto-sym fn-name (.fn-var impl-arity (FnValPtr (str (.fn-var impl-arity))))])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (sm/state-maybe (str "_" type-num "_")))
                _ (ev/traverse (keys (.impls ast))
                               (fn [protocol-name]
                                 (comp (get-protocol protocol-name)
                                       (compilation-error "Invalid protocol:" protocol-name "in"
                                                          (str (ast/file-name ast) ",")
                                                          (ast/line-number protocol-name)))))
                ;; TODO: make sure the proto-name/fn-name exists
                ;; especially that the fn-name doesn't exist in a different proto-name
                impl-arities (ev/traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (ev/traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns
                                                        (ast/file-name ast) (ast/line-number ast))
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-static-reified (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                               (.c-var value) ";" line-sep]
                                               (.decl value) (.refs-map value)
                                               {(.c-var value) (expr-constraints value)}
                                               (.c-struct value))))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-static-reified (.c-var value) [] [] {}
                                                          {(.c-var value) (expr-constraints value)}
                                                          (.c-struct value)))]
      [value]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (for [syms get-syms
            expr (emit clause)
            _ (set-syms syms)]
        (let [checks (map (seq (.refs-map expr))
                          (fn [[var refs]]
                            (either (for [constraint (get (.constraints expr) var)
                                          _ (< 0 refs)]
                                      (runtime-check (c/update-var constraint var) c/top-type
                                                     (ast/file-name clause) (ast/line-number clause)))
                                    "")))]
          (either (and (or (= MaybeType (expr-type-num expr))
                           (= "" (.c-var expr)))
                       (maybe (.init expr [checks (.init expr)])))
                  (.init expr [checks
                               (.init expr)
                               "if (" (.c-var expr) "->type != MaybeType) {" line-sep
                               "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
                               file-name "\","
                               (ast/line-number clause)
                               ");" line-sep
                               "fprintf(stderr, \"Expected Maybe, got %s\\n\", extractStr(type_name(empty_list, "
                               (.c-var expr) ")));" line-sep
                               "abort();" line-sep
                               "}" line-sep])))))))

(extend-type rdr/tagged-symbol
  EmitCond
  (emit-cond-clause [sym]
    (for [expr (emit sym)
          constraint (type-constraint (expr-type-num expr)
                                      (ast/file-name sym) (ast/line-number sym))]
      (let [expr-c (expr-constraints expr)]
        (.constraints expr (assoc (.constraints expr)
                             (.c-var expr) (comp constraint expr-c)))))))

(extend-type Symbol
  EmitCond
  (emit-cond-clause [sym]
    (for [expr (emit sym)
          constraint (type-constraint (expr-type-num expr)
                                      (ast/file-name sym) (ast/line-number sym))]
      (let [expr-c (expr-constraints expr)]
        (.constraints expr (assoc (.constraints expr)
                             (.c-var expr) (comp constraint expr-c)))))))

(defn clause-refs [exprs result-var]
  (let [clause-vars (-> exprs
                        (remove (fn [c] (empty? (.init c))))
                        (map .c-var)
                        set)
        refs-maps (map exprs .refs-map)]
    (dissoc (apply merge-with (list* + refs-maps))
            result-var)))

(defn last-init [evalled-clauses result-var]
  (let [last-clause (either (last evalled-clauses)
                            (do
                              (print-err "Booom!!!")
                              (abort)))]
    ;; TODO: only check the constraints that haven't been checked yet
    [;; (map (seq (.constraints last-clause))
     ;;      (fn [[var constraint]]
     ;;        (either (and (get (.refs-map last-clause) var)
     ;;                     (maybe (runtime-check (c/update-var constraint (str var)) c/top-type "" 0)))
     ;;                "")))
     (either (and  (= "" (.c-var last-clause))
                   (maybe (.init last-clause)))
             [(.init last-clause)
              result-var " = " (.c-var last-clause) ";" line-sep])]))

(defn cond-clause-init [cond-test result-var [init refs-map] clause]
  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs))]
    [(conj (vec init)
           ;; TODO: only check the constraints that haven't been checked yet
           [;; (map (seq (.constraints clause))
            ;;      (fn [[var constraint]]
            ;;        (either (and (get (.refs-map clause) var)
            ;;                     (maybe (runtime-check (c/update-var constraint (str var)) c/top-type "" 0)))
            ;;                "")))
            (.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            cond-test result-var ",\"\",0)) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  (either (and (= 0 remaining)
                                               (maybe ""))
                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))])
     refs-map]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits] (reduce (butlast evalled-clauses)
                               [[] refs-map]
                               (partial cond-clause-init cond-test result-var))]
    clause-inits))

(defn emit-cond-expr [cond-test result-var clauses tail-return]
  (map (ev/traverse clauses emit-cond-clause)
       (fn [evalled-clauses]
         (let [refs-map (clause-refs evalled-clauses result-var)
               [first-clause] evalled-clauses]
           (c-init result-var
                   ["Value *" result-var ";" line-sep
                    (-> evalled-clauses
                        (clause-inits cond-test refs-map result-var)
                        (conj (last-init evalled-clauses result-var))
                        (interpose [tail-return "} else {" line-sep
                                    "dec_and_free(" result-var ", 1);" line-sep]))
                    (-> (count evalled-clauses)
                        (dec)
                        (repeat (str "}" line-sep)))]
                   (map evalled-clauses .decl)
                   refs-map
                   (assoc (.constraints first-clause)
                     result-var (c/TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing result-var))
                   (ast/file-name clauses) (ast/line-number clauses))))))

(deftype TailAnd [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr "if (isNothing(" result-var
                               (filter (.clauses ast) produces-code?)
                               (str "return(nothing);" line-sep))]
      expr)))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (either (and (empty? clauses)
                   (maybe (sm/state-maybe empty-c-code)))
              (for [result-var (genlocal "andRslt")
                    expr (emit-cond-expr "if (isNothing(" result-var clauses "")]
                expr))))

  (tail-call [ast params result-constraint]
    (let [clauses (-> (.clauses ast)
                      (filter produces-code?)
                      seq
                      reverse)]
      (either (map (first clauses)
                   (fn [last-clause]
                     (TailAnd (-> (tail-call last-clause params result-constraint)
                                  (vector)
                                  (comp (rest clauses))
                                  reverse))))
              (TailAnd []))))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast (vec new-clauses))))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr "if (!isNothing(" result-var
                               (filter (.clauses ast) produces-code?)
                               (str "return(" result-var ");" line-sep))]
      expr)))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (either (and (empty? clauses)
                   (maybe (sm/state-maybe empty-c-code)))
              (flat-map (genlocal "orRslt")
                        (fn [result-var]
                          (emit-cond-expr "if (!isNothing(" result-var clauses
                                          line-sep))))))

  (tail-call [ast params result-constraint]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (TailOr (either (flat-map (last clauses)
                                (fn [last-clause]
                                  (store clauses (dec (count clauses))
                                         (tail-call last-clause params result-constraint))))
                      []))))

  (replace-syms [ast subs]
    (for [new-clauses (ev/traverse (.clauses ast)
                                   (fn [ast]
                                     (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs))))))

(deftype TailEither [clause alt result-constraint]

  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (for [cond-val (emit clause)
          alt-val (map (emit alt)
                       (fn [expr]
                         (let [expr (either (and (instance? Tagged alt)
                                                 (maybe (.refs-map expr {})))
                                            expr)]
                           (emit-tail-expr alt result-constraint expr))))
          result-var (genlocal "rslt")]
      (let [cond-rslt (.c-var cond-val)
            refs-map (merge-with + (.refs-map cond-val) (.refs-map alt-val))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                refs-map
                {result-var result-constraint
                 (.c-var cond-val) (c/TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing (.c-var cond-val))})))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          cond-val (emit-cond-clause (.clause ast))
          syms get-syms
          alt-val (emit (.alt ast))
          _ (set-syms syms)]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val)) refs-map
                {(.c-var cond-val) (c/TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing (.c-var cond-val))}
                (ast/file-name ast) (ast/line-number ast)))))

  (tail-call [ast params result-constraint]
    (TailEither (.clause ast) (.alt ast) result-constraint))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs))))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug "=======\n*** " 'main-fn)
          fn-arity (emit-fn-arity (rdr/tag 'main) (FnValPtr "") (.params ast) (.body ast))
          ;; _ (debug "=======")
          result-constraint (type-constraint IntegerType "" 0)
          _ (new-static-arity (FnValPtr 'main) 1 (.c-fn fn-arity)
                              (c/ResultConstraint result-constraint))]
      [(c-code "" [] (.decl (.var-info fn-arity)) {} {})])))


(defn static-fn [fn-sym fn-var arities]
  (assert (instance? FnValPtr fn-var))
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (ev/traverse arities
                                     (fn [static-arity]
                                       (for [_ (new-static-arity fn-var
                                                                 (.param-count static-arity)
                                                                 (.c-fn static-arity)
                                                                 (.result-constraints static-arity)
                                                                 (.param-constraints static-arity))]
                                         (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)
          decl ["\n// --------- " fn-sym " -------------\n"
                "Value *" fn-var ";\n"
                (map emitted-arities .decl)
                "Function " struct-var " = {FunctionType, -1, \""
                fn-sym "\", " arity-count ", "
                "{" (to-str (interpose (map emitted-arities .c-var)
                                       ", "))
                "}};\n"
                "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]]
      (either (or (and (= fn-sym 'list)
                       (maybe (c-list-fn fn-var [] decl {} {} struct-var)))
                  (and (= fn-sym 'vector)
                       (maybe (c-vector-fn fn-var [] decl {} {} struct-var))))
              (c-static-fn fn-var [] decl
                           {} {fn-var fn-constraint} struct-var)))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-init (str fn-var)
              [(map emitted-arities .init)
               line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
               struct-var "->name = \"" fn-sym "\";" line-sep
               struct-var "->arityCount = " arity-count ";" line-sep
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";" line-sep)))
               "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
              [(map emitted-arities .decl)] (apply merge-with (list* + (map emitted-arities .refs-map)))
              (assoc (.constraints (collapse-expressions emitted-arities))
                (str fn-var) fn-constraint)
              (ast/file-name fn-sym) (ast/line-number fn-sym)))))

(defn missing-impl-body [proto-sym fn-sym prototype]
  (let [disp-arg (either (-> prototype .params .fixed first extract (str "_") check-C-var)
                         "arg")]
    (comp (filter (.default-body prototype) assertion?)
          (filter (.default-body prototype) return-assertion?)
          [(ast/inline-ast
            'C nothing
            (str "if (closures != (List *)0) {"
                 "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                 "' for type '%s' at %s\\n\", "
                 "((String *)type_name(empty_list, " disp-arg "0))->buffer, "
                 "((String *)closures)->buffer);\nabort();\n"
                 "} else {"
                 "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
                 "' for type '%s'\\n\", "
                 "((String *)type_name(empty_list, " disp-arg "0))->buffer);\nabort();\n"
                 "}")
            (ast/file-name fn-sym) (ast/line-number fn-sym))])))

(defn emit-proto-default [protocol-sym fn-sym disp-fn-var prototype]
  (let [body (filter (.default-body prototype) produces-code?)
        body (either (and (empty? body)
                          (maybe (missing-impl-body protocol-sym fn-sym prototype)))
                     (.default-body prototype))]
    (for [arity-impl-var (global-var (str "Default_" fn-sym) "arityImpl")
          :let [arity-impl-var (ProtoDispFnPtr arity-impl-var)]
          static-arity (emit-fn-arity (rdr/tag (str "Default_" fn-sym)) disp-fn-var
                                      (.params prototype)
                                      (comp (remove (.default-body prototype) produces-code?)
                                            body)
                                      arity-impl-var)
          _ (sm/assoc-in-val [.modules (ast/file-name protocol-sym) .protocols protocol-sym fn-sym
                              (.param-count static-arity) 0]
                             (ProtoImpl 0 (.c-var (.var-info static-arity))
                                        (ast/fn-arity (.params prototype) "" body)
                                        (.param-constraints static-arity)
                                        (.result-constraints static-arity)
                                        arity-impl-var))
          _ (sm/assoc-in-val [.fns (.arity-fn-var static-arity) (.param-count static-arity) .param-constraints]
                             (.param-constraints static-arity))]
      (.decl (.var-info static-arity)))))

(defn create-dispatcher [proto-sym [fn-sym arities]]
  (for [proto-sym-expr (emit (ast/quoted-ast proto-sym))
        fn-sym-expr (emit (ast/quoted-ast fn-sym))

        fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                     (global-var (str "dispFn_" fn-sym) "fn"))
        :let [fn-var (FnValPtr fn-var)]
        arities-info (ev/traverse arities
                                  (fn [arity]
                                    (let [arg-count (count (.params arity))]
                                      (for [c-fn (global-var (str "disp_" fn-sym) "dispatcher")
                                            result-constraints (-> arity
                                                                   .default-body
                                                                   (filter return-assertion?)
                                                                   (ev/traverse to-constraint))
                                            _ (new-static-arity fn-var arg-count (ProtoDispFnPtr c-fn)
                                                                (comp* (c/ResultConstraint c/top-type)
                                                                       result-constraints)
                                                                c/empty-items-constraint)]
                                        ["Value *" c-fn "("
                                         (-> (map (range arg-count) (fn [n] (str "Value *arg" n)))
                                             (conj "List *closures")
                                             (interpose ", "))
                                         ");\n"]))))

        _ (new-module-def fn-sym (c-protocol-fn fn-var [] [] {} {fn-var fn-constraint} ""))
        default-fns (ev/traverse arities (partial emit-proto-default proto-sym fn-sym fn-var))]
    [(.decl proto-sym-expr)
     (.decl fn-sym-expr)
     "\n// proto fn for " proto-sym "/" fn-sym "\n"
     "\n// --------- " fn-sym " -------------\n"
     "Value *" fn-var ";\n"
     arities-info
     default-fns]))

(defn check-protocol-name [proto-sym]
  ;; Ensure all protocol symbols are unique
  (comp (for [proto-info (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])]
          (do
            (print-err  "Duplicate protocol"
                        (str "'" proto-sym "'") "at"
                        (str (ast/file-name proto-sym) ":")
                        (ast/line-number proto-sym))
            (abort)))
        (sm/state-maybe '_)))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (check-protocol-name proto-name)
            decl (ev/traverse (seq prototype-map)
                              (partial create-dispatcher proto-name))]
        [(c-code "" [] decl {} {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (either (and (= "" (.fn-sym ast))
                                (maybe (rdr/tag 'anon
                                                (ast/file-name (.params ast))
                                                (ast/line-number (.params ast)))))
                           (.fn-sym ast))
                   (FnValPtr (str (.fn-var ast))) (.params ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (sm/state-maybe (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (ev/traverse (.body ast) (fn [ast]
                                                (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (rdr/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug "=========")
                ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                :let [fn-var (FnValPtr fn-var)]
                arities (ev/traverse (map (.arities ast) (fn [arity]
                                                           (-> arity
                                                               (.fn-sym fn-sym)
                                                               (.fn-var fn-var))))
                                     emit)
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                :let [fn-var (FnValPtr fn-var)]
                arities (ev/traverse (.arities ast) emit)
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (-> value
                                            (.init [])
                                            (.decl [])
                                            (.refs-map {})))]
      [value]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (ev/traverse (.arities ast)
                                   (fn [arity]
                                     (replace-syms arity subs)))]
      (.arities ast (vec new-arities))))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (get-type-numbers (maybe type-sym))
                  fns (map (ev/traverse (seq type-nums) (partial extend-type* ast))
                           flatten)]
              fns)
            (compilation-error "Trying to extend unknown type: "
                               (str "'" type-sym "'") "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(deftype constraint-ast [constraint ast]
   (assert (instance? c/SymbolConstraints constraint))

  Stringable
  (string-list [_]
    (list "<ExprConstraint " (str constraint) " " (str ast) ">"))

  Emitter
  (replace-syms [_ subs]
    (for [new-ast (replace-syms ast subs)]
      (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (c/update-sym constraint new-sym))
                                   constraint)]
        (constraint-ast new-constraint new-ast))))

  (replace-bound-vars [_ subs]
    (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (c/update-sym constraint new-sym))
                                 constraint)
          new-ast (replace-bound-vars ast subs)]
      (constraint-ast new-constraint new-ast)))

  (tail-call [_ params return-constraints]
    (constraint-ast constraint (tail-call ast params return-constraints)))

  (emit [_]
    (for [expr (emit ast)]
      (add-constraint expr
                      (c/update-path constraint (ast/file-name ast) (ast/line-number ast))
                      (ast/file-name ast) (ast/line-number ast)))))

(defn constructor-expr [new-type-name new-type-constraint type-val-sym fields assertions]
  (assert (instance? c/TypeConstraint new-type-constraint))
  (assert (instance? Vector fields))

  (let [reified-type-num (extract rdr/type-counter)
        x* (rdr/tag "#x")
        y* (rdr/tag "#y")]
    (ast/definition new-type-name
      [(ast/reified reified-type-num
                    {Type-sym
                     [[type-name-sym
                       [(ast/fn-arity-ast (str new-type-name "_const_type_name") (FnValPtr "")
                                          (ast/params ['_]) ""
                                          [(str "*" new-type-name " constructor*")])]]
                      [type-mapping-sym
                       [(ast/fn-arity-ast (str new-type-name "_const_type_map") (FnValPtr "")
                                          (ast/params ['_]) ""
                                          [(map-vals (.type-maps new-type-constraint)
                                                     (fn [field-set]
                                                       (map field-set ast/quoted-ast)))])]]
                      [instance?-sym
                       [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") (FnValPtr "")
                                          (ast/params [x* y*]) ""
                                          [(ast/and-ast
                                            [(ast/call-ast =*-sym
                                                            [(ast/call-ast get-type-sym [type-val-sym])
                                                             (ast/call-ast get-type-sym [y*])])
                                             (ast/call-ast maybe-sym [y*])])])]]]

                     Function-sym
                     [[invoke-sym
                       [(ast/fn-arity-ast (str new-type-name "_invoke") (FnValPtr "")
                                          (ast/params (vec (cons '_ (seq fields)))) ""
                                          (comp assertions
                                                [(constraint-ast
                                                  new-type-constraint
                                                  (ast/call-ast new-type-value-sym
                                                                [type-val-sym
                                                                 (ast/call-ast 'vector
                                                                               (vec fields))]))]))]]]

                     Container-sym
                     [[apply-sym
                       [(ast/fn-arity-ast (str new-type-name "_apply_ST_") (FnValPtr "")
                                          (ast/params ['_ 'fields]) ""
                                          ;; TODO: need field constraints here
                                          [(ast/call-ast new-type-value-sym
                                                          [type-val-sym
                                                           (ast/call-ast 'vec ['fields])])])]]]

                     Stringable-sym
                     [[string-list-sym
                       [(ast/fn-arity (ast/params ['z]) ""
                                      [(ast/call-ast list-sym
                                                     ["<TypeCon " (str new-type-name) " ["
                                                      (to-str (interpose fields ", ")) "]>"])])]]]})])))

(defn type-val-expr [type-sym type-num type-val-sym fields impls]
  (let [x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field* (rdr/tag "#field")
        ctxt* (rdr/tag "#ctxt")]
    (ast/definition type-val-sym
      [(ast/reified type-num
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") (FnValPtr "")
                                                      (ast/params [x*]) ""
                                                      [(str type-sym)])]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") (FnValPtr "")
                                     (ast/params [x* field*]) ""
                                     [(ast/or-ast
                                       (conj (map fields
                                                  (fn [field]
                                                    (ast/call-ast identical-sym
                                                                  [(rdr/tag (str "." field))
                                                                   field*])))
                                             (rdr/tag 'nothing)))])]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") (FnValPtr "")
                                     (ast/params [x* y*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast
                                         =*-sym [(ast/call-ast get-type-sym [x*])
                                                 (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast
                                         =*-sym [(ast/call-ast reified-type-args-sym [x*])
                                                 (ast/call-ast reified-type-args-sym [y*])])
                                        (ast/call-ast maybe-sym [x*])])])]]]

                                 Associative-sym
                                 [[get-symb
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") (FnValPtr "")
                                     (ast/params [x* field*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym
                                                      [(ast/call-ast field* [x*])])])])]]

                                  [assoc-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_") (FnValPtr "")
                                     (ast/params [x* field* 'new-value]) ""
                                     [(ast/call-ast
                                       extract-sym
                                       [(ast/or-ast
                                         [(ast/and-ast
                                           [(ast/call-ast has-field-sym [x* field*])
                                            (ast/call-ast
                                             maybe-sym
                                             [(ast/call-ast field* [x* 'new-value])])])
                                          (ast/call-ast maybe-sym [x*])])])])]]]

                                 Hashable-sym
                                 [[sha1-update-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1_update") (FnValPtr "")
                                     (ast/params [x* ctxt*]) ""
                                     [(ast/call-ast sha1-update-type-sym [x* ctxt*])
                                      (ast/call-ast
                                       sha1-update-sym
                                       [(ast/call-ast reified-type-args-sym [x*]) ctxt*])])]]
                                  [sha1-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1") (FnValPtr "")
                                     (ast/params [x*]) ""
                                     [(ast/call-ast
                                       sha1-finalize-sym
                                       [(ast/call-ast
                                         sha1-update-sym
                                         [x* (ast/call-ast sha1-init-sym [])])])])]]]}
                                impls))])))

(defn declare-getters [new-type-name fields]
  (ev/traverse fields
               (fn [field]
                 (let [getter-sym (rdr/tag (str "." field) 'core 0)]
                   (comp (map (sm/get-in-val [.modules 'core .protocols Type-sym getter-sym]) (fn [_] []))
                         (create-dispatcher Type-sym
                                            [getter-sym
                                             [(ast/prototype getter-sym
                                                             (ast/params [(symbol "#x")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint getter-sym
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])
                                              (ast/prototype getter-sym
                                                             (ast/params [(symbol "#x") (symbol "#y")])
                                                             (ast/block-comment "" 0 [])
                                                             [(c/FieldConstraint getter-sym
                                                                               ""
                                                                               empty-list
                                                                               (maybe (symbol "#x"))
                                                                               "")])]]))))))

(defn create-getters [sym constraint fields field-constraints]
  (let [type-value (rdr/tag "#value")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            (let [new-value (rdr/tag (str field))
                  extract-field (ast/call-ast extract-sym
                                              [(ast/call-ast nth-sym
                                                             [(ast/call-ast reified-type-args-sym
                                                                            [type-value])
                                                              field-index])])
                  extract-field (either (or (map (= c/top-type field-constraint)
                                                 (fn [_]
                                                   [extract-field]))
                                            (map (instance? c/MultiConstraint field-constraint)
                                                 (fn [mc]
                                                   (map (.constraints mc)
                                                        (fn [c]
                                                          (constraint-ast c extract-field))))))
                                        [(constraint-ast field-constraint extract-field)])
                  set-field [(c/update-sym field-constraint field)
                             (constraint-ast constraint
                                             (ast/call-ast make-value-sym
                                                           [type-value
                                                            (ast/call-ast extract-sym
                                                                          [(ast/call-ast
                                                                            store-sym
                                                                            [(ast/call-ast
                                                                              reified-type-args-sym
                                                                              [type-value])
                                                                             field-index new-value])])]))]]
              [(rdr/tag (str "." field))
               [(ast/fn-arity-ast (str sym "_" field) (FnValPtr "")
                                  (ast/params [type-value new-value]) ""
                                  set-field)
                (ast/fn-arity-ast (str sym "_" field) (FnValPtr "")
                                  (ast/params [type-value]) ""
                                  extract-field)]])))}))

(defn destruct-impl-fields [sym ast field-types arity]
  (let [[type-value-parameter] (.fixed (.params arity))
        return-assertions (filter (.body arity) return-assertion?)
        new-body (comp return-assertions
                       [(ast/assert-type (.sym ast) type-value-parameter)]
                       (filter (.body arity) assertion?)
                       [(ast/let-ast [(ast/binding (.fields ast)
                                        (constraint-ast field-types (ast/call-ast
                                                                     reified-type-args-sym
                                                                     [type-value-parameter])))]
                                     (remove (.body arity) assertion?))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str sym "_" fn-name)))))

(defn destructure-fields [sym ast field-types]
  (let [impls (comp* {} (filter (.impls ast)
                                (partial instance? HashMap)))]
    (map-vals impls
              (fn [impl-arities]
                (map impl-arities
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields sym ast field-types))]))))))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))
          field-assertions (filter (.impls ast) assertion?)]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            (either (and (= file-name 'core)
                                                         (maybe "$TOCCATA_DIR/core.toc"))
                                                    file-name)
                                            ", " line-number))]
              "")

            ;; TODO: 'type-val-sym' ends up looking like "g_g__HASH_type_val_2882_2883'
            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym file-name line-number)
                        type-num (extract rdr/type-counter)
                        type-map {type-num (-> fields
                                               (map (fn [name]
                                                      (symbol
                                                       (str "." name))))
                                               set)}
                        new-type-constraint (c/TypeConstraint type-map (list [file-name line-number])
                                                            sym nothing "")]
                  _ (sm/assoc-in-val [.type-maps type-num] (TypeInfo sym type-map))
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)
                  _ (sm/assoc-in-val [.constants .type-names type-num] (str sym))
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition
                                    (constructor-expr sym new-type-constraint type-val-sym fields
                                                      field-assertions))
                  field-maps (ev/traverse field-assertions
                                          (fn [assertion]
                                            (map (to-constraint (.assertion assertion))
                                                 (fn [c]
                                                   {(.sym (.assertion assertion)) c}))))
                  :let [field-map (reduce field-maps {} (fn [m field-map]
                                                          (merge-with (partial compose-constraints
                                                                               file-name line-number)
                                                                      m field-map)))
                        field-constraints (c/ItemsConstraint
                                           (map fields (fn [field]
                                                         (either (get field-map field)
                                                                 c/top-type)))
                                           empty-list (maybe (symbol (str sym "-field-constraints"))) "")
                        impls (merge-with comp
                                          (create-getters sym new-type-constraint fields
                                                          (.items-constraints field-constraints))
                                          (destructure-fields sym ast field-constraints))]
                  type-val-def (emit-definition (type-val-expr sym type-num type-val-sym
                                                               fields impls))

                  const-type-num (map (sm/get-in-val [.modules file-name .values sym])
                                      expr-type-num)
                  _ (sm/assoc-in-val [.modules 'core .protocols Function-sym invoke-sym const-arity-index
                                      const-type-num .result-constraints]
                                     (c/ResultConstraint new-type-constraint))]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) {} {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {} empty-closures)
                                   (RuntimeInit (FunctionArityContext {} 0 {} {} empty-closures)
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names {})
                                   0                        ;; reify-fn-index
                                   core-types               ;; type-maps
                                   ))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");\n"]))

(defn gather-protocols [file-name]
  (comp (for [protocols (sm/get-in-val [.modules file-name .protocols])
              expr (encode-static protocols)
              _ (ev/traverse (for [[proto-sym proto-fns] (seq protocols)
                                   [fn-sym arities] (seq proto-fns)]
                               [proto-sym fn-sym arities])
                             (fn [[proto-sym fn-sym arities]]
                               (for [disp-fn (sm/get-in-val [.modules file-name .values fn-sym])
                                     :let [fn-var (.c-var disp-fn)]
                                     c-fns (ev/traverse (keys arities)
                                                        (fn [arg-count]
                                                          (for [disp-arity (lookup-static-arity-info fn-var arg-count)
                                                                arity-var (global-var "arity")]
                                                            [arg-count arity-var (.c-var disp-arity)])))
                                     struct-var (global-var "dispFnStruct")
                                     _ (sm/assoc-in-val [.modules file-name .values fn-sym]
                                                        (c-static-val fn-var [] [] {} {} struct-var))]
                                 (write-strings
                                  [(map c-fns
                                        (fn [[arg-count arity-var c-fn]]
                                          (let [impls (extract (get arities arg-count))]
                                            ["Value *" c-fn "(List *"
                                             (interpose (cons "closures" (map (range arg-count)
                                                                              (partial str "Value *arg")))
                                                        ",")
                                             ") {\nFnArity *arity;\n#\n"
                                             "FnType" arg-count " *_fn;\n"
                                             "switch (arg0->type) {\n"
                                             (map (seq (dissoc impls 0))
                                                  (fn [[type-num arity-info]]
                                                    (assert (instance? ProtoImpl arity-info))

                                                    ["case " (str type-num) ": arity = "
                                                     (.c-var arity-info) ";\n_fn = (FnType"
                                                     arg-count " *)" (.c-fn arity-info) ";\n"
                                                     (for [[constraint var] (-> (.param-constraints arity-info)
                                                                                (.items-constraints)
                                                                                (zip-lists (map (range arg-count)
                                                                                                (partial str "arg"))))]
                                                       (-> constraint
                                                           (c/update-var var)
                                                           (runtime-check c/top-type
                                                                          "((String *)closures)->buffer")))
                                                     "\nbreak;\n"]))
                                             (let [arity-info (extract (get impls 0))]
                                               ["default: arity = " (.c-var arity-info) ";_fn = (FnType" arg-count
                                                " *)" (.c-fn arity-info) ";\nbreak;\n"])
                                             "}\n"
                                             ;; "FnType" arg-count " *_fn = (FnType" arg-count " *)arity->fn;\n" 
                                             "return(_fn(arity->closures, " (-> (range arg-count)
                                                                                (map (partial str "arg"))
                                                                                (interpose ", "))
                                             "));\n}\n"
                                             "FnArity " arity-var " = {FnArityType, -1, "
                                             arg-count
                                             ", (List *)0, 0, " c-fn "};\n"])))
                                   "Function " struct-var " = {FunctionType, -1, \""
                                   fn-sym "\", " (count c-fns) ", "
                                   "{" (interpose (map c-fns (fn [[_ arity-var]] (str "&" arity-var))) ", ")
                                   "}};\n"
                                   "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]))))
              protos-var (sm/get-in-val [.modules file-name .values protocols-sym])]
          (comp expr
                (c-code (.c-var protos-var)
                        [(.c-var protos-var) " = " (.c-var expr) ";\n"]
                        [] {} {})))
        (compilation-error "Could not gather the protocols for" (str "'" file-name "'"))))

(defn gather-symbols [file-name]
  (for [symbols (sm/get-in-val [.modules file-name .values])
        expr (-> symbols
                 (dissoc symbols-sym)
                 (encode "symbols_"))
        sym-var (sm/get-in-val [.modules file-name .values symbols-sym])]
    (comp expr
          (c-code (.c-var sym-var)
                  [(.c-var sym-var) " = " (.c-var expr) ";\n"]
                  [] {} {}))))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity-info (FnValPtr 'main) 1)
                      (compilation-error "'main' function is missing"))
        modules (sm/get-in-val [.modules])
        protos (ev/traverse (keys modules) gather-protocols)
        symbols (ev/traverse (keys modules) gather-symbols)
        values (sm/get-in-val [.rt-init .exprs])]
    (write-strings ["\n#\n"
                    (map protos .decl)
                    (map symbols .decl)
                    "\nint main (int argc, char **argv) {\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map protos .init)
                    (map values .init) "\n"
                    (map symbols (fn [sym-map]
                                   [(.init sym-map) (.c-var sym-map) "->refs = -1;\n"]))
                    "\n#\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    "cleaningUp = 1;\n"
                    "mainThreadDone = 1;\n"
                    "waitForWorkers();\n"
                    (map (vals modules) (fn [module]
                                          (either (map (get-in module [.values symbols-sym])
                                                       (fn [expr]
                                                         (free-global (c-init (.c-var expr)
                                                                              [] [] {} {} "" 0))))
                                                  "")))
                    (map values free-global)
                    "\n#\n"
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif"
                    "\n#\n"
                    "  return(0);\n};\n"])))

(defn get-proto-dispatch-sym [fn-sym num-args]
  (for [fn-var (lookup-sym fn-sym)
        arity-var (sm/get-in-val [.fns (.c-var fn-var) num-args])]
    (.c-var arity-var)))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (for [protos-var (global-var "protos_")
                              symbols-var (global-var "symbols_")
                              _ (sm/assoc-in-val [.modules module-name]
                                                 (Module module-name
                                                         {protocols-sym (c-code protos-var [] [] {} {})
                                                          symbols-sym (c-code symbols-var [] [] {} {})}
                                                         {} core-type-nums {}))]
                          (write-strings ["Value *" protos-var " = (Value *)&emptyBMI;\n"
                                          "Value *" symbols-var " = (Value *)&emptyBMI;\n"
                                          ]))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [emitted (map emitted (fn [expr]
                                                           (write-strings (.decl expr))
                                                           (.decl expr [])))]
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))


(def fixup-native-symbols*
  (apply (sm/state-maybe (fn [& decl]
                            (write-strings decl)))
          (list (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                     (fn [arity-sym]
                       ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                     (fn [arity-sym]
                       ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                     (fn [arity-sym]
                       ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                     (fn [arity-sym]
                       ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                     (fn [arity-sym]
                       ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                     (fn [arity-sym]
                       ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                     (fn [arity-sym]
                       ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'vals) 1)
                     (fn [arity-sym]
                       ["Value *(*vals)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'rest) 1)
                     (fn [arity-sym]
                       ["Value *(*rest)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'seq) 1)
                     (fn [arity-sym]
                       ["Value *(*seq)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                     (fn [arity-sym]
                       ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                     (fn [arity-sym]
                       ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'has-field) 2)
                     (fn [arity-sym]
                       ["Value *(*hasField)(List *, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                     (fn [arity-ptr]
                       ["Value *(*showFn)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'new-hash-set) 1)
                     (fn [arity-ptr]
                       ["Value *(*newHashSet)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'apply) 2)
                     (fn [arity-ptr]
                       ["Value *(*fn_apply)(List *, Value*, Value*) = " arity-ptr ";\n"]))
                )))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ev/Evaluator
  (ev/eval [x]
    (let [file (.file-path x)]
      (comp (for [curr-file-name (sm/get-val .file-name)
                  curr-file-path (sm/when (sys/file-directory curr-file-name))
                  :let [file (str curr-file-path file)]
                  mod-syms (comp (sm/get-in-val [.ns file .syms])
                                 (for [asts (sm/when (for [file-in (fio/file-in file)
                                                           asts (ev/parse {'file-name file
                                                                           'line-number 1}
                                                                          (lazy-list file-in))]
                                                       asts))
                                       _ (sm/set-val .file-name file)
                                       base-imports (sm/get-val .base-imports)
                                       _ (sm/assoc-in-val [.ns file] (ev/EvalNamespace file base-imports {} {}))
                                       _ (ev/eval asts)
                                       mod-syms (sm/get-in-val [.ns file .syms])]
                                   mod-syms))
                  _ (sm/assoc-in-val [.ns curr-file-name .imports file] mod-syms)]
              mod-syms)
            (ev/abort-interp "Could not import module" (str "'" file "'") "at"
                             (ev/ast-location-str x))))) 

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def repo-cloner (agent {}))

(defn clone-repo* [ast proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sys/sh-proc "/usr/bin/git" (list "clone" "--branch" branch
                                                   (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sys/sh-proc "/usr/bin/git"
                                             (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ev/Evaluator
  (ev/eval [ast]
    (let [file (.file ast)]
      (either (and (-> file
                      seq
                      (some (partial = "/")))
                   (maybe (ev/abort-interp "For git dependencies,"
                                           "files may only be imported from root of repository,"
                                           file "is invalid.")))
              (comp (for [script-dir (sm/get-val .script-dir)
                          :let [clone-waiter (promise)
                                dep-path (do
                                           (clone-repo {} ast clone-waiter script-dir)
                                           (extract clone-waiter))
                                module-path (str dep-path "/" file)
                                _ (or (sys/access module-path)
                                      (do
                                        (print-err "Dependency file" file "missing from cloned repository"
                                                   (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                                        (abort)))]
                          curr-file-name (sm/get-val .file-name)
                          _ (sm/set-val .file-name module-path)
                          r (ev/eval (ast/module-ast file))
                          _ (sm/set-val .file-name curr-file-name)]
                      r)
                    (ev/abort-interp "Could not import module" (str "'" file "'") "from git repo at"
                                     (ev/ast-location-str ast))))))

  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (do
                  (send ast-emitter
                        (fn [context]
                          (update-context context
                                          (for [protocols-var (sm/get-in-val [.modules 'core .values protocols-sym])
                                                _ (sm/assoc-in-val [.modules 'core .values 'protocols]
                                                                   protocols-var)
                                               symbols-var (sm/get-in-val [.modules 'core .values symbols-sym])
                                                _ (sm/assoc-in-val [.modules 'core .values 'symbols]
                                                                   symbols-var)]
                                            '_))))
                  (assoc modules 'core 'loaded))))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? HashMap loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (let [r (analyze-forms {'file-name file-name
                                                                         'root-directory root-dir
                                                                         'project-directory proj-dir
                                                                         'line-number 1}
                                                                        (lazy-list file-in))]
                                                   (send ast-emitter
                                                         (fn [context]
                                                           (update-context
                                                            context
                                                            (for [protocols-var (sm/get-in-val [.modules file-name .values protocols-sym])
                                                                  _ (sm/assoc-in-val [.modules file-name .values 'protocols]
                                                                                     protocols-var)
                                                                  symbols-var (sm/get-in-val [.modules file-name .values symbols-sym])
                                                                  _ (sm/assoc-in-val [.modules file-name .values 'symbols]
                                                                                     symbols-var)]
                                                              '_))))
                                                   r)))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(extend-type ev/Thunk
  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (sm/state-maybe (fn [& rules]
                      (apply (sm/state-maybe (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type ev/ProtoDispatcher
  rd/RecursiveDescent
  (rd/recursive-descent [f]
    (sm/state-maybe (fn [& rules]
                      (apply (sm/state-maybe (fn [& parsed-values]
                                                (apply f (remove parsed-values rd/ignore?))))
                              rules)))))

(extend-type sm/new-sm
  ev/Evaluator
  (ev/apply-fn [mv [state]]
    (sm/state-maybe (mv state))))

(main [params]
  (either (or (and (< (count params) 2)
                   (do
                     (print-err "A filename to compile must be provided.")
                     (maybe -1)))
              (and (< 2 (count params))
                   (let [[_ option file-name & args] params]
                     (or (and (= "--script" option)
                              (flat-map (sys/file-directory file-name)
                                        (fn [script-dir]
                                          (interp/interp-file file-name script-dir
                                                              [(interp/CompiledNs 'file fio/symbols fio/protocols)
                                                               (interp/CompiledNs 'reader rdr/symbols rdr/protocols)
                                                               (interp/CompiledNs 'grammar grmr/symbols grmr/protocols)
                                                               (interp/CompiledNs 'parse rd/symbols rd/protocols)
                                                               (interp/CompiledNs 'ast ast/symbols ast/protocols)
                                                               (interp/CompiledNs 'sys sys/symbols sys/protocols)
                                                               (interp/CompiledNs 'state-maybe sm/symbols sm/protocols)
                                                               (interp/CompiledNs 'strm strm/symbols strm/protocols)]
                                                              args))))
                         (do
                           (print-err "The only option for the compiler is '--script'")
                           (maybe -1))))))
          (let [[_ file-name] params
                waiter (promise)]
            (or (map (sys/file-directory file-name)
                     (fn [root-dir]
                       (write-strings ["\n#define _XOPEN_SOURCE 600"
                                       "\n#include <stdlib.h>"
                                       "\n#include \"core.h\"\n"])
                       (send module-compiler compile-module file-name waiter root-dir root-dir)))
                (do
                  (print-err "Could not find " (str "'" file-name "'"))
                  (abort)))
            (extract waiter)
            (send ast-emitter emit-main)
            (send ast-emitter fixup-native-symbols)
            (send ast-emitter (fn [ctxt]
                                (map (get-in ctxt ['_ .constants .other])
                                     (fn [counts]
                                       (apply print-err (list* "\n" (interpose (map (seq counts)
                                                                                     (fn [[k v]]
                                                                                       (str k ": " v)))
                                                                                "\n")))))))
            ;; wait for agents to clear their queues
            (let [waiter (promise)]
              (send ast-emitter (fn [_]
                                  (send string-writer (fn [_]
                                                        (deliver waiter 'x)))))
              (extract waiter)))))
