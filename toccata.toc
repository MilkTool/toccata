
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def UnknownType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, 1};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, 2};"))
(def SubStringType (inline-C Number "(Value *)&(Number){NumberType, -1, 5};"))
(def FnArityType (inline-C Number "(Value *)&(Number){NumberType, -1, 3};"))
(def FunctionType (inline-C Number "(Value *)&(Number){NumberType, -1, 4};"))
(def ListType (inline-C Number "(Value *)&(Number){NumberType, -1, 6};"))
(def MaybeType (inline-C Number "(Value *)&(Number){NumberType, -1, 7};"))
(def VectorType (inline-C Number "(Value *)&(Number){NumberType, -1, 8};"))
(def VectorNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 9};"))
(def SymbolType (inline-C Number "(Value *)&(Number){NumberType, -1, 10};"))
(def BitmapIndexedType (inline-C Number "(Value *)&(Number){NumberType, -1, 11};"))
(def ArrayNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 12};"))
(def HashCollisionNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 13};"))
(def HashMapType (inline-C Number "(Value *)&(Number){NumberType, -1, 14};"))
(def PromiseType (inline-C Number "(Value *)&(Number){NumberType, -1, 15};"))
(def FutureType (inline-C Number "(Value *)&(Number){NumberType, -1, 16};"))
(def AgentType (inline-C Number "(Value *)&(Number){NumberType, -1, 17};"))

(def type-names {1 "Integer"
                 2 "String"
                 3 "FnArity"
                 4 "Function"
                 5 "SubString"
                 6 "List"
                 7 "Maybe"
                 8 "Vector"
                 9 "VectorNode"
                 10 "Symbol"
                 11 "BitmapIndexNode"
                 12 "ArrayNode"
                 13 "HashCollisionNode"
                 14 "HashMap"
                 15 "Promise"
                 16 "Future"
                 17 "Agent"})

(defn target-type-name [n]
  (extract (or (get type-names n)
               (maybe (str n)))))

(def core-types {'Integer IntegerType
                 'String StringType
                 'SubString SubStringType
                 'FnArity FnArityType
                 'Function FunctionType
                 'List ListType
                 'Maybe MaybeType
                 'Vector VectorType
                 'Symbol SymbolType
                 'BitmapIndexedNode BitmapIndexedType
                 'ArrayNode ArrayNodeType
                 'HashCollisionNode HashCollisionNodeType
                 'HashMap HashMapType
                 'Promise PromiseType
                 'Future FutureType
                 'Agent AgentType})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(deftype ConstantValues [numbers strings symbols]
  ;; numbers                static numbers
  ;; strings                static strings
  ;; symbols                static symbols
  )

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang fn-context init-fn-context modules
                        fns namespaces constants reify-fn-index]
  ;; target-lang            language to compile to
  ;; fn-context             context for the fn currently being compiled
  ;; init-fn-context        context for the initialization code
  ;; modules                info for each module compiled
  ;; numbers                static numbers
  ;; strings                static strings
  ;; fns                    static functions
  ;; namespaces             current namespace map
)

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types declarations]
  ;; path             path to file containing the modules source code
  ;; values           map of value symbols to defined values
  ;; protocols        set of protocol symbols
  ;; proto-fns        map of protocol fn symbols to fn information
  ;; types            map of type symbols to type definitions
  ;; declarations     map of symbols to C vars that have not been defined
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

(deftype Closures [closures refs-map])
(def empty-closures (Closures empty-list {}))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [sym-count syms context closed-over]
  ;; var-count     number of C variables already used in this fn
  ;; syms          the symbols local to the function that are currently interned
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn reset-fn-context
  ([]
   (for [curr-fn-context (sm/get-val .fn-context)
         :let [new-context (comp (.context curr-fn-context) (.syms curr-fn-context))]
         _ (sm/set-val .fn-context (FunctionArityContext 0 {} new-context empty-closures))]
     curr-fn-context))
  ([new-fn-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-fn-context)]
     curr-fn-context)))

(defn new-module [path]
  ;; If a module for `path` has not been defined yet, initialize it
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {} {} {} core-types {}))))

;; combine a sequence of expressions, adding reference increments and decrements
;; where needed
(defprotocol CollapseExprs
  (collapse-expressions* [x y]))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; type-num: the Toccata type of the value produced
;; refs-map: map of C variables that are used in 'init' and how many times
(deftype empty-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Composition
  (zero [c] c)
  (comp* [_ cs]
    (apply comp cs))

  CollapseExprs
  (collapse-expressions* [x y] y))

(def empty-c-code (empty-code "" [] [] UnknownType {}))

(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c collapse-expressions*))

  Collection
  (empty? [c]
    (and (empty? (.init c))
         (empty? (.decl c))))

  CollapseExprs
  (collapse-expressions* [x y]
    (c-code (.c-var y)
            [(.init x) (.init y)]
            [(.decl x) (.decl y)]
            (.type-num y)
            (merge-with + (.refs-map x) (.refs-map y)))))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", " (target-type-name type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Collection
  (empty? [c] nothing)

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (c-code (.c-var c)
                           [(.init result) (.init c)]
                           [(.decl result) (.decl c)]
                           (.type-num c)
                           (merge-with + (.refs-map result) (.refs-map c))))))

  CollapseExprs
  (collapse-expressions* [x y]
    (let [init (extract (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" ["\nincRef(" c-var ", " (dec refs) ");\n"])
                               (.init y)])
                            (and (= "" c-var)
                                 (maybe [(.init x) (.init y)]))
                            (maybe [(.init x)
                                    "\ndec_and_free(" c-var ", 1);\n"
                                    (.init y)])))
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              [(.decl x) (.decl y)]
              (.type-num y)
              refs-map))))

(defn collapse-expressions [cs]
  (extract (or (and (empty? cs) (maybe empty-c-code))
               (maybe (let [[c & cs] (reverse cs)
                            cs (remove cs empty?)]
                        (reduce cs c (fn [y x]
                                       (collapse-expressions* x y))))))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
              _ (compilation-error "Duplicate protocol" (str "'" proto-sym "'") "at"
                                   (str (ast/file-name proto-sym) ":")
                                   (ast/line-number proto-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using the current file name
  ;; 3. using `'core` for protcols defined in the core
  (comp (for [ns-sym (sm/when (rdr/namespace proto-sym))
              protocol-path (sm/get-in-val [.namespaces ns-sym])
              result (sm/get-in-val [.modules protocol-path .protocols proto-sym])]
          result)
        (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
        ;; TODO: change the "" to 'core
        (sm/get-in-val [.modules "" .protocols proto-sym])))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym])
              _ (compilation-error "Duplicate protocol function" (str "'" fn-sym "'") "at"
                                   (str (ast/file-name fn-sym) ":") (ast/line-number fn-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (map (sm/get-in-val [.modules path .proto-fns fn-sym])
       (fn [_] path)))

(defprotocol FindProtoPath
  (find-protocol-path [fn-sym]
    (comp (for [sym-ns (sm/when (rdr/namespace fn-sym))
                namespace (sm/get-in-val [.namespaces sym-ns])
                path (lookup-protocol-path fn-sym namespace)]
            path)
          (lookup-protocol-path fn-sym (ast/file-name fn-sym))
          ;; TODO: Change the "" to 'core
          (lookup-protocol-path fn-sym ""))))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym type-impls]
  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym]
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (for [protocol-path (find-protocol-path fn-sym)
        result (sm/get-in-val [.modules protocol-path .proto-fns fn-sym
                               .dispatchers num-args])]
    result))

(deftype ProtoImpl [dispatch-type c-var ast]
  Stringable
  (string-list [_] (list "<ProtoImpl " (target-type-name dispatch-type) " " c-var ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type c-code ast]
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type (.c-var c-code) ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (for [protocol-path (find-protocol-path fn-name)
        impl-info (sm/get-in-val [.modules protocol-path .proto-fns fn-name
                                  .dispatchers arg-count .type-impls type-num])]
    impl-info))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))


(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_])

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym])

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(extend-type Vector
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(defn genlocal [pre]
  (for [sym-count (sm/get-in-val [.fn-context .sym-count])
        _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
    (symbol (str pre sym-count))))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (ast/file-name sym) .values sym]))

(defn new-module-def [sym value]
  (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
        _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
    r))

(defn lookup-declaration [sym]
  (sm/get-in-val [.modules (ast/file-name sym) .declarations sym '_]))

(defn lookup-core-def [sym]
  ;; TODO: change "" to 'core
  (sm/get-in-val [.modules "" .values sym]))

(defn already-closed-over [sym]
  (for [closed-over (sm/get-in-val [.fn-context .closed-over .closures])
        closure-var (sm/when (some closed-over (fn [[closure-var sym-literal]]
                                                 (for [_ (= sym sym-literal)]
                                                   closure-var))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(defn closed-over-sym [sym]
  (for [;; it's supposed to fail if 'sym' is not in the context
        c-sym (sm/get-in-val [.fn-context .context sym])

        ;; if 'sym' is in the context, it should be in .closed-over
        closure-var (comp (already-closed-over sym)
                          (new-closure sym))]
    (c-code closure-var [] [] (.type-num c-sym) {closure-var 1})))

(defn lookup-sym [sym]
  (comp (sm/get-in-val [.fn-context .syms sym])
        (closed-over-sym sym)
        (lookup-module-def sym)
        (lookup-declaration sym)
        (lookup-core-def sym)
        (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                           (str (ast/file-name sym) ":")
                           (ast/line-number sym))))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn new-static-arity [fn-var num-params arity-var type-num]
  (sm/assoc-in-val [.fns fn-var num-params]
                   (c-code arity-var [] [] type-num {})))

(defn lookup-core-fn-arity [sym num-args]
  ;; TODO: change to 'core
  (for [fn-sym (sm/get-in-val [.modules "" .values sym])
        arity-sym (lookup-static-arity (.c-var fn-sym) num-args)]
    arity-sym))


(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))

  (emit-defined-value [_ _] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe [])))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-in-val [.constants .strings]) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.constants .strings str-val] (c-code str-ptr [] [] StringType {}))]
      (c-init str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(defn make-c-code [value]
  (c-code (.c-var value) (.init value) (.decl value) (.type-num value) (.refs-map value)))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.constants .strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] StringType {}))]
      [(make-c-code value)])))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-in-val [.constants .numbers]) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Number
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] IntegerType {}))]
      [(make-c-code value)])))


(extend-type ast/quoted-ast
  Emitter
  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (map (sm/get-in-val [.constants .symbols]) count)
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-code sym-ptr [] [] SymbolType {}))]
              (c-code sym-ptr
                      []
                      ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                       ", 0, 0, \"" sym "\"};\n"
                       "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                      SymbolType {})))))

  (emit-defined-value [ast defined-sym]
    (for [quoted (emit ast)
          _ (new-module-def defined-sym (c-code (.c-var quoted) [] [] SymbolType {}))]
      [(make-c-code quoted)])))


(extend-type rdr/tagged-symbol
  Emitter
  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (new-module-def defined-sym value)]
      [(make-c-code value)])))


(extend-type Symbol
  Emitter
  (emit [sym]
    (lookup-sym sym)))


(defn get-type [type-symbol]
  (sm/state-maybe 0))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var "var"))
          _ (new-module-def defined-sym (c-code c-var [] [] type-num {}))]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [] [(.txt ast)] type-num {}))))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var "var")
                  :let [c-info (c-code c-var [] [] UnknownType {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              (let [c-info (assoc c-info .c-var "")]
                [(assoc c-info .decl ["Value *" c-var ";\n"])]))))))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-init result-sym
                               ["\n// call-vector\n// #line " (str (ast/line-number target))
                                " " "\""
                                (ast/file-name target) "\"\n"
                                "Vector *" vect-sym " = empty_vect;\n"
                                (map args
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [vect-sym " = mutateVectConj(" vect-sym ", "
                                          arg-sym ");\n"])))
                                "Value *" result-sym " = (Value *)" vect-sym ";\n"]
                               [] VectorType {})]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-init result-sym
                                ["\n// call-list\n// #line "
                                 (str (ast/line-number target)) " " "\""
                                 (ast/file-name target) "\"\n"
                                 "List *" list-sym " = empty_list;\n"
                                 (map (reverse args)
                                      (fn [arg]
                                        (let [arg-sym (.c-var arg)]
                                          [list-sym " = listCons(" "(Value *)" arg-sym
                                           ", " list-sym ");\n"])))
                                 "Value *" result-sym " = (Value *)" list-sym ";\n"]
                                [] ListType {})]))))

(defn dispatch-type-known [target args]
  (let [num-args (count args)]
    (for [dispatch-val (sm/when (first args))
          impl-info (get-proto-impl target num-args (.type-num dispatch-val))
          arity-info (lookup-static-arity (.c-var impl-info) num-args)
          result-sym (genlocal "rslt")
          return-type (sm/when (or (and (= (.type-num arity-info) UnknownType)
                                        ;; TODO: these should be the result of
                                        ;; asserts on the protocol fn defs
                                        (or (= target 'map)
                                            (= target 'comp*)
                                            (= target 'comp)
                                            (= target 'wrap))
                                        (maybe (.type-num dispatch-val)))
                                   (maybe (.type-num arity-info))))]
      (apply comp (comp args
                        [(c-init result-sym
                                 ["\n// type-known for " (str target) "\n// #line "
                                  (str (ast/line-number target)) " " "\""
                                  (ast/file-name target) "\"\n"
                                  "Value *" result-sym " = " (.c-var arity-info) "("
                                  (interpose (conj (map args .c-var) "empty_list")
                                             ", ")
                                  ");\n"]
                                 []
                                 return-type {})])))))

(defn dispatch-type-unknown [target args]
  (let [num-args (count args)]
    (for [impls-sym (map (get-protocol-dispatcher target num-args) .impls-sym)
          result-sym (genlocal "rslt")]
      (apply comp (comp args
                        [(c-init result-sym
                                 ["\n// type-unknown " (str target) "\n// #line " (str (ast/line-number target)) " " "\""
                                  (ast/file-name target) "\"\n"
                                  "Value *" result-sym " = proto" num-args "Arg(&"
                                  impls-sym ", \"" (.sym target) "\", "
                                  (interpose (comp (map args .c-var)
                                                   [(str "\"" (.file-name target) "\"")
                                                    (ast/line-number target)])
                                             ", ")
                                  ");\n"]
                                 []
                                 UnknownType {})])))))

(defn call-proto-impl [target-ast args]
  (for [name (sm/when (and (< 0 (count args))
                           (instance? rdr/tagged-symbol target-ast)
                           (maybe target-ast)))
        call-info (comp (dispatch-type-known name args)
                        (dispatch-type-unknown name args))]
    call-info))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        result-sym (genlocal "rslt")]
    (c-init result-sym
            ["\n// static-fixed\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq arg-vars)) ", ") ");\n"]
            [] (.type-num arity-info) {})))

(defn call-static-variadic [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) 'variadic)
        variadic-sym (genlocal "varArgs")
        result-sym (genlocal "rslt")]
    (c-init result-sym
            ["\n// static-variadic\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "List *" variadic-sym " = empty_list;\n"
             (map (reverse arg-vars)
                  (fn [arg-sym]
                    (str variadic-sym " = (List *)listCons("
                         "(Value *)" arg-sym
                         ", " variadic-sym ");\n")))
             "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
             variadic-sym ");\n"]
            []
            (.type-num arity-info)
            {})))

(defn call-dyn-fn-value [target args file-name line-number]
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (.type-num target))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";\n"
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");\n"
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;\n"
               "\n// #line " line-number " " "\"" file-name "\"\n"
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");\n"
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;\n"
               "List *" variadic-sym " = empty_list;\n"
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");\n")))
               "\n// dynamic fn type\n// #line " line-number " " "\"" file-name "\"\n"
               result-sym " = " fn-var "(" (car arg-syms) ", (Value *)"
               variadic-sym ");\n"
               "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" file-name "\", " line-number
               ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);\n"]
              []
              UnknownType {}))))

(defn call-dyn-unknown-type [target args file-name line-number]
  (let [num-args (count args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (map (lookup-core-fn-arity 'invoke (inc num-args)) .c-var)]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                ["\n// dynamic unknown type"
                 "\n// #line " (str line-number) " " "\""
                 file-name "\"\n"
                 "Value *" result-sym ";\n"
                 "if((" (.c-var target) ")->type != FunctionType) {\n"

                 result-sym " = " invoke-arity-sym "(empty_list, "
                 (to-str (interpose (conj args (.c-var target)) ", "))
                 ");\n} else {\n"

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");\n"
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {\n"
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;\n"
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");\n"
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {\n"
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;\n"
                 "List *" variadic-sym " = empty_list;\n"
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");\n")))
                 result-sym " = " fn-sym "(" (car arg-syms) ", (Value *)" variadic-sym ");\n"
                 "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");\n  abort();\n}\n"
                 "dec_and_free("(.c-var target) ", 1);\n}\n"]
                [] UnknownType {})))))

(defn call-invoke [target args file-name line-number]
  (let [num-args (inc (count args))]
    (for [invoke-info (get-proto-impl 'invoke num-args (.type-num target))
          arity-info (lookup-static-arity (.c-var invoke-info) num-args)
          result-sym (genlocal "rslt")]
      (c-init result-sym
              ["// call invoke\n// #line " line-number " \"" file-name "\"\n"
               "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (conj (cons (.c-var target) args) "empty_list") ", ") ");\n"]
              []
              (.type-num arity-info)
              {}))))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [args (emit (.args ast))
            call-site (comp (call-vector (.call-target ast) args)
                            (call-list (.call-target ast) args)
                            (call-proto-impl (.call-target ast) args)
                            (for [target (emit (.call-target ast))
                                  :let [arg-vars (map args .c-var)]
                                  call-site (comp (call-static-fixed target arg-vars
                                                                     file-name line-number)
                                                  (call-static-variadic target arg-vars
                                                                        file-name line-number)
                                                  (call-invoke target arg-vars
                                                               file-name line-number)
                                                  (call-dyn-fn-value target arg-vars
                                                                     file-name line-number)
                                                  (call-dyn-unknown-type target arg-vars
                                                                         file-name line-number))]
                              (comp* target (comp args [call-site])))
                            (compilation-error "Could not compile call site at:"
                                               file-name line-number))]
        (let [call-site (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                                (.type-num call-site) (.refs-map call-site))]
          call-site))))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(deftype ParamBinding [vars destruct]
  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (cons x xs)]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn unpack-arg-list [list-sym elem-vars file-name line-num]
  (comp (sm/when (for [elem (first elem-vars)
                       :when (= 1 (count elem-vars))
                       var (first (.vars elem))]
                   (ParamBinding [list-sym]
                                 [(c-init var ["Value *" var " = (Value *)" list-sym ";\n"]
                                          [] ListType {})])))
        (for [destructArgs (genlocal "destArgs")]
          (let [elem-c-vars (flat-map elem-vars .vars)
                tail-var (extract (last elem-c-vars))
                elem-count (count elem-vars)]
            (ParamBinding [list-sym]
                          (comp [(c-code ""
                                         [(map elem-c-vars (fn [var] ["Value *" var ";\n"]))
                                          "Value **" destructArgs "[" elem-count "] = {"
                                          (interpose (map elem-c-vars (fn [arg] ["&" arg])) ", ")
                                          "};\n" "destructValue(\"" file-name "\", \"" line-num
                                          "\", (Value *)" list-sym ", " elem-count ", "
                                          destructArgs ");\n"]
                                         [] UnknownType {list-sym 1})]
                                (map elem-c-vars (fn [var]
                                                   (c-init var [] []
                                                           ((= var tail-var) ListType UnknownType)
                                                           {})))
                                (flat-map elem-vars .destruct)))))))

(defprotocol Bindings
  (bind [binding]
    (for [arg-var (genlocal "arg")
          :let [arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (sm/assoc-in-val [.fn-context .syms binding] arg)]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (let [evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled) {(.c-var evalled) 1})]
      (for [_ (sm/assoc-in-val [.fn-context .syms binding] evalled-ref)]
        (ParamBinding [(.c-var evalled)] [evalled (c-init (.c-var evalled) [] []
                                                          (.type-num evalled) {})]))))

  (gen-binding-vars [param]
    ;; generate bindings for symbols and tagged-symbols
    (bind param)))


(extend-type ast/params-ast
  Bindings
  (bind [params]
    (comp (flat-map (sm/when (.variadic params))
                    (fn [_]
                      (gen-binding-vars params)))
          (for [fixed-vars (map (traverse (.fixed params) sm/state-maybe bind) vec)
                tail-var (bind (symbol "#tail"))
                param-var (genlocal "arg")
                destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                          (ast/file-name params)
                                          (ast/line-number params))]
            destruct)))

  (bind [params evalled]
    (for [tail (sm/when (or (.variadic params)
                            (maybe (symbol "#tail"))))
          fixed-vars (map (traverse (.fixed params) sm/state-maybe bind) vec)
          tail-var (bind tail)
          destruct (unpack-arg-list (.c-var evalled) (conj fixed-vars tail-var)
                                    (ast/file-name params) (ast/line-number params))
          destruct (sm/when (or (and (empty? (.init evalled))
                                     (empty? (.decl evalled))
                                     (maybe destruct))
                                (maybe (assoc destruct .destruct
                                              (comp [evalled] (.destruct destruct))))))]
      (let [destruct (assoc destruct .vars [(.c-var evalled)])]
        destruct))))

(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals (sm/get-in-val [.fn-context .syms])
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          _ (sm/assoc-in-val [.fn-context .syms] locals)]
      (let [code (collapse-expressions (comp (flatten (map bindings .destruct)) body-exprs))]
        (c-init (.c-var code) (.init code) (.decl code) (.type-num code) (.refs-map code)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns]
  ;; TODO: change impls-fns to be a list StaticArity/ClosureArity
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (let [impls-syms (map impl-fns .c-var)]
        (c-init reified-sym
                [inits
                 ["Value *" reified-sym " = (Value *)malloc_reified("
                  (count impls-syms) ");\n"
                  "((ReifiedVal *)" reified-sym ")->type = " type-num ";\n"
                  "((ReifiedVal *)" reified-sym ")->implCount = "
                  (count impl-fns) ";\n"
                  "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;\n"]
                 (flat-map (index impls-syms)
                           (fn [[index sym]]
                             ["((ReifiedVal *)" reified-sym
                              ")->impls[" index "] = (Value *)" sym ";\n"]))]
                (map impl-fns .decl)
                type-num
                (apply merge-with + (map impl-fns .refs-map)))))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic_")
        reified-ptr (global-var "reifiedPtr_")]
    (c-code reified-ptr
            []
            [(map impl-fns .decl)
             "ReifiedVal " reified-sym " = {"
             type-num ", -1, (Value *)0, 0, {}};\n"
             "Value *" reified-ptr " = (Value *)&" reified-sym ";\n"]
            type-num {})))

(defprotocol ArityType
  (closure-arity? [_] nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name]))

(deftype StaticArity [arity-fn-var param-count return-type var-info]
  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " "
                (target-type-name return-type) " ")
          (string-list var-info)))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (for [_ (new-proto-impl fn-name param-count dispatch-type-num var-info arity-ast)
          _ (new-static-arity (.c-var var-info) param-count arity-fn-var (.type-num var-info))]
      var-info)))

(deftype ClosureArity [arity-fn-var param-count var-info]
  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))
  (reify-arity [_ dispatch-type-num arity-ast fn-name]
    (let [args (map (range param-count) (partial str "arg"))
          arg-decls (to-str (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                             (str "List *closures"))
                                       ", "))
          args (to-str (interpose (conj args "closures") ", "))
          fn-arity-sym (gensym "protoFnArity_")
          impl-fn-sym (gensym "protoImpl_")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (new-proto-impl fn-name param-count dispatch-type-num
                              (c-code (str "&" fn-arity-sym) [] [] FunctionType {}) arity-ast)
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {\n"
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)arg0)->impls["
                                  reify-fn-index "];\n"
                                  "incRef(arg0, 1);\n"
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");\n"
                                  "dec_and_free(arg0, 1);\n"
                                  "return(rval);\n"
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};\n"]
                                 UnknownType {})]
          (comp reified-fn var-info))))))

(defn emit-reified-fn [reified-type-num [fn-name arity-ast]]
  (for [_ (comp (get-protocol-dispatcher fn-name (count (.params arity-ast)))
                (compilation-error "Invalid protocol fn:"
                                   (str "'" fn-name "' in")
                                   (str (ast/file-name fn-name) ",")
                                   (ast/line-number fn-name)))
        arity-info (comp (emit (assoc arity-ast .param-types [reified-type-num]))
                         (compilation-error "Could not compile protocol fn:"
                                            (str "'" fn-name "' in")
                                            (str (ast/file-name fn-name) ",")
                                            (ast/line-number fn-name)))
        reified (reify-arity arity-info reified-type-num arity-ast fn-name)]
    reified))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            _ (traverse (keys (.impls ast)) sm/state-maybe
                        (fn [protocol-name]
                          (comp (get-protocol protocol-name)
                                (compilation-error "Invalid protocol:" protocol-name "in"
                                                   (str (ast/file-name fn-name) ",")
                                                   (ast/line-number protocol-name)))))
            impl-fns (traverse (for [impl-fns (vals (.impls ast))
                                     [fn-name arities] (seq impl-fns)
                                     impl-arity arities]
                                 [fn-name impl-arity])
                               sm/state-maybe
                               (partial emit-reified-fn reified-type-num))
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns)
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-code (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                     (.c-var value) ";\n"]
                                     (.decl value) (.type-num value) (.refs-map value))))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] (.type-num value) {}))]
      [value])))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [and-result (genlocal "andRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce
                            evalled-clauses [[] total-refs]
                            (fn [[init remaining-refs] clause]
                              (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                  (partial < 0)))
                                    remaining-refs (reduce
                                                    clause-refs
                                                    remaining-refs
                                                    (fn [remaining-refs [k v]]
                                                      (extract
                                                       (or (update-in remaining-refs [k]
                                                                      (fn [remaining]
                                                                        (- remaining v)))
                                                           (maybe remaining-refs)))))]
                                [(conj (vec init)
                                       ["// and clause\n"
                                        (.init clause)
                                        and-result " = " (.c-var clause) ";\n"
                                        "if (isNothing(" and-result ")) {\n"
                                        (map (seq (filter-vals remaining-refs (partial < 0)))
                                             (fn [[c-sym remaining]]
                                               ["dec_and_free(" c-sym ", "
                                                remaining ");\n"]))
                                        "} "])
                                 remaining-refs])))]
        (c-init and-result
                ["Value *" and-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" and-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                MaybeType total-refs)))))


(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (for [or-result (genlocal "orRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce evalled-clauses [[] total-refs]
                                   (fn [[init remaining-refs] clause]
                                     (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                         (partial < 0)))
                                           remaining-refs (reduce
                                                           clause-refs
                                                           remaining-refs
                                                           (fn [remaining-refs [k v]]
                                                             (extract
                                                              (or
                                                               (update-in remaining-refs [k]
                                                                          (fn [remaining]
                                                                            (- remaining v)))
                                                               (maybe remaining-refs)))))]
                                       [(conj init
                                              ["// or clause\n"
                                               (.init clause)
                                               or-result " = " (.c-var clause) ";\n"
                                               "if (!isNothing(" or-result ")) {\n"
                                               (map (seq (filter-vals remaining-refs
                                                                      (partial < 0)))
                                                    (fn [[c-sym remaining]]
                                                      ["dec_and_free(" c-sym ", "
                                                       remaining ");\n"]))
                                               "} "])
                                        remaining-refs])))]
        (c-init or-result
                ["Value *" or-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" or-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                MaybeType total-refs)))))


(extend-type ast/assert-ast
  Emitter
  (emit [ast]
    (sm/state-maybe empty-c-code)))


(extend-type ast/returns-ast
  Emitter
  (emit [ast]
    (sm/state-maybe empty-c-code)))

(defn emit-closures []
  (comp (for [closures (sm/get-in-val [.fn-context .closed-over .closures])
              :when-not (empty? closures)
              :let [closures (comp (reverse closures) [["closuresTail" ""]])]
              destructArgs (genlocal "destArgs_")]
          (cons (c-code ""
                        [(map closures (fn [[arg]] ["Value *" arg ";\n"]))
                         "incRef((Value *)closures, 1);\n"
                         "Value **" destructArgs "[" (count closures) "] = {"
                         (interpose (map closures (fn [[arg]] ["&" arg])) ", ") "};\n"
                         "destructValue(\"\", \"\", (Value *)closures"
                         ", " (count closures) ", " destructArgs ");\n"]
                        []
                        UnknownType {})
                (map closures (fn [[arg]] (c-init arg [] [] UnknownType {})))))
        (sm/state-maybe [])))

(defn closures-init [closures arity-sym]
  (for [_ (sm/when-not (empty? closures))
        closure-vars (traverse closures sm/state-maybe (fn [[_ sym]] (lookup-sym sym)))]
    (map closure-vars
         (fn [closure]
           (c-code arity-sym
                   [arity-sym "->closures = listCons((Value *)"
                    (.c-var closure) ", (List *)" arity-sym "->closures);\n"]
                   []
                   ListType
                   {(.c-var closure) 1})))))

(defprotocol ProducesCode
  (produces-code [ast] (maybe ast)))

(extend-type ast/assert-ast
  ProducesCode
  (produces-code [ast] nothing))

(extend-type ast/returns-ast
  ProducesCode
  (produces-code [ast] nothing))

(extend-type ast/block-comment-ast
  ProducesCode
  (produces-code [ast] nothing))

(defprotocol SetType
  (set-type [sym type-num]
    sm-space))

(extend-type rdr/tagged-symbol
  SetType
  (set-type [sym type-num]
    (comp (for [sym-info (sm/get-in-val [.fn-context .syms sym])
                _ (sm/assoc-in-val [.fn-context .syms sym .type-num] type-num)]
            "")
          sm-space)))

(defn emit-fn-arity [params param-types body]
  (let [arity-index ((.variadic params) 'variadic (count params))]
    (for [_ (sm/when (some body produces-code))
          fn-context (reset-fn-context)
          arity-fn-var (global-var "arityImpl")
          param-vars (comp (for [tail (sm/when (.variadic params))
                                 fixed-vars (map (traverse (.fixed params) sm/state-maybe bind) vec)
                                 tail-var (bind tail)
                                 _ (sm/assoc-in-val [.fn-context .syms tail .type-num] ListType)
                                 param-var (genlocal "arg")
                                 destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                                           (ast/file-name params)
                                                           (ast/line-number params))]
                             destruct)
                           (for [vars (traverse (.fixed params) sm/state-maybe bind)
                                 :when-not (empty? vars)
                                 :let [inline-body? (some body (partial instance? ast/inline-ast))
                                       param-vars (apply comp vars)]
                                 param-destruct (sm/when (or (and inline-body? (maybe []))
                                                             (maybe (comp (map (.vars param-vars)
                                                                               (fn [var]
                                                                                 (c-init var [] []
                                                                                         UnknownType
                                                                                         {})))
                                                                          (.destruct param-vars)))))]
                             (ParamBinding (.vars param-vars) param-destruct))
                           (sm/state-maybe (ParamBinding [] [])))
          _ (traverse (zip-lists (seq (.fixed params)) (seq param-types)) sm/state-maybe
                      (fn [[var type-num]] (set-type var type-num)))
          body-exprs (emit body)
          destruct-closures (emit-closures)
          :let [exprs (comp (.destruct param-vars)
                            destruct-closures
                            body-exprs)
                body (collapse-expressions exprs)]
          closures (sm/get-in-val [.fn-context .closed-over .closures])
          _ (reset-fn-context fn-context)
          :let [param-decls (seq (map (.vars param-vars) (fn [param]
                                                           (str "Value *" param))))
                fn-expr (c-code "" []
                                ["Value *" arity-fn-var "("
                                 (interpose (cons "List *closures" param-decls) ", ")
                                 ") {\n"]
                                FnArityType {})
                fn-result (extract (or (and (= "" (.c-var body))
                                            (maybe "nothing"))
                                       (maybe (.c-var body))))
                arg-count (count (.vars param-vars))]
          arity-info (comp (for [arity-var (genlocal "dynArity")
                                 closed-over (closures-init closures arity-var)
                                 closure-vars (traverse closures sm/state-maybe
                                                        (fn [[_ sym]]
                                                          (lookup-sym sym)))]
                             (ClosureArity arity-fn-var arity-index
                                           (comp* (c-init arity-var
                                                          ["FnArity *" arity-var
                                                           " = malloc_fnArity();\n"
                                                           arity-var "->count = " arg-count ";\n"
                                                           arity-var "->variadic = "
                                                           ((.variadic params) "1" "0") ";\n"
                                                           arity-var "->fn = " arity-fn-var ";\n"
                                                           arity-var "->closures = empty_list;\n"]
                                                          [(.decl body)
                                                           (.decl fn-expr)
                                                           (.init fn-expr)
                                                           (.init body)
                                                           "\nreturn(" fn-result ");\n};\n"]
                                                          FnArityType {})
                                                  closed-over)))
                           (for [arity-var (global-var "staticArity")]
                             (StaticArity arity-fn-var arity-index (.type-num body)
                                          (c-code (str "&" arity-var)
                                                  []
                                                  [(.decl body)
                                                   (.decl fn-expr)
                                                   (.init fn-expr)
                                                   (.init body)
                                                   "\nreturn(" fn-result ");\n};\n\n"
                                                   "FnArity " arity-var " = {FnArityType, -1, "
                                                   arg-count
                                                   ", (List *)0, " ((.variadic params) "1" "0")
                                                   ", " arity-fn-var "};\n"]
                                                  FnArityType {}))))]
      arity-info)))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug 'main-fn)
          fn-arity (emit-fn-arity (.params ast) [ListType] (.body ast))
          ;; _ (debug "=======")
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [num-args (count (.params prototype))]
    (for [arity-fn-var (global-var "protoDisp")
          impls-sym (global-var "protoImpls")
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var UnknownType)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-fn-arity (.params prototype) [] default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.var-info static-arity) default-body)]
            (.decl (.var-info static-arity)))

          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (global-var "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] FunctionType {}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities sm/state-maybe
                                   (partial declare-proto-dispatch-arity
                                            fn-name dispatch-fn-sym))
        default-fns (traverse arities sm/state-maybe
                              (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (apply merge-with comp
                               (map (.prototypes ast)
                                    (fn [prototype]
                                      {(.fn-name prototype) [prototype]})))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map) sm/state-maybe
                        (partial create-dispatcher proto-name))]
        [(c-code "" [] decl UnknownType {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (.params ast) (.param-types ast) (.body ast))))


(defn static-fn [fn-sym fn-var arities]
  (for [struct-var (global-var "fnStruct")
        emitted-arities (traverse arities sm/state-maybe
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.arity-fn-var static-arity)
                                                              (.return-type static-arity))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              FunctionType {}))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var "fnStruct")]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-code fn-var
              [(map emitted-arities .init)
               "\n// creating " fn-sym "\n"
               "Function *" struct-var " = malloc_function(" arity-count ");\n"
               struct-var "->name = \"" fn-sym "\";\n"
               struct-var "->arityCount = " arity-count ";\n"
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";\n")))
               "Value *" fn-var " = (Value *)" struct-var ";\n "]
              [(map emitted-arities .decl)]
              FunctionType
              (apply merge-with + (map emitted-arities .refs-map))))))

(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug 'fn-sym fn-sym)
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var "fn"))
                _ (new-module-def fn-sym (c-code fn-var [] [] FunctionType {}))
                arities (emit (.arities ast))
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                arities (emit (.arities ast))
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] FunctionType {}))]
      [(make-c-code value)])))


(defn extend-type* [ast type-num]
  (for [_ (traverse (keys (.impls ast)) sm/state-maybe
                    (fn [protocol-name]
                      (comp (get-protocol protocol-name)
                            (compilation-error "Invalid protocol:" protocol-name "in"
                                               (str (ast/file-name fn-name) ",")
                                               (ast/line-number protocol-name)))))
        ext-fns (traverse (for [impl-fns (vals (.impls ast))
                                [fn-name arities] (seq impl-fns)
                                impl-arity arities]
                            [fn-name impl-arity])
                          sm/state-maybe
                          (fn [[fn-name arity-ast]]
                            (let [num-args (count (.params arity-ast))]
                              (for [_ (comp (get-protocol-dispatcher fn-name num-args)
                                            (compilation-error "Invalid protocol fn:"
                                                               (str "'" fn-name "' in")
                                                               (str (ast/file-name fn-name) ",")
                                                               (ast/line-number fn-name)))
                                    ;; TODO: pre-declare all the impl fn arities
                                    ext-fn (comp (emit (assoc arity-ast .param-types [type-num]))
                                                 (compilation-error "Could not compile protocol fn:"
                                                                    (str "'" fn-name "' in")
                                                                    (str (ast/file-name fn-name) ",")
                                                                    (ast/line-number fn-name)))
                                    _ (new-static-arity (.c-var (.var-info ext-fn))
                                                        (.param-count ext-fn)
                                                        (.arity-fn-var ext-fn)
                                                        (.return-type ext-fn))

                                    _ (new-proto-impl fn-name num-args type-num
                                                      (.var-info ext-fn) arity-ast)]
                                (.var-info ext-fn)))))]
    ext-fns))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (sm/when (or (and (= type-sym 'HashMap)
                                              (maybe (list BitmapIndexedType
                                                           ArrayNodeType
                                                           HashCollisionNodeType)))
                                         (and (= type-sym 'String)
                                              (maybe (list StringType
                                                           SubStringType)))))
                  fns (map (traverse type-nums sm/state-maybe (partial extend-type* ast))
                           flatten)]
              fns)
            (for [type-num (comp (for [ns-path (comp (for [ns-sym (sm/when (.ns (.type ast)))
                                                                ns-path (sm/get-in-val
                                                                         [.namespaces ns-sym])]
                                                            ns-path)
                                                          (sm/state-maybe (ast/file-name ast)))
                                            type-num (sm/get-in-val [.modules ns-path
                                                                     .types type-sym])]
                                        type-num)
                                      (sm/get-in-val [.modules 'core .types type-sym])
                                      (compilation-error "Trying to extend unknown type: "
                                                         type-sym "at"
                                                         (str (.file-name (.type ast)) ":")
                                                         (ast/line-number (.type ast))))
                  fn (extend-type* ast type-num)]
              fn)))))


(defn declare-getters [new-type-name fields]
  (traverse fields sm/state-maybe
            (fn [field]
              (let [getter-sym (symbol (str "." field))]
                (comp (map (sm/get-in-val [.modules "" .proto-fns getter-sym]) (fn [_] []))
                      (for [dispatch-fn-var (global-var "dispatchFnPtr")
                            arity-fn-var1 (global-var "protoImpl")
                            impls-sym1 (global-var "protoImpls")
                            arity-fn-var2 (global-var "protoImpl")
                            impls-sym2 (global-var "protoImpls")
                            ;; TODO: change to 'core
                            _ (new-module-def getter-sym (c-code dispatch-fn-var [] [] FunctionType {}))
                            _ (sm/assoc-in-val [.modules "" .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules "" .proto-fns getter-sym]
                                               (ProtoFnInfo getter-sym dispatch-fn-var {}))
                            _ (sm/assoc-in-val [.modules "" .proto-fns getter-sym .dispatchers 1]
                                               (ProtocolDispatcher 1 arity-fn-var1 impls-sym1 {}))
                            _ (sm/assoc-in-val [.modules "" .proto-fns getter-sym .dispatchers 2]
                                               (ProtocolDispatcher 2 arity-fn-var2 impls-sym2 {}))
                            _ (new-static-arity dispatch-fn-var 1 arity-fn-var1 UnknownType)
                            _ (new-static-arity dispatch-fn-var 2 arity-fn-var2 UnknownType)]
                        ["ProtoImpls " impls-sym1 ";\n"
                         "ProtoImpls " impls-sym2 ";\n"
                         "Value *" dispatch-fn-var ";\n"
                         "Value *" arity-fn-var1
                         "(List *closures, Value *arg);\n"
                         "Value *" arity-fn-var2
                         "(List *closures, Value *arg1, Value *arg2);\n"]))))))

(defn constructor-expr [new-type-name type-val-sym fields]
  (ast/definition new-type-name
    [(ast/reified (extract rdr/type-counter)
                  {'Type
                   [['type-name
                     [(ast/fn-arity (ast/params ['_] nothing) ""
                                    [(str "*" new-type-name " constructor*")])]]
                    ['instance?
                     [(ast/fn-arity (ast/params ['x 'y] nothing) ""
                                    [(ast/call-ast '=*
                                                   [(ast/call-ast 'get-type [type-val-sym])
                                                    (ast/call-ast 'get-type ['y])])])]]]

                   'Function
                   [['invoke
                     [(ast/fn-arity (ast/params (vec (cons '_ (seq fields))) nothing) ""
                                    [(ast/call-ast 'new-type-value
                                                   [type-val-sym (ast/call-ast 'vector (seq fields))])])]]]

                   'Stringable
                   [['string-list
                     [(ast/fn-arity (ast/params ['_] nothing) ""
                                    [(ast/call-ast 'list
                                                   ["<TypeCon " (str new-type-name) " ["
                                                    (to-str (interpose fields ", ")) "]>"])])]]]})]))

(defn type-val-expr [type-name type-val-sym fields impls]
  (let [x* (symbol "#x")
        y* (symbol "#y")
        field* (symbol "#field")]
    (ast/definition type-val-sym
      [(ast/reified (extract rdr/type-counter)
                    (merge-with comp
                                {'Type
                                 [['type-name
                                   [(ast/fn-arity (ast/params [x*] nothing) ""
                                                  [(str type-name)])]]
                                  ['has-field
                                   [(ast/fn-arity (ast/params [x* field*] nothing) ""
                                                  [(ast/or-ast
                                                    (map fields (fn [field]
                                                                  (ast/call-ast
                                                                   'identical [(symbol (str "." field))
                                                                               field*]))))])]]]

                                 'Eq
                                 [['=*
                                   [(ast/fn-arity (ast/params [x* y*] nothing) ""
                                                  [(ast/and-ast (list (ast/call-ast
                                                                       '=* [(ast/call-ast 'get-type [x*])
                                                                            (ast/call-ast 'get-type [y*])])
                                                                      (ast/call-ast
                                                                       '=* [(ast/call-ast 'type-args [x*])
                                                                            (ast/call-ast 'type-args [y*])])))])]]]

                                 'Associative
                                 [['get
                                   [(ast/fn-arity (ast/params [x* field*] nothing) ""
                                                  [(ast/and-ast
                                                     (list
                                                      (ast/call-ast 'has-field [x* field*])
                                                      (ast/call-ast 'maybe [(ast/call-ast field* (list x*))])))])]]

                                  ['assoc
                                   ;; TODO: check if 'field' is actually a field of type value
                                   [(ast/fn-arity
                                     (ast/params [x* field* 'new-value] nothing) ""
                                     [(ast/call-ast
                                       'extract
                                       [(ast/or-ast
                                         (list (ast/and-ast
                                                (list
                                                 (ast/call-ast 'has-field [x* field*])
                                                 (ast/call-ast
                                                  'maybe
                                                  [(ast/call-ast field* (list x* 'new-value))])))
                                               (ast/call-ast 'maybe [x*])))])])]]]}
                                impls))])))

(defn create-getters [fields]
  (let [type-value (symbol "#value")
        new-value (symbol "#new-value")]
    {'Type
     (map fields (fn [field]
                   [(symbol (str "." field))
                    [(ast/fn-arity (ast/params [type-value new-value] nothing) ""
                                   [(ast/let-ast [(ast/binding (ast/params fields nothing)
                                                    (ast/call-ast 'type-args [type-value]))
                                                  (ast/binding field new-value)]
                                                 [(ast/call-ast 'make-value
                                                                [type-value (ast/call-ast 'vector fields)])])])
                     (ast/fn-arity (ast/params [type-value] nothing) ""
                                   [(ast/let-ast [(ast/binding (ast/params fields nothing)
                                                    (ast/call-ast 'type-args [type-value]))]
                                                 [field])])]]))}))

(defn add-fields-destruct [arity fields]
  (let [[type-value-parameter] (.fixed (.params arity))]
    (assoc arity .body
           [(ast/let-ast [(ast/binding fields (ast/call-ast 'type-args [type-value-parameter]))]
                          (.body arity))])))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))
          impls (merge-with comp
                            (create-getters fields)
                            (map-vals (.impls ast)
                                      (fn [impl-arities]
                                        (map impl-arities
                                             (fn [[fn-name impls]]
                                               [fn-name (map impls (fn [impl]
                                                                     (add-fields-destruct impl
                                                                                          (.fields ast))))])))))]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            file-name ", " (ast/line-number ast)))]
              "")

            (for [type-val-sym (global-var "#type-val-")
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition (constructor-expr sym type-val-sym fields))
                  const-type-num (sm/get-in-val [.modules file-name .values sym .type-num])

                  type-val-def (emit-definition (type-val-expr sym type-val-sym fields impls))
                  type-num (sm/get-in-val [.modules file-name .values type-val-sym .type-num])
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)]
              (comp type-val-decl
                    [(c-code "" [] getters UnknownType {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext 'C
                                   (FunctionArityContext 0 {} {} empty-closures)
                                   (FunctionArityContext 0 {} {} empty-closures)
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {})
                                   0                        ;; reify-fn-index
                                   ))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_] []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    [(.c-var c-info) "->refs = 1;\n"
     "freeGlobal(" (.c-var c-info) ");\n"]))

(defn emit-main [vals]
  (for [main-fn (lookup-static-arity 'main 1)]
    [(c-code "" []
             ["\nint main (int argc, char **argv) {\n"
              "outstream = stdout;\n"
              "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
              "futuresQueue.output = empty_list;\n"
              "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
              "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
              "pthread_mutex_init(&shutDown.access, NULL);\n"
              "startWorkers();\n"
              (map vals .init) "\n"
              "Value *the_final_answer = " (.c-var main-fn) "((List *)empty_list, (Value *)empty_list);\n\n"
              "#ifdef CHECK_MEM_LEAK\n"
              (map vals free-global)
              "mainThreadDone = 1;\n"
              "waitForWorkers();\n"
              "dec_and_free(the_final_answer, 1);\n"
              "freeAll();\n"
              "if (malloc_count - free_count != 0)\n"
              "   return(1);\n"
              "#endif\n"
              "  return(0);\n};\n"]
             0 {})]))

(defprotocol SymFileInfo
  (symbol-file-info [_]))

(extend-type rdr/tagged-symbol
  SymFileInfo
  (symbol-file-info [sym]
    (sm/state-maybe [(ast/file-name sym) (ast/line-number sym)])))

(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity
                    (str "&" arity-sym) num-args UnknownType
                    (c-code (str "&" arity-sym)
                            []
                            ["\n// " fn-name " " num-args " args\n"
                             "ProtoImpls " impls-sym " = {"
                             (count impls) ", {"
                             (rest (flat-map (vals impls)
                                             ;; [type arity-sym fn-sym]
                                             (fn [type-impl]
                                               [", " "{" (.dispatch-type type-impl)
                                                ", (Value *)" (.c-var type-impl)
                                                "}"])))
                             "}};\n"
                             "Value *" (.dispatch-sym proto-disp) "("
                             (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                              "List *closures")
                                        ", ")
                             ") {\n"
                             "  return(proto" num-args "Arg(&" impls-sym ", \""
                             fn-name "\", " (interpose
                                             (comp args
                                                   [(str "\"" (ast/file-name fn-name) "\"")
                                                    (ast/line-number fn-name)])
                                             ", ")
                             "));\n}\n"
                             "FnArity " arity-sym " = {FnArityType, -1, "
                             num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                            FnArityType {}))]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn)) sm/state-maybe
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              UnknownType {}))))

(defn finalize-protocols []
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              sm/state-maybe
                              emit-proto-fn)]
    dispatchers))

(defn get-proto-dispatch-sym [fn-name num-args]
  ;; TODO: change to 'core
  (sm/get-in-val [.modules "" .proto-fns fn-name .dispatchers num-args .dispatch-sym]))

(defn fixup-native-symbols []
  (apply-to (fn [& decl]
              (c-code "" [] decl UnknownType {}))
            (map (get-proto-dispatch-sym 'type-name 1)
                 (fn [arity-sym]
                   ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'invoke 1)
                 (fn [arity-sym]
                   ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'invoke 2)
                 (fn [arity-sym]
                   ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'invoke 3)
                 (fn [arity-sym]
                   ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym '=* 2)
                 (fn [arity-sym]
                   ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'hash-seq 2)
                 (fn [arity-sym]
                   ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'count 1)
                 (fn [arity-sym]
                   ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'sha1 1)
                 (fn [arity-sym]
                   ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'assoc* 5)
                 (fn [arity-sym]
                   ["Value *(*assoc)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'dissoc* 4)
                 (fn [arity-sym]
                   ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'get* 5)
                 (fn [arity-sym]
                   ["Value *(*get)(List *, Value*, Value*, Value*, Value*, Value*) = "
                    arity-sym ";\n"]))

            (map (lookup-core-fn-arity 'fn-apply 2)
                 (fn [arity-sym]
                   ["Value *(*fn_apply)(List *, Value*, Value*) = "
                    (.c-var arity-sym) ";\n"]))
            ))

(main [params]
      (let [[_ file-name] params]
        (println)
        (for [core-file (fio/file-in "core.toc")
              core-asts (analyze-forms (cache core-file))
              in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (comp (for [_ (new-module "")
                                          emitted-core (traverse core-asts sm/state-maybe
                                                                 emit-definition)
                                          emitted (traverse asts sm/state-maybe
                                                            emit-definition)
                                          main-fn (emit-main (flatten emitted))
                                          dispatchers (finalize-protocols)
                                          fixups (fixup-native-symbols)]
                                      (flatten (comp emitted-core emitted [main-fn]
                                                     [dispatchers] [[fixups]])))
                                    (compilation-error "Could not compile"))]
              [emitted-exprs] (emit-code global-context)]
          (let [_ (write-str "\n#include \"core.h\"\n")]
            (map emitted-exprs
                 (fn [emitted]
                   (write-str (.decl emitted))))))))
