
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def UnknownType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, 1};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, 2};"))
(def SubStringType (inline-C Number "(Value *)&(Number){NumberType, -1, 5};"))
(def FnArityType (inline-C Number "(Value *)&(Number){NumberType, -1, 3};"))
(def FunctionType (inline-C Number "(Value *)&(Number){NumberType, -1, 4};"))
(def ListType (inline-C Number "(Value *)&(Number){NumberType, -1, 6};"))
(def MaybeType (inline-C Number "(Value *)&(Number){NumberType, -1, 7};"))
(def VectorType (inline-C Number "(Value *)&(Number){NumberType, -1, 8};"))
(def VectorNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 9};"))

(def core-types {'Integer IntegerType
                 'String StringType
                 'SubString SubStringType
                 'FnArity FnArityType
                 'Function FunctionType
                 'List ListType
                 'Maybe MaybeType
                 'Vector VectorType
                 })

(def BitmapIndexedType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def ArrayNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def HashCollisionNodeType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))

(def sm-space (sm/state-maybe ""))
(def sm-gensym (sm/lift gensym))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang fn-context init-fn-context modules numbers
                        strings fns namespaces]
  ;; target-lang            language to compile to
  ;; fn-context             context for the fn currently being compiled
  ;; init-fn-context        context for the initialization code
  ;; modules                info for each module compiled
  ;; numbers                static numbers
  ;; strings                static strings
  ;; fns                    static functions
  ;; namespaces             current namespace map
)

;; information that must be tracked for each module
(deftype Module [path values protocols proto-fns types]
  ;; path             path to file containing the modules source code
  ;; values           map of value symbols to defined values
  ;; protocols        set of protocol symbols
  ;; proto-fns        map of protocol fn symbols to fn information
  ;; types            map of type symbols to type definitions
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

(deftype Closures [closures refs-map])
(def empty-closures (Closures empty-list {}))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [sym-count syms context closed-over]
  ;; var-count     number of C variables already used in this fn
  ;; syms          the symbols local to the function that are currently interned
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn reset-fn-context
  ([]
   (for [curr-fn-context (sm/get-val .fn-context)
         :let [new-context (comp (.context curr-fn-context) (.syms curr-fn-context))]
         _ (sm/set-val .fn-context (FunctionArityContext 0 {} new-context empty-closures))]
     curr-fn-context))
  ([new-fn-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-fn-context)]
     curr-fn-context)))

(defn new-module [path]
  ;; If a module for `path` has not been defined yet, initialize it
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {} {} {} core-types))))

;; combine a sequence of expressions, adding reference increments and decrements
;; where needed
(defprotocol CollapseExprs
  (collapse-expressions* [x y]))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; type-num: the Toccata type of the value produced
;; refs-map: map of C variables that are used in 'init' and how many times
(deftype empty-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Composition
  (zero [c] c)
  (comp* [_ cs]
    (apply comp cs))

  CollapseExprs
  (collapse-expressions* [x y] y))

(def empty-c-code (empty-code "" [] [] UnknownType {}))

(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (str type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c collapse-expressions*))

  CollapseExprs
  (collapse-expressions* [x y]
    (c-code (.c-var y)
            (conj (.init x) (.init y))
            (conj (.decl x) (.decl y))
            (.type-num y)
            (merge-with + (.refs-map x) (.refs-map y)))))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", " (str type-num) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ">"))

  Composition
  (zero [_] empty-c-code)
  (comp* [c cs]
    (reduce cs c (fn [result c]
                   (c-code (.c-var c)
                           (conj (.init result) (.init c))
                           (conj (.decl result) (.decl c))
                           (.type-num c)
                           (merge-with + (.refs-map result) (.refs-map c))))))

  CollapseExprs
  (collapse-expressions* [x y]
    (let [init (extract (or (for [refs (get-in y [.refs-map c-var])]
                              [(.init x)
                               ((< refs 2) "" ["\nincRef(" c-var ", " (dec refs) ");\n"])
                               (.init y)])
                            (maybe [(.init x)
                                    "\ndec_and_free(" c-var ", 1);\n"
                                    (.init y)])))
          refs-map (merge-with + (.refs-map x) (.refs-map y))
          refs-map (assoc refs-map c-var 0)]
      (c-code (.c-var y)
              init
              (conj (.decl x) (.decl y))
              (.type-num y)
              refs-map))))

(defn collapse-expressions [cs]
  (extract (or (and (empty? cs) (maybe empty-c-code))
               (maybe (let [[c & cs] (reverse cs)]
                        (reduce cs c (fn [y x] (collapse-expressions* x y))))))))

(defn new-protocol [proto-sym]
  ;; Initialize a new protocol definition in a module if it does not already exist.
  ;; Ensure all protocol symbols are unique
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
              _ (compilation-error "Duplicate protocol" (str "'" proto-sym "'") "at"
                                   (str (ast/file-name proto-sym) ":")
                                   (ast/line-number proto-sym))]
          "")
        (sm/assoc-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym]
                         proto-sym)))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using the current file name
  ;; 3. using `'core` for protcols defined in the core
  (comp (for [ns-sym (sm/when (.ns proto-sym))
              protocol-path (sm/get-in-val [.namespaces ns-sym])
              result (sm/get-in-val [.modules protocol-path .protocols proto-sym])]
          result)
        (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])
        (sm/get-in-val [.modules 'core .protocols proto-sym])))

(deftype ProtoFnInfo [fn-sym disp-sym dispatchers]
  Stringable
  (string-list [_] (list "<ProtoFnInfo " fn-sym ">")))

(defn new-protocol-fn [fn-sym disp-sym]
  (comp (for [_ (sm/get-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym])]
          (print-err "Duplicate protocol function" (str "'" fn-sym "'") "at"
                     (str (ast/file-name fn-sym) ":") (ast/line-number fn-sym)))
        (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym]
                         (ProtoFnInfo fn-sym disp-sym {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (map (sm/get-in-val [.modules path .proto-fns fn-sym])
       (fn [_] path)))

(defprotocol FindProtoPath
  (find-protocol-path [fn-sym]
    (comp (for [sym-ns (sm/when (.ns fn-sym))
                namespace (sm/get-in-val [.namespaces sym-ns])
                path (lookup-protocol-path fn-sym namespace)]
            path)
          (lookup-protocol-path fn-sym (ast/file-name fn-sym))
          (lookup-protocol-path fn-sym 'core))))

(deftype ProtocolDispatcher [arg-count dispatch-sym impls-sym type-impls]
  Stringable
  (string-list [_] (list "<ProtoDispatcher " (str arg-count) ">")))

(defn new-proto-dispatcher [fn-sym arg-count dispatch-sym impls-sym]
  (sm/assoc-in-val [.modules (ast/file-name fn-sym) .proto-fns fn-sym .dispatchers arg-count]
                   (ProtocolDispatcher arg-count dispatch-sym impls-sym {})))

(defn get-protocol-dispatcher [fn-sym num-args]
  (for [protocol-path (find-protocol-path fn-sym)
        result (sm/get-in-val [.modules protocol-path .proto-fns fn-sym
                               .dispatchers num-args])]
    result))

(deftype ProtoImpl [dispatch-type c-var ast]
  Stringable
  (string-list [_] (list "<ProtoImpl " (str dispatch-type) ">")))

(defn new-proto-impl [fn-name arg-count dispatch-type c-code ast]
  (for [protocol-path (find-protocol-path fn-name)
        _ (sm/assoc-in-val [.modules protocol-path .proto-fns fn-name
                            .dispatchers arg-count .type-impls dispatch-type]
                           (ProtoImpl dispatch-type (.c-var c-code) ast))]
    ""))

(defn get-proto-impl [fn-name arg-count type-num]
  (for [protocol-path (find-protocol-path fn-name)
        impl-info (sm/get-in-val [.modules protocol-path .proto-fns fn-name
                                  .dispatchers arg-count .type-impls type-num])]
    impl-info))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))


(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_])

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym])

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(defn genlocal [pre]
  (for [sym-count (sm/get-in-val [.fn-context .sym-count])
        _ (sm/assoc-in-val [.fn-context .sym-count] (inc sym-count))]
    (symbol (str pre sym-count))))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (ast/file-name sym) .values sym]))

(defn new-module-def [sym value]
  (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value))

(defn already-closed-over [sym]
  (for [closed-over (sm/get-in-val [.fn-context .closed-over .closures])
        closure-var (sm/when (some closed-over (fn [[closure-var sym-literal]]
                                                 (for [_ (= sym sym-literal)]
                                                   closure-var))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map sym] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map sym] 1)]
    closure-var))

(defn closed-over-sym [sym]
  (for [;; it's supposed to fail if 'sym' is not in the context
        c-sym (sm/get-in-val [.fn-context .context sym])

        ;; if 'sym' is in the context, it should be in .closed-over
        closure-var (comp (already-closed-over sym)
                          (new-closure sym))]
    (c-code closure-var [] [] (.type-num c-sym) {closure-var 1})))

(defn lookup-sym [sym]
  (comp (sm/get-in-val [.fn-context .syms sym])
        (closed-over-sym sym)
        (lookup-module-def sym)
        (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                           (str (ast/file-name sym) ":")
                           (ast/line-number sym))))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn new-static-arity [fn-var num-params arity-var type-num]
  (sm/assoc-in-val [.fns fn-var num-params]
                   (c-code arity-var [] [] type-num {})))

(defn lookup-core-fn-arity [sym num-args]
  (for [fn-sym (sm/get-in-val [.modules "" .values (rdr/tag sym "" 0)])
        arity-sym (lookup-static-arity (.c-var fn-sym) num-args)]
    arity-sym))


(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))

  (emit-defined-value [_ _] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe [])))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-val .strings) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.strings str-val] (c-code str-ptr [] [] StringType {}))]
      (c-init str-ptr
              []
              ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] StringType {}))]
      [(assoc value .c-var "")])))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-val .numbers) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Number
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] IntegerType {}))]
      [(assoc value .c-var "")])))


(extend-type rdr/tagged-symbol
  Emitter
  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (new-module-def defined-sym value)]
      [(assoc value .c-var "")])))


(defn get-type [type-symbol]
  (sm/state-maybe 0))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (lookup-module-def defined-sym)
                      (global-var "var"))
          _ (new-module-def defined-sym (c-code c-var [] [] type-num {}))]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [] [(.txt ast)] type-num {}))))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-init result-sym
                               ["\n// call-vector\n// #line " (str (ast/line-number target))
                                " " "\""
                                (ast/file-name target) "\"\n"
                                "Vector *" vect-sym " = empty_vect;\n"
                                (map args
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [vect-sym " = mutateVectConj(" vect-sym ", "
                                          arg-sym ");\n"])))
                                "Value *" result-sym " = (Value *)" vect-sym ";\n"]
                               [] VectorType {})]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-init result-sym
                                ["\n// call-list\n// #line "
                                 (str (ast/line-number target)) " " "\""
                                 (ast/file-name target) "\"\n"
                                 "List *" list-sym " = empty_list;\n"
                                 (map (reverse args)
                                      (fn [arg]
                                        (let [arg-sym (.c-var arg)]
                                          [list-sym " = listCons(" "(Value *)" arg-sym
                                           ", " list-sym ");\n"])))
                                 "Value *" result-sym " = (Value *)" list-sym ";\n"]
                                [] ListType {})]))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        result-sym (genlocal "rslt")]
    (c-init result-sym
            ["\n// static-fixed\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq arg-vars)) ", ") ");\n"]
            [] (.type-num arity-info) {})))

(defn call-static-variadic [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) 'variadic)
        variadic-sym (genlocal "varArgs")
        result-sym (genlocal "rslt")]
    (c-init result-sym
            ["\n// static-variadic\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "List *" variadic-sym " = empty_list;\n"
             (map (reverse arg-vars)
                  (fn [arg-sym]
                    (str variadic-sym " = (List *)listCons("
                         "(Value *)" arg-sym
                         ", " variadic-sym ");\n")))
             "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
             variadic-sym ");\n"]
            []
            (.type-num arity-info)
            {})))

(defn call-dyn-fn-value [target args file-name line-number]
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (.type-num target))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";\n"
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");\n"
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;\n"
               "\n// #line " line-number " " "\"" file-name "\"\n"
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");\n"
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;\n"
               "List *" variadic-sym " = empty_list;\n"
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");\n")))
               "\n// dynamic fn type\n// #line " line-number " " "\"" file-name "\"\n"
               result-sym " = " fn-var "(" (car arg-syms) ", (Value *)"
               variadic-sym ");\n"
               "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" file-name "\", " line-number
               ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);\n"]
              []
              UnknownType {}))))

(defn call-dyn-unknown-type [target args file-name line-number]
  (let [num-args (count args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (map (lookup-core-fn-arity 'invoke (inc num-args)) .c-var)]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                ["\n// dynamic unknown type"
                 "\n// #line " (str line-number) " " "\""
                 file-name "\"\n"
                 "Value *" result-sym ";\n"
                 "if((" (.c-var target) ")->type != FunctionType) {\n"

                 result-sym " = " invoke-arity-sym "(empty_list, "
                 (to-str (interpose (conj args (.c-var target)) ", "))
                 ");\n} else {\n"

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");\n"
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {\n"
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;\n"
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");\n"
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {\n"
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;\n"
                 "List *" variadic-sym " = empty_list;\n"
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");\n")))
                 result-sym " = " fn-sym "(" (car arg-syms) ", (Value *)" variadic-sym ");\n"
                 "} else {\nfprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");\n  abort();\n}\n"
                 "dec_and_free("(.c-var target) ", 1);\n}\n"]
                [] UnknownType {})))))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [args (emit (.args ast))
            call-site (comp (call-vector (.call-target ast) args)
                            (call-list (.call-target ast) args)
                            (for [target (emit (.call-target ast))
                                  :let [arg-vars (map args .c-var)]
                                  call-site (comp (call-static-fixed target arg-vars
                                                                     file-name line-number)
                                                  (call-static-variadic target arg-vars
                                                                        file-name line-number)
                                                  (call-dyn-fn-value target arg-vars
                                                                     file-name line-number)
                                                  (call-dyn-unknown-type target arg-vars
                                                                         file-name line-number))]
                              (comp* target (comp args [call-site])))
                            (compilation-error "Could not compile call site at:"
                                               file-name line-number))]
        (let [call-site (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                                (.type-num call-site) (.refs-map call-site))]
          call-site))))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (global-var "var")
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(deftype ParamBinding [vars destruct]
  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (cons x xs)]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn unpack-arg-list [list-sym elem-vars file-name line-num]
  (comp (sm/when (for [elem (first elem-vars)
                       :when (= 1 (count elem-vars))
                       var (first (.vars elem))]
                   (ParamBinding [list-sym]
                                 [(c-init var ["Value *" var " = (Value *)" list-sym ";\n"]
                                          [] UnknownType {})])))
        (for [destructArgs (genlocal "destArgs")]
          (let [elem-c-vars (flat-map elem-vars .vars)
                elem-count (count elem-vars)]
            (ParamBinding [list-sym]
                          (comp [(c-code ""
                                         [(map elem-c-vars (fn [var] ["Value *" var ";\n"]))
                                          "Value **" destructArgs "[" elem-count "] = {"
                                          (interpose (map elem-c-vars (fn [arg] ["&" arg])) ", ")
                                          "};\n" "destructValue(\"" file-name "\", \"" line-num
                                          "\", (Value *)" list-sym ", " elem-count ", "
                                          destructArgs ");\n"]
                                         [] UnknownType {list-sym 1})]
                                (map elem-c-vars (fn [var] (c-init var [] [] UnknownType {})))
                                (flat-map elem-vars .destruct)))))))

(defprotocol Bindings
  (bind [binding]
    (for [arg-var (genlocal "arg")
          :let [arg (c-code arg-var [] [] UnknownType {arg-var 1})]
          _ (sm/assoc-in-val [.fn-context .syms binding] arg)]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (let [evalled-ref (c-code (.c-var evalled) [] [] (.type-num evalled) {(.c-var evalled) 1})]
      (for [_ (sm/assoc-in-val [.fn-context .syms binding] evalled-ref)]
        (ParamBinding [(.c-var evalled)] [evalled (c-init (.c-var evalled) [] []
                                                          (.type-num evalled) {})]))))
  
  (gen-binding-vars [param]
    ;; generate bindings for symbols and tagged-symbols
    (bind param)))


(extend-type ast/params-ast
  Bindings
  (bind [params]
    (comp (flat-map (sm/when (.variadic params))
                    (fn [_]
                      (gen-binding-vars params)))
          (for [fixed-vars (map (traverse (.fixed params) sm/state-maybe bind) vec)
                tail-var (bind (symbol ".tail"))
                param-var (genlocal "arg")
                destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                          (ast/file-name params)
                                          (ast/line-number params))]
            destruct)))

  (bind [params evalled]
    (for [tail (sm/when (or (.variadic params)
                            (maybe (symbol ".tail"))))
          fixed-vars (map (traverse (.fixed params) sm/state-maybe bind) vec)
          tail-var (bind tail)
          destruct (unpack-arg-list (.c-var evalled) (conj fixed-vars tail-var)
                                    (ast/file-name params) (ast/line-number params))
          destruct (sm/when (or (and (empty? (.init evalled))
                                     (empty? (.decl evalled))
                                     (maybe destruct))
                                (maybe (assoc destruct .destruct
                                              (comp [evalled] (.destruct destruct))))))]
      (let [destruct (assoc destruct .vars [(.c-var evalled)])]
        destruct))))

(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals (sm/get-in-val [.fn-context .syms])
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          _ (sm/assoc-in-val [.fn-context .syms] locals)]
      (let [code (collapse-expressions (comp (flatten (map bindings .destruct)) body-exprs))]
        (c-init (.c-var code) (.init code) (.decl code) (.type-num code) (.refs-map code)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (global-var "var")
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] (.type-num value) {}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [and-result (genlocal "andRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce
                            evalled-clauses [[] total-refs]
                            (fn [[init remaining-refs] clause]
                              (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                  (partial < 0)))
                                    remaining-refs (reduce
                                                    clause-refs
                                                    remaining-refs
                                                    (fn [remaining-refs [k v]]
                                                      (extract
                                                       (or (update-in remaining-refs [k]
                                                                      (fn [remaining]
                                                                        (- remaining v)))
                                                           (maybe remaining-refs)))))]
                                [(conj (vec init)
                                       ["// and clause\n"
                                        (.init clause)
                                        and-result " = " (.c-var clause) ";\n"
                                        "if (isNothing(" and-result ")) {\n"
                                        (map (seq (filter-vals remaining-refs (partial < 0)))
                                             (fn [[c-sym remaining]]
                                               ["dec_and_free(" c-sym ", "
                                                remaining ");\n"]))
                                        "} "])
                                 remaining-refs])))]
        (c-init and-result
                ["Value *" and-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" and-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                Maybe total-refs)))))


(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (for [or-result (genlocal "orRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce evalled-clauses [[] total-refs]
                                   (fn [[init remaining-refs] clause]
                                     (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                         (partial < 0)))
                                           remaining-refs (reduce
                                                           clause-refs
                                                           remaining-refs
                                                           (fn [remaining-refs [k v]]
                                                             (extract
                                                              (or
                                                               (update-in remaining-refs [k]
                                                                          (fn [remaining]
                                                                            (- remaining v)))
                                                               (maybe remaining-refs)))))]
                                       [(conj init
                                              ["// or clause\n"
                                               (.init clause)
                                               or-result " = " (.c-var clause) ";\n"
                                               "if (!isNothing(" or-result ")) {\n"
                                               (map (seq (filter-vals remaining-refs
                                                                      (partial < 0)))
                                                    (fn [[c-sym remaining]]
                                                      ["dec_and_free(" c-sym ", "
                                                       remaining ");\n"]))
                                               "} "])
                                        remaining-refs])))]
        (c-init or-result
                ["Value *" or-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" or-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                Maybe total-refs)))))


(extend-type ast/assert-ast
  Emitter
  (emit [ast]
    (sm/state-maybe empty-c-code)))


(extend-type ast/returns-ast
  Emitter
  (emit [ast]
    (sm/state-maybe empty-c-code)))

(defprotocol ArityType
  (closure-arity? [_] nothing))

(deftype StaticArity [arity-fn-var param-count var-info]
  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info))))

(deftype ClosureArity [arity-fn-var param-count var-info]
  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity)))

(defn emit-closures []
  (comp (for [closures (sm/get-in-val [.fn-context .closed-over .closures])
              :when-not (empty? closures)
              :let [closures (comp (reverse closures) [["closuresTail" ""]])]
              destructArgs (genlocal "destArgs_")]
          (cons (c-code ""
                        [(map closures (fn [[arg]] ["Value *" arg ";\n"]))
                         "incRef((Value *)closures, 1);\n"
                         "Value **" destructArgs "[" (count closures) "] = {"
                         (interpose (map closures (fn [[arg]] ["&" arg])) ", ") "};\n"
                         "destructValue(\"\", \"\", (Value *)closures"
                         ", " (count closures) ", " destructArgs ");\n"]
                        []
                        UnknownType {})
                (map closures (fn [[arg]] (c-init arg [] [] UnknownType {})))))
        (sm/state-maybe [])))

(defn closures-init [closures arity-sym]
  (for [_ (sm/when-not (empty? closures))
        closure-vars (traverse closures sm/state-maybe (fn [[_ sym]] (lookup-sym sym)))]
    (reduce (reverse closure-vars) empty-list
            (fn [closed-over sym]
              [arity-sym "->closures = listCons((Value *)"
               (.c-var sym) ", (List *)" arity-sym "->closures);\n"
               closed-over]))))

(defprotocol ProducesCode
  (produces-code [ast] (maybe ast)))

(extend-type ast/assert-ast
  ProducesCode
  (produces-code [ast] nothing))

(extend-type ast/returns-ast
  ProducesCode
  (produces-code [ast] nothing))

(extend-type ast/block-comment-ast
  ProducesCode
  (produces-code [ast] nothing))

(defn emit-fn-arity [params body]
  (let [arity-index ((.variadic params) 'variadic (count params))]
    (for [_ (sm/when (some body produces-code))
          fn-context (reset-fn-context)
          arity-fn-var (global-var "arityImpl")
          param-vars (comp (for [tail (sm/when (.variadic params))
                                 fixed-vars (map (traverse (.fixed params) sm/state-maybe bind) vec)
                                 tail-var (bind tail)
                                 param-var (genlocal "arg")
                                 destruct (unpack-arg-list param-var (conj fixed-vars tail-var)
                                                           (ast/file-name params)
                                                           (ast/line-number params))]
                             destruct)
                           (for [vars (traverse (.fixed params) sm/state-maybe bind)
                                 :when-not (empty? vars)
                                 :let [inline-body? (some body (partial instance? ast/inline-ast))
                                       param-vars (apply comp vars)]
                                 param-destruct (sm/when (or (and inline-body? (maybe []))
                                                             (maybe (comp (map (.vars param-vars)
                                                                               (fn [var]
                                                                                 (c-init var [] []
                                                                                         UnknownType
                                                                                         {})))
                                                                          (.destruct param-vars)))))]
                             (ParamBinding (.vars param-vars) param-destruct))
                           (sm/state-maybe (ParamBinding [] [])))
          body-exprs (emit body)
          destruct-closures (emit-closures)
          :let [body (collapse-expressions (comp (.destruct param-vars)
                                                 destruct-closures
                                                 body-exprs))]
          closures (sm/get-in-val [.fn-context .closed-over .closures])
          _ (reset-fn-context fn-context)
          :let [param-decls (seq (map (.vars param-vars) (fn [param]
                                                           (str "Value *" param))))
                fn-expr (c-code "" []
                                ["Value *" arity-fn-var "("
                                 (interpose (cons "List *closures" param-decls) ", ")
                                 ") {\n"]
                                FnArityType {})
                fn-result (extract (or (and (= "" (.c-var body))
                                            (maybe "nothing"))
                                       (maybe (.c-var body))))
                arg-count (count (.vars param-vars))]
          arity-info (comp (for [arity-var (genlocal "dynArity")
                                 closed-over (closures-init closures arity-var)
                                 closure-vars (traverse closures sm/state-maybe (fn [[_ sym]]
                                                                                  (lookup-sym sym)))]
                             (let [refs (reduce closure-vars empty-list
                                                (fn [refs var]
                                                  (cons {(.c-var var) 1} refs)))
                                   refs (apply merge-with + refs)]
                               (ClosureArity arity-fn-var arity-index
                                             (c-init arity-var
                                                     ["FnArity *" arity-var " = malloc_fnArity();\n"
                                                      arity-var "->count = " arg-count ";\n"
                                                      arity-var "->variadic = "
                                                      ((.variadic params) "1" "0") ";\n"
                                                      arity-var "->fn = " arity-fn-var ";\n"
                                                      arity-var "->closures = empty_list;\n"
                                                      closed-over]
                                                     [(.decl body)
                                                      (.decl fn-expr)
                                                      (.init fn-expr)
                                                      (.init body)
                                                      "\nreturn(" fn-result ");\n};\n"]
                                                     FnArityType refs))))
                           (for [arity-var (global-var "staticArity")]
                             (StaticArity arity-fn-var arity-index
                                          (c-code (str "&" arity-var)
                                                  []
                                                  [(.decl body)
                                                   (.decl fn-expr)
                                                   (.init fn-expr)
                                                   (.init body)
                                                   "\nreturn(" fn-result ");\n};\n\n"
                                                   "FnArity " arity-var " = {FnArityType, -1, "
                                                   arg-count
                                                   ", (List *)0, " ((.variadic params) "1" "0")
                                                   ", " arity-fn-var "};\n"]
                                                  FnArityType {}))))]
      arity-info)))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [fn-arity (emit-fn-arity (.params ast) (.body ast))
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(defn declare-proto-dispatch-arity [fn-name dispatch-fn-var prototype]
  (let [num-args (count (.params prototype))]
    (for [arity-fn-var (sm-gensym "protoDisp")
          impls-sym (sm-gensym "protoImpls")
          _ (new-proto-dispatcher fn-name num-args arity-fn-var impls-sym)
          _ (new-static-arity dispatch-fn-var num-args arity-fn-var UnknownType)]
      ["ProtoImpls " impls-sym ";\n"
       "Value *" arity-fn-var "("
       (interpose (conj (map (range num-args)
                             (fn [n]
                               (str "Value *arg" n)))
                        "List *closures")
                  ", ")
       ");\n"])))

(defn emit-proto-default [protocol-name fn-name prototype]
  (let [default-body (.default-body prototype)]
    (comp (for [_ (sm/when-not (empty? default-body))
                static-arity (emit-fn-arity (.params prototype) default-body)
                _ (new-proto-impl fn-name (count (.params prototype)) 0
                                  (.var-info static-arity) default-body)]
            (.decl (.var-info static-arity)))

          sm-space)))

(defn create-dispatcher [proto-name [fn-name arities]]
  (for [dispatch-fn-sym (sm-gensym "dispatchFnPtr")
        _ (sm/assoc-in-val [.modules (ast/file-name fn-name) .values fn-name]
                           (c-code dispatch-fn-sym [] [] FunctionType {}))
        _ (new-protocol-fn fn-name dispatch-fn-sym)
        dispatch-arities (traverse arities sm/state-maybe
                                   (partial declare-proto-dispatch-arity
                                            fn-name dispatch-fn-sym))
        default-fns (traverse arities sm/state-maybe
                              (partial emit-proto-default proto-name fn-name))]
    ["\n// proto fn for " proto-name "/" fn-name "\n"
     "Value *" dispatch-fn-sym ";\n"
     dispatch-arities
     default-fns]))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (apply merge-with comp
                               (map (.prototypes ast)
                                    (fn [prototype]
                                      {(.fn-name prototype) [prototype]})))]
      (for [_ (new-protocol proto-name)
            decl (traverse (seq prototype-map) sm/state-maybe
                        (partial create-dispatcher proto-name))]
        [(c-code "" [] decl UnknownType {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (.params ast) (.body ast))))


(defn static-fn [fn-sym arities]
  (for [struct-var (global-var "fnStruct")
        fn-var (comp (map (lookup-sym fn-sym) .c-var)
                     (global-var "fn"))
        emitted-arities (traverse arities sm/state-maybe
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.arity-fn-var static-arity)
                                                              (.type-num (.var-info static-arity)))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              FunctionType {}))))

(defn closure-fn [fn-sym arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var "fnStruct")
        fn-var (comp (map (lookup-sym fn-sym) .c-var)
                     (global-var "fn"))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)
          arity-refs (reduce (flat-map (map emitted-arities .refs-map) keys) {}
                             (fn [m k]
                               (extract (or (update-in m [k] inc)
                                            (maybe (assoc m k 1))))))]
      (c-code fn-var
              [(map emitted-arities .init)
               "\n// creating " fn-sym "\n"
               "Function *" struct-var " = malloc_function(" arity-count ");\n"
               struct-var "->name = \"" fn-sym "\";\n"
               struct-var "->arityCount = " arity-count ";\n"
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";\n")))
               "Value *" fn-var " = (Value *)" struct-var ";\n "]
              [(map emitted-arities .decl)]
              FunctionType arity-refs))))

(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (for [fn-sym (sm/when (or (.fn-sym ast)
                              (maybe 'anon)))
          ;; _ (debug 'fn-sym fn-sym)
          fn-var (global-var "fn")
          _ (new-module-def fn-sym (c-code fn-var [] [] FunctionType {}))
          arities (emit (.arities ast))
          ;; _ (debug "------")
          fn-expr (comp (closure-fn fn-sym arities)
                        (static-fn fn-sym arities))]
      fn-expr))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] FunctionType {}))]
      [(assoc value .c-var "")])))


(defn extend-type* [ast type-num]
  (for [_ (traverse (keys (.impls ast)) sm/state-maybe
                    (fn [protocol-name]
                      (comp (get-protocol protocol-name)
                            (compilation-error "Invalid protocol:" protocol-name "in"
                                               (str (ast/file-name fn-name) ",")
                                               (ast/line-number protocol-name)))))
        ext-fns (traverse (for [impl-fns (vals (.impls ast))
                                [fn-name arities] (seq impl-fns)
                                impl-arity arities]
                            [fn-name impl-arity])
                          sm/state-maybe
                          (fn [[fn-name arity-ast]]
                            (let [num-args (count (.params arity-ast))]
                              (for [_ (comp (get-protocol-dispatcher fn-name num-args)
                                            (compilation-error "Invalid protocol fn:"
                                                               (str "'" fn-name "' in")
                                                               (str (ast/file-name fn-name)
                                                                    ",")
                                                               (ast/line-number fn-name)))
                                    ext-fn (comp (emit (assoc arity-ast .param-types [type-num]))
                                                 (compilation-error "Could not compile protocol fn:"
                                                                    (str "'" fn-name "' in")
                                                                    (str (ast/file-name fn-name) ",")
                                                                    (ast/line-number fn-name)))
                                    _ (new-proto-impl fn-name num-args type-num
                                                      (.var-info ext-fn) arity-ast)]
                                (.var-info ext-fn)))))]
    ext-fns))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [type-nums (sm/when (or (and (= type-sym 'HashMap)
                                              (maybe (list BitmapIndexedType
                                                           ArrayNodeType
                                                           HashCollisionNodeType)))
                                         (and (= type-sym 'String)
                                              (maybe (list StringType
                                                           SubStringType)))))
                  fns (map (traverse type-nums sm/state-maybe (partial extend-type* ast))
                           flatten)]
              fns)
            (for [type-num (comp (for [ns-path (comp (for [ns-sym (sm/when (.ns (.type ast)))
                                                                ns-path (sm/get-in-val
                                                                         [.namespaces ns-sym])]
                                                            ns-path)
                                                          (sm/state-maybe (ast/file-name ast))) 
                                            type-num (sm/get-in-val [.modules ns-path
                                                                     .types type-sym])]
                                        type-num)
                                      (sm/get-in-val [.modules 'core .types type-sym])
                                      (compilation-error "Trying to extend unknown type: "
                                                         type-sym "at"
                                                         (str (.file-name (.type ast)) ":")
                                                         (ast/line-number (.type ast))))
                  fn (extend-type* ast type-num)]
              fn)))))

(def global-context (GlobalContext 'C
                                   (FunctionArityContext 0 {} {} empty-closures)
                                   (FunctionArityContext 0 {} {} empty-closures)
                                   {}                       ;; map for module info
                                   {}                       ;; map for const numbers
                                   {}                       ;; map for const strings
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   ))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defn emit-main [vals]
  (for [main-fn (lookup-static-arity 'main 1)]
    [(c-code "" []
             ["\nint main (int argc, char **argv) {\n"
              "outstream = stdout;\n"
              (map vals .init) "\n"
              "Value *the_final_answer = " (.c-var main-fn) "((List *)empty_list, (Value *)empty_list);\n\n"
              "#ifdef CHECK_MEM_LEAK\n"
              (map vals (fn [val]
                          [(.c-var val) "->refs = 1;\n"
                           "freeGlobal(" (.c-var val) ");\n"]))
              "  dec_and_free(the_final_answer, 1);\n"
              "  freeAll();\n"
              "  if (malloc_count - free_count != 0)\n"
              "     return(1);\n"
              "#endif\n"
              "    return(0);\n};\n"]
             0 {})]))

(defprotocol SymFileInfo
  (symbol-file-info [_]))

(extend-type rdr/tagged-symbol
  SymFileInfo
  (symbol-file-info [sym]
    (sm/state-maybe [(ast/file-name sym) (ast/line-number sym)])))

(defn emit-proto-dispatcher [fn-name proto-disp]
  (let [num-args (.arg-count proto-disp)
        args (map (range num-args) (partial str "arg"))
        impls-sym (.impls-sym proto-disp)
        impls (.type-impls proto-disp)
        arity-sym (gensym "protoFnArity")
        dispatcher (StaticArity
                    (str "&" arity-sym) num-args
                    (c-code (str "&" arity-sym)
                            []
                            ["\n// " fn-name " " num-args " args\n"
                             "ProtoImpls " impls-sym " = {"
                             (count impls) ", {"
                             (rest (flat-map (vals impls)
                                             ;; [type arity-sym fn-sym]
                                             (fn [type-impl]
                                               [", " "{" (.dispatch-type type-impl)
                                                ", (Value *)" (.c-var type-impl)
                                                "}"])))
                             "}};\n"
                             "Value *" (.dispatch-sym proto-disp) "("
                             (interpose (conj (map args (fn [arg] (str "Value *" arg)))
                                              "List *closures")
                                        ", ")
                             ") {\n"
                             "  return(proto" num-args "Arg(&" impls-sym ", \""
                             fn-name "\", " (interpose
                                             (comp args
                                                   [(str "\"" (ast/file-name fn-name) "\"")
                                                    (ast/line-number fn-name)])
                                             ", ")
                             "));\n}\n"
                             "FnArity " arity-sym " = {FnArityType, -1, "
                             num-args ", (List *)0, 0, " (.dispatch-sym proto-disp) "};\n"]
                            FnArityType {}))]
    (sm/state-maybe dispatcher)))

(defn emit-proto-fn [proto-fn]
  (let [fn-sym (gensym "protoFn")]
    (for [arities (traverse (vals (.dispatchers proto-fn)) sm/state-maybe
                            (partial emit-proto-dispatcher (.fn-sym proto-fn)))]
      (c-code "" []
              [(map arities (fn [arity] (.decl (.var-info arity))))
               "Function " fn-sym " = {FunctionType, -1, \""
               (.fn-sym proto-fn) "\", " (count arities) ", {"
               (interpose (map arities .arity-fn-var) ", ")
               "}};\n" "Value *" (.disp-sym proto-fn) " = (Value *)&" fn-sym ";\n\n"]
              UnknownType {}))))

(defn finalize-protocols []
  (for [modules (map (sm/get-val .modules) vals)
        dispatchers (traverse (for [module modules
                                    proto-fn (vals (.proto-fns module))]
                                proto-fn)
                              sm/state-maybe
                              emit-proto-fn)]
    dispatchers))

(defn get-proto-dispatch-sym [fn-name num-args]
  (sm/get-in-val [.modules "" .proto-fns (rdr/tag fn-name "" 0)
                  .dispatchers num-args .dispatch-sym]))

(defn fixup-native-symbols []
  (apply-to (fn [& decl]
              (c-code "" [] decl UnknownType {}))
            (map (get-proto-dispatch-sym 'type-name 1)
                 (fn [arity-sym]
                   ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'invoke 1)
                 (fn [arity-sym]
                   ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'invoke 2)
                 (fn [arity-sym]
                   ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym 'invoke 3)
                 (fn [arity-sym]
                   ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

            (map (get-proto-dispatch-sym '=* 2)
                 (fn [arity-sym]
                   ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))
            ))

(main [params]
      (let [[_ file-name] params]
        (println)
        (for [core-file (fio/file-in "core.toc")
              core-asts (analyze-forms (cache core-file))
              in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (comp (for [_ (new-module "")
                                          emitted-core (traverse core-asts sm/state-maybe
                                                                 emit-definition)
                                          emitted (traverse asts sm/state-maybe
                                                            emit-definition)
                                          main-fn (emit-main (remove (flatten emitted)
                                                                     (fn [val]
                                                                       (= "" (.c-var val)))))
                                          dispatchers (finalize-protocols)
                                          fixups (fixup-native-symbols)]
                                      (flatten (comp emitted-core emitted [main-fn]
                                                     [dispatchers] [[fixups]])))
                                    (compilation-error "Could not compile"))]
              [emitted-exprs] (emit-code global-context)]
          (let [_ (write-str "\n#include \"core.h\"\n")]
            (map emitted-exprs
                 (fn [emitted]
                   (write-str (.decl emitted))))))))
