
(add-ns rdr (git-dependency "https://github.com/Toccata-Lang/reader.git"
                            "reader.toc"
                            :sha "4893cbf"))
(add-ns rd (git-dependency "https://github.com/Toccata-Lang/recursive-descent.git"
                           "recursive-descent.toc"
                           :sha "c89ab00"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "7690cd3"))
(add-ns sys (git-dependency "https://github.com/Toccata-Lang/system.git"
                            "system.toc"
                            :sha "40c1c4d"))
(add-ns sm (git-dependency "https://github.com/Toccata-Lang/state-maybe.git"
                           "state-maybe.toc"
                           :sha "ecde30b"))
(add-ns fio (git-dependency "https://github.com/Toccata-Lang/file-io.git"
                            "file-io.toc"
                            :sha "e7a489b"))
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "ba18227"))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(def string-writer (agent ""))
(defn write-strings [strs]
  (send string-writer (fn [_]
                        (write-str strs))))

(def Tagged (comp ast/SymbolOrString
                  rdr/tagged-symbol))

(def path-to-core (extract (or (map (sys/get-environment "TOCCATA_DIR")
                                    (fn [toc-dir]
                                      (str toc-dir "/core.toc")))
                               (do
                                 (print-err "Could not read environnment variable"
                                            "TOCCATA_DIR")
                                 (abort)))))

(def line-sep "\n")

(defn line-macro [ast marker]
  (let [file-name (ast/file-name ast)]
    (sm/state-maybe (either (= "" file-name)
                            ["\n" marker "\n// #line "
                             (str (ast/line-number ast)) " " "\""
                             (either (and (= 'core file-name)
                                          (maybe path-to-core))
                                     file-name)
                             "\"\n"]))))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -1, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -1, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FunctionType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, MaybeType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))
(def BitmapIndexedType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ArrayNodeType};"))
(def HashCollisionNodeType
  (inline C Integer "(Value *)&(Integer){IntegerType, -1, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -1, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -1, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -1, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -1, OpaqueType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -1, TypeCount};"))

(def type-names {IntegerType "Integer"
                 StringBufferType "String"
                 SubStringType "String"
                 FnArityType "FnArity"
                 FunctionType "Function"
                 ListType "List"
                 MaybeType "Maybe"
                 VectorType "Vector"
                 VectorNodeType "VectorNode"
                 SymbolType "Symbol"
                 BitmapIndexedType "BitmapIndexNode"
                 ArrayNodeType "ArrayNode"
                 HashCollisionNodeType "HashCollisionNode"
                 PromiseType "Promise"
                 FutureType "Future"
                 AgentType "Agent"
                 OpaqueType "Opaque"
                 UnknownType "UnknownType"})

(defn target-type-name [n]
  (either (get type-names n)
          (str n)))

(def core-type-nums {'Integer IntegerType
                     'StringBuffer StringBufferType
                     'SubString SubStringType
                     'FnArity FnArityType
                     'Function FunctionType
                     'List ListType
                     'Maybe MaybeType
                     'Vector VectorType
                     'Symbol SymbolType
                     'BitmapIndexedNode BitmapIndexedType
                     'ArrayNode ArrayNodeType
                     'HashCollisionNode HashCollisionNodeType
                     'Promise PromiseType
                     'Future FutureType
                     'Agent AgentType
                     'Opaque OpaqueType
                     'TypeCount TypeCount})

(deftype TypeInfo [sym type-map])

(def core-types {IntegerType (TypeInfo 'Integer {IntegerType #{}})
                 StringBufferType (TypeInfo 'StringBuffer {StringBufferType #{}})
                 SubStringType (TypeInfo 'SubString {SubStringType #{}})
                 FnArityType (TypeInfo 'FnArity {FnArityType #{}})
                 FunctionType (TypeInfo 'Function {FunctionType #{}})
                 ListType (TypeInfo 'List {ListType #{}})
                 MaybeType (TypeInfo 'Maybe {MaybeType #{}})
                 VectorType (TypeInfo 'Vector {VectorType #{}})
                 SymbolType (TypeInfo 'Symbol {SymbolType #{}})
                 BitmapIndexedType (TypeInfo 'BitmapIndexedNode {BitmapIndexedType #{}})
                 ArrayNodeType (TypeInfo 'ArrayNode {ArrayNodeType #{}})
                 HashCollisionNodeType (TypeInfo 'HashCollisionNode {HashCollisionNodeType #{}})
                 PromiseType (TypeInfo 'Promise {PromiseType #{}})
                 FutureType (TypeInfo 'Future {FutureType #{}})
                 AgentType (TypeInfo 'Agent {AgentType #{}})
                 OpaqueType (TypeInfo 'Opaque {OpaqueType #{}})})

(def sm-space (sm/state-maybe ""))

;; useful for debugging the compiler
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (sm/new-sm (fn [s]
               (apply print-err msg)
               (abort))))

(defn format-path* [path desired-len]
  (either (empty? path)
          (let [path (map path
                          (fn [[file line]]
                            (str file ": " line)))
                max-width (reduce path 0 (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                path (either (and (< (count path) desired-len)
                                  (maybe (comp path (repeat (- desired-len (count path))
                                                            (spaces max-width)))))
                             path)]
            (map path
                 (fn [x]
                   (str x (spaces (- max-width (count x)))))))))

(deftype StaticLengthConstraint [length path sym var])
(deftype StaticIntConstraint [val path sym var])
(deftype StaticStrConstraint [val path sym var])

(def StaticConstraints (comp StaticLengthConstraint
                             StaticStrConstraint
                             StaticIntConstraint))

(defprotocol Constraint
  (format-path [x n])

  (intersect [c1 c2])
  (restrict-types [c type-map]
    type-map)

  (extract-type-map [_]
    (assert-result r (instance? Maybe r)))

  (extract-items-constraints [_]
    (assert-result r (instance? List r))
    empty-list)

  (update-path [constraint file-name line-number]
    constraint)

  (update-sym [tc new-sym]
    (assert (instance? Tagged new-sym)))

  (update-var [tc new-var]
    (assert (instance? String new-var)))

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))
    nothing)

  (runtime-check [constraint value-info file-name line-number]
    ;; generated code must preserve ref counts
    []))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "<NoValues>"))

  Constraint
  (intersect [nv _] nv)
  (update-sym [x _] x)
  (update-var [x _] x)

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (.path c)))) n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c max-len)))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (< (count (.constraints x)) (count (.constraints y)))
                  (maybe y))
             (maybe x))))

  Composition
  (comp* [nv-type _]
    nv-type))

(def bottom-type (NoValues []))

(deftype AllValues []
  Stringable
  (string-list [_]
    (list "<AllValues>"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (intersect [_ c] c)
  (update-sym [x _] x)
  (update-var [x _] x)
  (extract-type-map [_] nothing)

  Composition
  (comp* [av-type constraints]
    (either (map (first constraints)
                 (fn [constraint]
                   (comp* constraint (rest constraints))))
            av-type)))


(def top-type (AllValues))

(deftype MultiConstraint [constraints]
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_] (list "<MultiConstraint \n" (to-str (interpose constraints "\n-- ")) ">"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (= constraints (.constraints y))
         (maybe x)))

  Collection
  (conj [mc c]
    (either (or (= bottom-type c)
                (and (some constraints (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj constraints c))))

  Constraint
  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (.path c)))) n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  (update-sym [mc sym]
    (.constraints mc (map constraints (fn [c]
                                        (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map constraints (fn [c]
                                        (update-var c var)))))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number)))))

  (intersect [mc c]
    (either (or (and (instance? MultiConstraint c)
                     (maybe (reduce (.constraints c) mc
                                    (fn [cs new-c]
                                      (either (= cs bottom-type)
                                              (intersect new-c cs))))))
                (= bottom-type (intersect c mc))
                (and (some constraints (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj constraints c)))))

(defprotocol Emitter
  ;; For AST nodes that can be embedded in other AST nodes
  (emit [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can be assigned to a symbol at the top level
  (emit-defined-value [ast defined-sym]
    (assert-result x (instance? sm/new-sm x)))

  ;; For AST nodes that can appear at the top level of a file
  (emit-definition [_]
    (assert-result x (instance? sm/new-sm x)))

  ;; Mark this AST node as the final (or tail) expression in a function body
  (tail-call [_ params result-constraint])

  ;; Does 'ast' produce any executable code when emitted?
  (produces-code? [ast]
    (assert-result x (instance? Maybe x))
    (maybe ast))

  ;; Emit a call expression if the call target is a tagged-symbol. Otherwise, fail
  (emit-call-expr [target-ast args call-expr-ast]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; replace all occurances of the keys in 'subs' with their associated values
  (replace-syms [ast subs]
    (assert-result x (instance? sm/new-sm x)))

  ;; prepend "#" to all the bound variables in the AST
  (replace-bound-vars [ast subs]
    ast)

  ;; produce a constraint from an assertion ast
  (to-constraint [ast]
    (sm/state-maybe top-type))

  ;; expand 'target-ast' so that it's component asts are inlined
  (inline-expr [target-ast arg-asts]
    (assert-result x (instance? sm/new-sm x))
    (zero sm/state-maybe))

  ;; generate a new local C var for a symbol
  (bind [binding]
    (assert-result x (instance? sm/new-sm x)))

  ;; bind the symbol 'binding' to the results of 'evalled'
  (bind [binding evalled]
    (assert-result x (instance? sm/new-sm x)))

  ;; unpack the 'list-var' and bind the items to the 'elem-vars'
  (bind-list [list-var params]
    (assert (instance? ast/params-ast params)))

  ;; get the constraints for a symbol or params-ast
  (get-param-constraints [_ constraint-map]
    (assert-result x (instance? sm/new-sm x)))

  ;; update the constraint map for symbol
  (constrain-sym [sym constraint]
    (sm/state-maybe constraint))

  (update-call-site-count [_]
    (assert-result x (instance? sm/new-sm x)))

  (call-site-meta-data [c-var file-name line-number]
    (assert-result x (instance? sm/new-sm x)))

  ;; encode a static representation of a core data structure
  (encode [m]
    (emit m))
  (encode [m var-prefix]))

(defprotocol Assertion
  (assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (return-assertion? [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (assert-type [ast]
    (assert-result x (instance? Maybe x))
    nothing)

  (assert-return-type [ast]
    (assert-result x (instance? Maybe x))
    nothing))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? HashMap type-maps))
  (assert (instance? List path))
  (assert (instance? Tagged type-sym))
  (assert (instance? Maybe sym))
  ;; (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "<TypeConstraint " (str type-sym) " " (str type-maps)
          " " (str sym) " '" (str var) "'>"))

  Eq
  (=* [x y]
    (and (instance? TypeConstraint y)
         (= type-maps (.type-maps y))
         (maybe x)))

  Constraint
  (satisfied-by [c info]
    (map (extract-type-map info)
         (fn [value-type-map]
           (subset (set (keys type-maps))
                   (set (keys value-type-map))))))

  (extract-type-map [_]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "'" type-sym "' From") ""]
                        path)
                  desired-len))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (satisfied-by constraint value-info)
                 (maybe ""))
            (let [file-name (either (and (= file-name 'core)
                                         (maybe "$TOCCATA_DIR/core.toc"))
                                    file-name)
                  sym-location (either (= "" file-name)
                                       (str " at " file-name ", line " line-number))]
              ["switch (" var "->type) {" line-sep
               (map (keys type-maps) (fn [type-num]
                                       ["case " type-num ": " line-sep]))
               "break;" line-sep " default:"
               "\n#ifndef EMBEDDED\n"
               "fprintf(stderr, \"Invalid type of value for '"
               (either sym "<unknown>") "'" sym-location "\\n\");\n"
               "fprintf(stderr, \"Needed " (str type-sym)
               ", got %s\\n\", extractStr(type_name(empty_list, " var ")));" line-sep
               "fprintf(stderr, \""
               (interpose (format-path constraint (inc (count path))) "\\n")
               "\\n\");"
               "\n#endif\n"
               "abort();" line-sep
               "}" line-sep]))))

(def fn-constraint (TypeConstraint {FunctionType #{}} empty-list 'Function nothing ""))
(def sym-constraint (TypeConstraint {SymbolType #{}} empty-list 'Symbol nothing ""))

(extend-type StaticLengthConstraint
  (assert (instance? Integer length))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Eq
  (=* [x y]
    (and (instance? StaticLengthConstraint y)
         (= (.length x) (.length y))
         (maybe x)))

  Stringable
  (string-list [c]
    (list "<StaticLengthConstraint " (str (.length c)) " " (str (.sym c)) "\n"
          (to-str (interpose (seq (.path c)) "\n")) ">"))

  Constraint
  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                        (.path x))
                  desired-len)))

(defn destruct-seq [seq-c-var elem-c-vars dest-args file-name line-num]
  (assert (instance? Tagged seq-c-var))
  (assert (instance? Tagged dest-args))

  (let [elem-count (count elem-c-vars)]
    [(map elem-c-vars (fn [var]
                        ["Value *" var ";" line-sep]))
     "Value **" dest-args "[" elem-count "] = {"
     (interpose (map elem-c-vars (fn [var] ["&" var])) ", ")
     "};" line-sep "destructValue(\"" file-name "\", \"" line-num
     "\", (Value *)" seq-c-var ", " elem-count ", "
     dest-args ");" line-sep]))

(deftype ItemsConstraint [items-constraints path sym var]
  (assert (instance? List items-constraints))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Collection
  (empty? [_]
    (every items-constraints empty?))

  Eq
  (=* [x y]
    (and (instance? ItemsConstraint y)
         (= items-constraints (.items-constraints y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<ItemsConstraint " (str items-constraints) " " (str sym) ">"))

  Constraint
  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  (extract-items-constraints [_]
    items-constraints)

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (satisfied-by constraint value-info)
                 (maybe ""))
            (let [file-name (either (and (= file-name 'core)
                                         (maybe "$TOCCATA_DIR/core.toc"))
                                    file-name)]
              (either (and (empty? items-constraints)
                           (maybe []))
                      [(-> (TypeConstraint {ListType #{} VectorType #{}} path 'Sequence sym var)
                           (runtime-check value-info file-name line-number))
                       (let [sym-location (either (= "" file-name)
                                                  (str " at " file-name ", line " line-number))
                             min-count (str (count items-constraints))]
                         ["if (countSeq(incRef(" var ", 1)) < " min-count ") {"
                          "\n#ifndef EMBEDDED\n"
                          "fprintf(stderr, \"Insufficient values" sym-location "\\n\");\n"
                          "fprintf(stderr, \"Needed " min-count
                          ", got %\" PRId64 \"\\n\", ((Integer *)count(empty_list, " var "))->numVal);" line-sep
                          "fprintf(stderr, \"From: \\n"
                          (interpose (format-path constraint (inc (count path))) "\\n")
                          "\\n\");"
                          "\n#endif\n"
                          "abort();" line-sep
                          "}\n"])
                       "if (1) {\n // TODO: I'm sure this is awful\n"
                       "incRef(" var ", 1);" line-sep
                       (let [items (map (range (inc (count items-constraints)))
                                        (partial str var "_"))]
                         [(destruct-seq var items (str var "_args") file-name line-number)
                          (for [[constraints item] (zip-lists items-constraints items)]
                            (runtime-check (update-var constraints item) value-info file-name line-number))
                          (map items (fn [item]
                                       (str "dec_and_free(" item ", 1);" line-sep)))])
                       "}" line-sep])))))

(def empty-items-constraint (ItemsConstraint empty-list empty-list nothing ""))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Tagged field))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Eq
  (=* [x y]
    (and (instance? FieldConstraint y)
         (= field (.field y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<FieldConstraint " (str field) " " (str sym)
          ;; "\n" (str (interpose path "\n"))
          ">"))

  Constraint
  (extract-type-map [_] nothing)

  (restrict-types [c type-map]
    (reduce (seq type-map) {}
            (fn [type-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc type-map type-num field-set)))
                      type-map))))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (satisfied-by constraint value-info)
                 (maybe ""))
            (let [file-name (either (and (= file-name 'core)
                                         (maybe "$TOCCATA_DIR/core.toc"))
                                    file-name)
                  sym-location (either (= "" file-name)
                                       (str " at " file-name ", line " line-number))]
              ["if(1) {\n"
               "Value *dork = hasField(empty_list, incRef(" var ", 1), " field-var ");\n"
               "if (isNothing(dork,\"\",0)) {"
               "\n#ifndef EMBEDDED\n"
               "fprintf(stderr, \"Value of type '%s' does not have field '"
               field "'" sym-location "\\n\", extractStr(type_name(empty_list, " var ")));\n" line-sep
               "fprintf(stderr, \""
               (interpose (format-path constraint (inc (count path))) "\\n")
               "\\n\");"
               "\n#endif\n"
               "abort();" line-sep
               "}\ndec_and_free(dork, 1);\n}\n"])))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len)))

(def SymbolConstraints (comp TypeConstraint
                             StaticConstraints
                             ItemsConstraint
                             FieldConstraint))

(def ValueConstraint (comp SymbolConstraints
                           MultiConstraint
                           AllValues))

(deftype ResultConstraint [assertion]
  (assert (instance? ValueConstraint assertion))

  Stringable
  (string-list [_] (list "<ResultConstraint " (str assertion) ">"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (extract-type-map [_]
    (extract-type-map assertion))

  (intersect [rc c]
    (either (and (instance? ResultConstraint c)
                 (maybe (ResultConstraint (intersect assertion (.assertion c)))))
            (ResultConstraint (intersect assertion c))))

  Eq
  (=* [x y]
    (and (or (and (instance? ResultConstraint y)
                  (=* assertion (.assertion y)))
             (=* assertion y))
         (maybe x)))

  Assertion
  (return-assertion? [ast] (maybe ast))

  Emitter
  (produces-code? [ast] nothing)

  (to-constraint [ast]
    (sm/state-maybe ast)))

(extend-type SymbolConstraints
  Emitter
  (to-constraint [ast]
    (sm/state-maybe ast))

  Constraint
  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var)))

(extend-type TypeConstraint
  Constraint
  (intersect [tc c]
    (either (or (= tc c)
                (= c bottom-type)
                (and (= c top-type) (maybe tc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) tc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c tc))))
                (and (instance? ItemsConstraint c)
                     (let [types-map (select-keys (.type-maps tc) [ListType VectorType])]
                       (and (empty? types-map)
                            (maybe (NoValues [tc c])))))
                (and (instance? FieldConstraint c)
                     (let [field (.field c)]
                       (and (empty? (filter (vals (.type-maps tc)) (fn [fields]
                                                                     (fields field))))
                            (maybe (NoValues [tc c])))))
                (and (instance? ResultConstraint c)
                     (maybe (ResultConstraint (intersect tc (.assertion c)))))
                (and (instance? TypeConstraint c)
                     (let [types-map (select-keys (.type-maps tc) (keys (.type-maps c)))]
                       (and (empty? types-map)
                            (maybe (NoValues [tc c]))))))
            (MultiConstraint [tc (update-var c (.var tc))]))))

(extend-type FieldConstraint
  Constraint
  (satisfied-by [c info]
    (let [type-map (extract-type-map info)]
      (or (flat-map type-map
                    (fn [type-map]
                      (first (seq (restrict-types c type-map)))))
          (and (= nothing type-map)
               (or (and (instance? FieldConstraint info)
                        (= (.field c) (.field info)))
                   (and (instance? MultiConstraint info)
                        (some (.constraints info)
                              (partial satisfied-by c))))))))

  (intersect [fc c]
    (either (or (= fc c)
                (= c bottom-type)
                (and (= c top-type) (maybe fc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) fc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c fc))))
                (and (instance? ItemsConstraint c)
                     (maybe (NoValues [fc c])))
                (and (instance? ResultConstraint c)
                     (maybe (ResultConstraint (intersect fc (.assertion c)))))
                (and (instance? TypeConstraint c)
                     (let [field (.field fc)]
                       (and (empty? (filter (vals (.type-maps c)) (fn [fields]
                                                                    (fields field))))
                            (maybe (NoValues [fc c]))))))
            (MultiConstraint [fc (update-var c (.var fc))]))))

(extend-type ItemsConstraint
  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (ItemsConstraint (map (.items-constraints constraint)
                            (fn [constraints]
                              (update-path constraints file-name line-number)))
                       (cons [file-name line-number] (.path constraint))
                       (.sym constraint) (.var constraint))))

  (intersect [ic c]
    (either (or (= ic c)
                (= c bottom-type)
                (and (= c top-type) (maybe ic))
                (and (instance? ResultConstraint c)
                     (maybe (ResultConstraint (intersect ic (.assertion c)))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) ic
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c ic))))
                (and (instance? TypeConstraint c)
                     (let [types-map (select-keys (.type-maps c) [ListType VectorType])]
                       (and (empty? types-map)
                            (maybe (NoValues [ic c])))))
                (and (instance? StaticLengthConstraint c)
                     (< (.length c) (count (.items-constraints ic)))
                     (maybe (NoValues [ic c])))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [ic c])))
                (and (instance? ItemsConstraint c)
                     (= bottom-type
                        (reduce (zip-lists (.items-constraints ic) (.items-constraints c))
                                top-type
                                (fn [final-c [c1 c2]]
                                  (either (= bottom-type final-c)
                                          (intersect c1 c2)))))))
            (MultiConstraint [ic (update-var c (.var ic))]))))

(extend-type StaticLengthConstraint
  Constraint
  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? ResultConstraint c)
                     (maybe (ResultConstraint (intersect slc (.assertion c)))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c])))
                (and (instance? ItemsConstraint c)
                     (< (.length slc) (count (.items-constraints c)))
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(extend-type StaticIntConstraint
  Constraint
  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? ResultConstraint c)
                     (maybe (ResultConstraint (intersect slc (.assertion c)))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(extend-type StaticStrConstraint
  Constraint
  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? ResultConstraint c)
                     (maybe (ResultConstraint (intersect slc (.assertion c)))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(def Constraints (comp AllValues
                       NoValues
                       MultiConstraint
                       SymbolConstraints
                       ResultConstraint))

(extend-type Constraints
  Composition
  (comp* [mc cs]
    (reduce cs mc intersect)))

(extend-type MultiConstraint
  Constraint
  (satisfied-by [c info]
    (let [type-map (extract-type-map c)]
      (or (flat-map type-map
                    (fn [type-map]
                      (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                    info)))
          (and (= nothing type-map)
               (every (.constraints c)
                      (fn [inner-c]
                        (satisfied-by inner-c info)))))))

  (runtime-check [constraint value-info file-name line-number]
    (either (and (or (some (.constraints constraint)
                           (partial instance? StaticConstraints))
                     (satisfied-by constraint value-info))
                 (maybe ""))
            (do
              ;; TODO: minimize the runtime checks
              (map (.constraints constraint)
                   (fn [c]
                     (runtime-check c value-info file-name line-number))))))

  (extract-type-map [mc]
    (reduce (.constraints mc) nothing
            (fn [type-map c]
              (or (map type-map (partial restrict-types c))
                  (extract-type-map c)))))

  (extract-items-constraints [mc]
    (-> (.constraints mc)
        (filter (partial instance? ItemsConstraint))
        (map .items-constraints)
        ((fn [ls]
           (let [max-len (reduce ls 0 (fn [max l]
                                        (either (> (count l) max)
                                                max)))]
             (map ls (fn [l]
                       (either (and (< (count l) max-len)
                                    (maybe (comp l (repeat (- max-len (count l))
                                                           top-type))))
                               l))))))
        (list-zipper empty-list)
        (map (fn [[c & cs]] (comp* c cs)))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number))))))


(deftype FnValPtr [var]
  ;; pointer to a Function struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ArityValPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype StaticFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(deftype ProtoDispFnPtr [var]
  ;; pointer to a FnArity struct
  (assert (instance? ast/SymbolOrString var)))

(def CFnPtr (comp StaticFnPtr
                  ProtoDispFnPtr))

(def PointerVar (comp FnValPtr
                      ArityValPtr
                      CFnPtr))

(extend-type PointerVar
  Stringable
  (string-list [x]
    (list (str (.var x))))

  Hashable
  (sha1 [x]
    (sha1 (.var x)))

  (sha1-update [x context]
    (sha1-update (.var x) context)))

(defprotocol C-Code
  (expr-constraints [expr]
    (assert-result x (instance? Constraints x)))
  (collapse-expressions* [x y]))

(defn expr-type-num [expr]
  (either (-> expr
              expr-constraints
              extract-type-map
              (flat-map (fn [type-map]
                          (let [type-nums (keys type-map)]
                            (and (= 1 (count type-nums))
                                 (first type-nums))))))
          UnknownType))

;; information about a compiled expression(s)
;; c-var: C variable that holds the value produced by the code
;; init: C code that produces the value at run time
;; decl: C code to declare anything needed
;; refs-map: map of C variables that are used in 'init' and how many times

(deftype empty-code [c-var init decl refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<Empty-C-Code>"))

  Collection
  (empty? [c]
    (maybe c))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def empty-c-code (empty-code "" [] [] {} {}))

(defn conflicting-assertions [constraints file-name line-number]
  (apply print-err "Conflicting assertions"
         (either (= "" file-name)
                 (str " at " file-name ": " line-number))
         "\n"
         (format-path (MultiConstraint constraints) 0))
  (abort))

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (comp* x (list y))]
    (and (= bottom-type z)
         (let [constraints (either (and (< 1 (count (.constraints z)))
                                        (maybe (.constraints z)))
                                   [x y])]
           (maybe (conflicting-assertions constraints file-name line-number))))
    z))

(deftype c-code [c-var init decl refs-map constraints]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c]
    (and (empty? init)
         (empty? decl)
         (empty? constraints)))

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but is the first appearance of 'c-var' in the generated code
(deftype c-init [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Init " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

;; same as 'c-code', but defines a function parameter
(deftype c-param [c-var init decl refs-map constraints file-name line-number]
  (assert (instance? Sequence init))
  (assert (instance? Sequence decl))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints))

  Stringable
  (string-list [_]
    (list "<C-Param " (str c-var) ", "
          (str (count init)) ", "(str (count decl)) ", " (str refs-map) ", "
          (str constraints) ">"))

  Collection
  (empty? [c] nothing)

  Emitter
  (emit [x]
    (sm/state-maybe x)))

(def C-expr (comp empty-code
                  c-code
                  c-param
                  c-init))

(defn add-constraint [expr constraint file-name line-number]
  (let [constraints (either (get-in expr [.constraints (.c-var expr)])
                            top-type)]
    (.constraints expr {(.c-var expr) (compose-constraints file-name line-number constraints constraint)})))

(extend-type empty-code
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (comp* y (rest xs))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))

    y))

(extend-type c-param
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (collapse-expressions* x y))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [init (either (or (for [refs (get-in y [.refs-map (.c-var x)])]
                             [(.init x)
                              (either (and (< refs 2)
                                           (maybe ""))
                                      ["incRef(" (.c-var x) ", " (dec refs) ");" line-sep])
                              (.init y)])
                           (and (= "" (.c-var x))
                                (maybe [(.init x) (.init y)])))
                       [(.init x)
                        line-sep "dec_and_free(" (.c-var x) ", 1);" line-sep
                        (.init y)])
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           (.c-var x))
          refs-map (assoc refs-map (.c-var x) 0)]
      (c-code (.c-var y)
              init [(.decl x) (.decl y)] refs-map
              (merge-with (partial compose-constraints (.file-name x) (.line-number x))
                          (.constraints x) (.constraints y))))))

(extend-type c-init
  Composition
  (comp* [x xs]
    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))
                         y (.refs-map y (merge-with + (.refs-map y) {(.c-var x) 1}))]
                     (collapse-expressions* x y))))
            x)) 

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [c-var (.c-var x)
          file-name (.file-name x)
          line-number (.line-number x)
          init [(.init x)
                (either (for [constraint (get (.constraints y) c-var)
                              value-info (or (get (.constraints x) c-var)
                                             (maybe top-type))]
                          (-> constraint
                              (update-var c-var)
                              (runtime-check value-info file-name line-number)))
                        "")
                (either (or (for [refs (get-in y [.refs-map c-var])]
                              [((< refs 2) "" ["incRef(" c-var ", " (dec refs) ");" line-sep])])
                            (= "" c-var))
                        [line-sep "dec_and_free(" c-var ", 1);" line-sep])
                (.init y)]
          refs-map (dissoc (merge-with + (.refs-map x) (.refs-map y))
                           c-var)
          constraints-map (merge-with (partial compose-constraints file-name line-number)
                                      (.constraints x) (.constraints y))]
      (-> y
          (.init init)
          (.decl [(.decl x) (.decl y)])
          (.refs-map refs-map)
          (.constraints constraints-map)))))

(extend-type c-code
  Composition
  (comp* [x xs]
    (assert-result z (instance? C-expr z))

    (either (map (first xs)
                 (fn [y]
                   (let [y (comp* y (rest xs))]
                     (-> y
                         (.init [(.init x) (.init y)])
                         (.decl [(.decl x) (.decl y)])
                         (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
                         (.constraints (merge-with comp (.constraints x) (.constraints y)))))))
            x))

  C-Code
  (collapse-expressions* [x y]
    (assert (instance? C-expr y))
    (assert-result z (instance? C-expr z))

    (let [x (either (and (empty? (.init x))
                         (maybe (.refs-map x {})))
                    x)]
      (-> y
          (.init [(.init x) (.init y)])
          (.decl [(.decl x) (.decl y)])
          (.refs-map (merge-with + (.refs-map x) (.refs-map y)))
          (.constraints (merge-with comp (.constraints x) (.constraints y)))))))

(defn collapse-expressions [cs]
  (either (or (and (empty? cs)
                   (maybe empty-c-code))
              (and (empty? (rest cs))
                   (first cs)))
          (let [[c & cs] cs]
            (collapse-expressions* c (collapse-expressions cs)))))

(deftype Closures [closures refs-map constraints]
  (assert (instance? Vector closures))
  (assert (instance? HashMap refs-map))
  (assert (instance? HashMap constraints)))

(def empty-closures (Closures [] {} {}))

(deftype ConstantValues [numbers strings symbols type-names other]
  ;; numbers                static numbers
  (assert (instance? HashMap numbers))
  ;; strings                static strings
  (assert (instance? HashMap strings))
  ;; symbols                static symbols
  (assert (instance? HashMap symbols))
  ;; type-names             map of type numbers to type names
  (assert (instance? HashMap type-names)))

;; Every function arity has some information that's local to it

(deftype FunctionArityContext [recurse sym-count syms context-syms closed-over]
  ;; recurse       info to detect recursive calls
  (assert (instance? HashMap recurse))
  ;; sym-count     number of local symbols that have been defined
  (assert (instance? Integer sym-count))
  ;; syms               the symbols local to the function that are currently interned
  (assert (instance? HashMap syms))
  ;; context-syms  the symbols in the context of the function being emitted
  (assert (instance? HashMap context-syms))
  ;; closed-over   symbols that this function closes over
  (assert (instance? Closures closed-over))

  Stringable
  (string-list [_]
    (comp (list "<FunctionArityContext ")
          (string-list syms)
          (list ">"))))

(deftype RuntimeInit [fn-context exprs]
  ;; fn-context        context for the initialization code
  (assert (instance? FunctionArityContext fn-context))
  ;; exprs             the init expressions
  (assert (instance? Vector exprs)))

;; information that must be tracked for each module
(deftype Module [path values protocols types declarations]
  ;; path             path to file containing the modules source code (Symbol or String)
  ;; values           map of value symbols to defined values
  (assert (instance? HashMap values))
  ;; protocols        set of protocol symbols
  (assert (instance? HashMap protocols))
  ;; types            map of type symbols to type definitions
  (assert (instance? HashMap types))
  ;; declarations     map of symbols to C vars that have not been defined
  (assert (instance? HashMap declarations))

  Stringable
  (string-list [_] (list "<Module '" (str path) "'>")))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [fn-context rt-init modules fns namespaces constants reify-fn-index type-maps]
  ;; fn-context             context for the fn currently being compiled
  (assert (instance? FunctionArityContext fn-context))
  ;; init                   context for the runtime initialization
  (assert (instance? RuntimeInit rt-init))
  ;; modules                info for each module compiled
  (assert (instance? HashMap modules))
  ;; fns                    static functions
  (assert (instance? HashMap fns))
  ;; namespaces             current namespace map
  (assert (instance? HashMap namespaces))
  ;; constants              the various constants encountered
  (assert (instance? ConstantValues constants))
  ;; reify-fn-index         index of reified fn being compiled
  (assert (instance? Integer reify-fn-index))

  Stringable
  (string-list [_] (list "<GlobalContext>")))

(defn reset-fn-context
  ([]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [curr-fn-context (.fn-context s)
                      new-context (comp (-> curr-fn-context .context-syms)
                                        (-> curr-fn-context .syms))]
                  (maybe [curr-fn-context
                          (.fn-context s (FunctionArityContext {} 0 {} new-context empty-closures))])))))
  ([new-fn-context]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (maybe [(.fn-context s) (.fn-context s new-fn-context)])))))

(defn extract-sym-path [s sym]
  (let [file-name (ast/file-name sym)]
    (flat-map (rdr/namespace sym)
              (fn [ns-sym]
                (or (get-in (.namespaces s) [file-name ns-sym])
                    (get-in (.namespaces s) [file-name (rdr/tag ns-sym)]))))))

(defn sym-ns-path [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (map (extract-sym-path s sym) (fn [path]
                                                   [path s]))
                   (maybe [(ast/file-name sym) s])))))

(def C-var-punct (grmr/any (grmr/apply-fn (constantly "_STAR_")
                                          (grmr/ignore "*"))
                           (grmr/apply-fn (constantly "")
                                          (grmr/ignore "."))
                           (grmr/apply-fn (constantly "_HASH_")
                                          (grmr/ignore "#"))
                           (grmr/apply-fn (constantly "_PLUS_")
                                          (grmr/ignore "+"))
                           (grmr/apply-fn (constantly "_QM_")
                                          (grmr/ignore "?"))
                           (grmr/apply-fn (constantly "_BANG_")
                                          (grmr/ignore "!"))
                           (grmr/apply-fn (constantly "_EQ_")
                                          (grmr/ignore "="))
                           (grmr/apply-fn (constantly "_LT_")
                                          (grmr/ignore "<"))
                           (grmr/apply-fn (constantly "_GT_")
                                          (grmr/ignore ">"))))

(def C-var-remaining
  (grmr/none-or-more (grmr/any "_"
                               (grmr/apply-fn (constantly "_")
                                              (grmr/ignore "-"))
                               grmr/alpha
                               grmr/digit
                               C-var-punct)))

(def C-var (grmr/apply-fn (fn [start remaining]
                            (apply str start (seq remaining)))
                          (grmr/any grmr/alpha
                                    (map (grmr/ignore "#") (fn [] ""))
                                    (map (grmr/ignore "-") (fn [] "_MINUS_"))
                                    C-var-punct)
                          C-var-remaining))

(def check-C-var (rd/parser C-var))

(defn genlocal
  ([pre]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str pre sym-count) new-ctxt])))))
  ([sym arg-name]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (let [ctxt (.fn-context s)
                      sym-count (.sym-count ctxt)
                      new-ctxt (.fn-context s (.sym-count ctxt (inc sym-count)))]
                  (maybe [(str (either (check-C-var (str sym "_"))
                                       arg-name)
                               sym-count)
                          new-ctxt]))))))

(deftype ParamBinding [vars destruct]
  (assert (instance? Vector vars))
  (assert (instance? Vector destruct))

  Stringable
  (string-list [_]
    (comp (list "<ParamBinding ")
          (string-list vars)
          (list " ")
          (string-list destruct)
          (list ">")))

  Composition
  (comp* [x xs]
    (let [xs (vec (cons x xs))]
      (ParamBinding (flat-map xs .vars) (flat-map xs .destruct)))))


(defn traverse [asts f]
  (assert-result x (instance? sm/new-sm x))

  ;; TODO: use a vector instead
  (reduce (reverse asts) (sm/state-maybe empty-list)
            (fn [l ast]
              (flat-map (f ast)
                        (fn [emitted]
                          (map l (fn [x]
                                   (cons emitted x))))))))

;; generate symbols that are available globally inside the 'state-maybe' container
(defn global-var
  ([arg-name] (sm/state-maybe (gensym (str "g_" arg-name))))
  ([sym arg-name]
   (sm/state-maybe (gensym (str "g_" (either (check-C-var (str sym "_"))
                                             arg-name))))))


(deftype ProtoImpl [dispatch-type c-var ast param-constraints result-constraints]
  (assert (instance? ArityValPtr c-var))
  (assert (instance? Integer dispatch-type))
  (assert (instance? ItemsConstraint param-constraints))
  (assert (instance? ResultConstraint result-constraints))

  Stringable
  (string-list [_] (list "<ProtoImpl type: " (target-type-name dispatch-type) " " (str c-var) ">"))

  Emitter
  (encode [_]
    (sm/state-maybe (c-code (str "(Value *)" c-var) [] [] {} {}))))

(defn lookup-protocol-path [fn-sym path]
  ;; is protocol function `fn-sym` declared in module at 'path'
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [protos (get-in s [.modules path .protocols])
                           _ (some (vals protos) (fn [proto] (get proto fn-sym)))]
                       [path s]))))

;; TODO: still need?
(defn find-protocol-path [fn-sym]
  (comp (for [path (sym-ns-path fn-sym)
              path (lookup-protocol-path fn-sym path)]
          path)
        (lookup-protocol-path fn-sym 'core)))

(defn redef-proto-fn-error [sym]
  (for [path (find-protocol-path sym)
        _ (compilation-error "Redefining" (str "'" sym "'") "at"
                             (str (ast/file-name sym) ":") (ast/line-number sym)
                             "which is a protocol function in" path)]
    ""))

(defn new-proto-impl [proto-sym fn-sym arg-count dispatch-type var ast param-constraints result-constraints]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-sym))
  (assert (instance? Integer dispatch-type))
  (assert (instance? ast/fn-arity-ast ast))
  (assert (instance? ItemsConstraint param-constraints))
  (assert (instance? ResultConstraint result-constraints))
  (assert (instance? ArityValPtr var))

  (for [protocol-path (find-protocol-path fn-sym)
        _ (sm/assoc-in-val [.modules protocol-path .protocols proto-sym fn-sym arg-count dispatch-type]
                           (ProtoImpl dispatch-type var ast param-constraints result-constraints))]
    ""))

(defn get-protocol [proto-sym]
  ;; Look for the protocol information
  ;; 1. using the namespace portion of the protocol symbol
  ;; 2. using `'core` for protcols defined in the core
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (or (let [path (either (extract-sym-path s proto-sym)
                                      (ast/file-name proto-sym))]
                     (for [proto-info (-> (.modules s)
                                          (get path)
                                          (flat-map (fn [module]
                                                      (get (.protocols module) proto-sym))))]
                       [proto-info s]))
                   (for [proto-info (-> (.modules s)
                                        (get 'core)
                                        (flat-map (fn [module]
                                                    (get (.protocols module) proto-sym))))]
                     [proto-info s])))))

;; TODO: it feels like these 2 arities are too different
(defn get-proto-impl
  ([fn-name arg-count type-num]
   (sm/new-sm (fn [s]
                (assert (instance? GlobalContext s))
                (or (let [proto-path (either (extract-sym-path s fn-name)
                                             (ast/file-name fn-name))]
                      (for [protocols (get-in s [.modules proto-path .protocols])
                            impl-info (some (vals protocols)
                                            (fn [dispatchers]
                                              (get-in dispatchers [fn-name arg-count type-num])))]
                        [impl-info s]))
                    (for [protocols (get-in s [.modules 'core .protocols])
                          impl-info (some (seq protocols)
                                          (fn [[proto-name dispatchers]]
                                            (get-in dispatchers [fn-name arg-count type-num])))]
                      [impl-info s])))))
  ([proto-sym fn-sym arg-count type-num]
   (flat-map (sm/new-sm (fn [s]
                          (maybe [(either (extract-sym-path s proto-sym)
                                          (ast/file-name proto-sym))
                                  s])))
             (fn [proto-path]
               (comp (sm/get-in-val [.modules proto-path .protocols proto-sym fn-sym
                                     arg-count type-num])
                     (sm/get-in-val [.modules 'core .protocols proto-sym fn-sym arg-count type-num])
                     ;; (compilation-error "Invalid protocol fn:"
                     ;;                    (str "'" fn-sym "' in")
                     ;;                    (str (ast/file-name fn-sym) ",")
                     ;;                    (ast/line-number fn-sym))
                     )))))

(defn new-module-def [sym value]
  (comp (redef-proto-fn-error sym)
        (for [r (sm/assoc-in-val [.modules (ast/file-name sym) .values sym] value)
              _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym] nothing)]
          r)))

(defn lookup-declaration [sym]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (-> (.modules s)
                   (get (ast/file-name sym))
                   (flat-map (fn [module]
                               (map (get-in (.declarations module) [sym '_])
                                    (fn [expr]
                                      [expr s]))))))))

(defn already-closed-over [sym]
  (for [closure-var (sm/new-sm (fn [s]
                                 (assert (instance? GlobalContext s))
                                 (-> s
                                     .fn-context
                                     .closed-over
                                     .closures
                                     (some (fn [[closure-var sym-literal]]
                                             (for [_ (= sym sym-literal)]
                                               [closure-var s]))))))
        _ (sm/update-in-val [.fn-context .closed-over .refs-map closure-var] inc)]
    closure-var))

(defn new-closure [sym]
  (for [closure-var (genlocal "val")
        _ (sm/update-in-val [.fn-context .closed-over .closures]
                            (fn [v] (conj v [closure-var sym])))
        _ (sm/assoc-in-val [.fn-context .closed-over .refs-map closure-var] 1)]
    closure-var))

(def get-syms (sm/new-sm (fn [s]
                           (assert (instance? GlobalContext s))
                           (maybe [(.syms (.fn-context s)) s]))))

(defn get-sym [sym]
  (flat-map get-syms (fn [syms]
                       (sm/when (get syms sym)))))

(defn set-syms [syms]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (maybe [s (.fn-context s (.syms (.fn-context s) syms))]))))

(defn set-sym [sym expr]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [ctxt (.fn-context s)
                     syms (.syms ctxt)]
                 (maybe [s (.fn-context s (.syms ctxt (assoc syms sym expr)))])))))

;; This is so hideous on purpose. It's called *A LOT* so I unwound it for performance's sake
(defn lookup-sym [sym]
  (let [sym-file (ast/file-name sym)]
    (comp (sm/new-sm
           (fn [s]
             (assert (instance? GlobalContext s))
             (let [ctxt (.fn-context s)
                   syms (.syms ctxt)
                   modules (.modules s)
                   closed-over (.closed-over ctxt)
                   closures (.closures closed-over)
                   refs-map (.refs-map closed-over)]
               (or (map (or (and (rdr/namespace sym)
                                 (or (-> (flat-map (extract-sym-path s sym)
                                                   (partial get modules))
                                         (flat-map (fn [module]
                                                     (let [values (.values module)]
                                                       (or (get values (.base sym))
                                                           (get values (rdr/tag (.base sym))))))))
                                     (do
                                       (print-err "Undefined symbol" (str "'" sym "'") "at"
                                                  (str sym-file ":")
                                                  (ast/line-number sym))
                                       (maybe (abort)))))
                            (get syms sym))
                        (fn [expr]
                          [expr s]))
                   (map (-> ctxt .context-syms (get sym))
                        (fn [sym-info]
                          (either (some closures
                                        (fn [[closure-var sym-literal]]
                                          (and (= sym sym-literal)
                                               (map (get refs-map closure-var)
                                                    (fn [refs-count]
                                                      (let [new-refs-map (assoc refs-map closure-var (inc refs-count))
                                                            new-closed-over (.refs-map closed-over new-refs-map)
                                                            new-ctxt (.closed-over ctxt new-closed-over)]
                                                        [(c-code closure-var [] [] {closure-var 1}
                                                                 {closure-var (expr-constraints sym-info)})
                                                         (.fn-context s new-ctxt)]))))))
                                  (let [sym-count (.sym-count ctxt)
                                        closure-var (str "val" sym-count)
                                        new-sym-count (inc sym-count)
                                        new-closures (conj closures [closure-var sym (expr-constraints sym-info)])
                                        new-refs-map (assoc refs-map closure-var 1)
                                        new-closed-over (-> closed-over
                                                            (.closures new-closures)
                                                            (.refs-map new-refs-map))
                                        new-ctxt (-> ctxt
                                                     (.sym-count new-sym-count)
                                                     (.closed-over new-closed-over))]
                                    [(c-code closure-var [] [] {closure-var 1}
                                             {closure-var (expr-constraints sym-info)})
                                     (.fn-context s new-ctxt)]))))
                   (map (or (flat-map (get modules sym-file)
                                      (fn [module]
                                        (or (get (.values module) sym)
                                            (get-in (.declarations module) [sym '_]))))
                            (flat-map (get modules 'core)
                                      (fn [module]
                                        (get (.values module) sym))))
                        (fn [expr] [expr s]))
                   (do
                     (print-err "Undefined symbol" (str "'" sym "'") "at"
                                (str sym-file ":")
                                (ast/line-number sym))
                     (abort)))))))))

(extend-type SymbolConstraints
  Emitter
  (tail-call [constraint _ _] constraint)

  (produces-code? [_] nothing)

  (replace-syms [constraint subs]
    (either (for [old-sym (.sym constraint)
                  new-sym (get subs old-sym)]
              (sm/state-maybe (update-sym constraint new-sym)))
            (sm/state-maybe constraint)))

  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (for [sym-info (lookup-sym sym)
                         :let [var (.constraints sym-info (merge-with (partial compose-constraints "" 0)
                                                                      (.constraints sym-info)
                                                                      {(.c-var sym-info)
                                                                       (update-var constraint (.c-var sym-info))}))]
                         _ (set-sym sym var)]
                     (.refs-map var (dissoc (.refs-map sym-info) (.c-var sym-info))))))
            (sm/state-maybe empty-c-code)))

  Assertion
  (assertion? [constraint]
    (maybe constraint))

  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint (cons [(str file-name ":") line-number]
                                      (.path constraint)))))))

(extend-type FieldConstraint
  Emitter
  (emit [constraint]
    (either (map (.sym constraint)
                 (fn [sym]
                   (for [sym-info (lookup-sym sym)
                         field-var (lookup-sym (.field constraint))
                         :let [var (.constraints sym-info (merge-with (partial compose-constraints "" 0)
                                                                      (.constraints sym-info)
                                                                      {(.c-var sym-info)
                                                                       (-> constraint
                                                                           (.field-var (.c-var field-var))
                                                                           (update-var (.c-var sym-info)))}))]
                         _ (set-sym sym var)]
                     (.refs-map var (dissoc (.refs-map sym-info) (.c-var sym-info))))))
            (sm/state-maybe empty-c-code))))

(extend-type MultiConstraint
  Emitter
  (emit [constraint]
    (map (traverse (.constraints constraint) emit)
         (fn [[expr & exprs]]
           (comp* expr exprs)))))

(extend-type AllValues
  Emitter
  (emit [constraint]
    (sm/state-maybe empty-c-code)))

(extend-type List
  Emitter
  (tail-call [asts args result-constraint]
    (let [asts (reverse asts)]
      (either (empty? asts)
              (let [[tail & init] asts]
                (-> (tail-call tail args result-constraint)
                    (cons init)
                    reverse))))))

(extend-type Vector
  Emitter
  (tail-call [asts params result-constraint]
    (extract (or (empty? asts)
                 (flat-map (last asts)
                           (fn [tail]
                             (store asts (dec (count asts))
                                    (tail-call tail params result-constraint))))))))

(extend-type HashMap
  Emitter
  (encode [m] (encode m "var_"))
  (encode [m var-prefix]
    (for [map-var (global-var var-prefix)
          :let [_ (write-strings [["Value *" map-var " = (Value *)&emptyBMI;\n"]])]
          assocs (traverse (seq m)
                           (fn [[sym var]]
                             (for [sym-var (either (and (instance? Tagged sym)
                                                        (maybe (emit (ast/quoted-ast sym))))
                                                   (emit sym))
                                   expr (encode var)]
                               (do
                                 (write-strings [(.decl sym-var) (.decl expr)])
                                 [(.init sym-var) (.init expr)
                                  map-var " = hashMapAssoc((Value *)" map-var
                                  ", incRef(" (.c-var sym-var) ", 1), " (.c-var expr) ");\n"]))))]
      (c-code map-var
              (comp* [] assocs)
              [] {} {}))))

(deftype StaticArityInfo [c-var param-constraints result-constraint]
  (assert (instance? CFnPtr c-var))
  (assert (instance? ItemsConstraint param-constraints))
  (assert (instance? ValueConstraint result-constraint))

  Stringable
  (string-list [_]
    (list "<StaticArityInfo " (str c-var) " " (str param-constraints) " " (str result-constraint) ">")))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity-info [fn-var num-params]
  (assert (instance? FnPTr fn-var))
  
  (sm/get-in-val [.fns fn-var num-params]))

(defn arg-constraints [arg-asts arg-vars constraints file-name line-number]
  (assert (instance? ItemsConstraint constraints))

  (for [constraint-maps (traverse (zip-lists (seq arg-asts)
                                             (seq arg-vars)
                                             (.items-constraints constraints))
                                  (fn [[ast var constraint]]
                                    (let [constraint (update-path constraint file-name line-number)
                                          new-const (compose-constraints file-name line-number
                                                                         constraint
                                                                         (update-path (expr-constraints var)
                                                                                      file-name line-number))]
                                      (comp (for [_ (constrain-sym ast constraint)]
                                              {(.c-var var) new-const})
                                            (sm/state-maybe {(.c-var var) new-const})))))]
    (comp* {} constraint-maps)))

(defn lookup-core-fn-arity [sym num-args]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (for [module (get (.modules s) 'core)
                     fn-sym (get (.values module) sym)
                     expr (get-in (.fns s) [(.c-var fn-sym) num-args .c-var])]
                 [expr s]))))


(extend-type ast/block-comment-ast
  Emitter
  (produces-code? [ast] nothing)

  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] {} {})))

  (emit-defined-value [_ x] (sm/state-maybe []))
  (emit-definition [_] (sm/state-maybe []))

  (tail-call [ast params result-constraint] ast))

(defn make-static-string [str-val]
  ;; TODO: when adding meta data, make sure to update this as well
  (let [str-len (count str-val)]
    (comp (sm/get-in-val [.constants .strings str-val])
          (for [str-idx (sm/new-sm (fn [s]
                                     (assert (instance? GlobalContext s))
                                     (-> s
                                         .constants
                                         .strings
                                         count
                                         (vector s)
                                         maybe)))
                :let [str-sym (str "str" str-idx)
                      str-ptr (str "strPtr" str-idx)]
                _ (sm/assoc-in-val [.constants .strings str-val]
                                   (c-code str-ptr [] [] {}
                                           {str-ptr (TypeConstraint {StringBufferType #{}} empty-list
                                                                    'String nothing str-ptr)}))]
            (c-init str-ptr
                    []
                    ["struct {int64_t type;
        int32_t refs;
        int64_t len;
        Integer *hash;
        char buffer["
                     (inc str-len)
                     "];\n} " str-sym " = {StringBufferType, -1, "
                     str-len ", 0, \"" (escape-chars str-val) "\"};\n"
                     "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
                    {} {str-ptr (TypeConstraint {StringBufferType #{}} empty-list 'String nothing str-ptr)}
                    "" 0)))))

(defn make-c-code [value]
  (c-code (.c-var value) (.init value) (.decl value)
          (.refs-map value) (.constraints value)))

(defn get-type-info [path type-symbol]
  (sm/new-sm (fn [s]
               (assert (instance? GlobalContext s))
               (let [modules (.modules s)]
                 (for [type-num (or (flat-map (get modules path)
                                              (fn [module]
                                                (get (.types module) type-symbol)))
                                    (flat-map (get modules 'core)
                                              (fn [module]
                                                (get (.types module) type-symbol))))
                       type-map (get-in s [.type-maps type-num .type-map])]
                   [type-map s])))))

(defn get-type-sym-info [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-info (get-type-info ns-path type-symbol)]
          type-info)
        (sm/state-maybe {})))

(defn type-constraint [type-num file-name line-number]
  (comp (for [type-info (sm/get-in-val [.type-maps type-num])]
          (either (and (empty? (.type-map type-info))
                       (maybe top-type))
                  (-> (.type-map type-info)
                      (TypeConstraint empty-list (.sym type-info) nothing "")
                      (update-path file-name line-number))))
        (sm/state-maybe top-type)))

(defn get-type-numbers [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-info ns-path type-symbol)]
          (set (keys type-nums)))
        (sm/state-maybe #{})))

(defn get-type-number [type-symbol]
  (assert (instance? Maybe type-symbol))
  (comp (for [type-symbol (sm/when type-symbol)
              ns-path (sym-ns-path type-symbol)
              type-nums (get-type-info ns-path type-symbol)]
          (either (and (= 1 (count type-nums))
                       (first (keys type-nums)))
                  UnknownType))
        (sm/state-maybe UnknownType)))

;; TODO: only used in commented code
;; (defn get-asserted-types [type-symbol file-name line-number]
;;   (comp (for [ns-path (sym-ns-path type-symbol)
;;               type-nums (get-type-info ns-path type-symbol)]
;;           (set (keys type-nums)))
;;         (compilation-error "Unknown type"
;;                            (str "'" type-symbol "'")
;;                            "in assertion at"
;;                            (str file-name ":")
;;                            line-number)))

;; TODO: line numbering starts to go wrong here

(extend-type ast/assert-ast
  Assertion
  (assertion? [ast]
    (maybe ast))

  (assert-type [ast]
    (assert-type (.assertion ast)))

  Emitter
  (replace-bound-vars [ast subs]
    (ast/assert-ast (replace-bound-vars (.assertion ast) subs)))

  (replace-syms [ast subs]
    (map (replace-syms (.assertion ast) subs)
         (fn [assertion]
           (ast/assert-ast assertion))))

  (produces-code? [ast]
    nothing)

  (emit [ast]
    (-> (.assertion ast)
        (update-path (ast/file-name ast) (ast/line-number ast))
        emit))

  (tail-call [ast params result-constraint] ast))


(extend-type ast/type-assertion
  Emitter
  (replace-bound-vars [ast subs]
    (.sym ast (either (get subs (.sym ast))
                      (.sym ast))))

  (replace-syms [ast subs]
    (sm/state-maybe (.sym ast (either (get subs (.sym ast))
                                      (.sym ast)))))

  (to-constraint [ast]
    (let [sym (.type-sym ast)
          file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (comp (map (get-type-sym-info (maybe sym))
                 (fn [type-info]
                   (either (and (empty? type-info)
                                (maybe top-type))
                           (-> type-info
                               (TypeConstraint empty-list sym nothing "")
                               (update-path file-name line-number)))))
            (sm/state-maybe top-type))))

  (emit [ast]
    (for [constraint (to-constraint ast)
          _ (constrain-sym (.sym ast) constraint)
          var (lookup-sym (.sym ast))]
      (c-code "" [] [] {} (.constraints var))))

  ;; Ooof. so having this as the last thing in the previous 'emit' impl' causes an incRef error
    ;; TODO:  move this to the c-init comp* fn
  ;; (for [type-nums (get-asserted-types (.type-sym ast) (ast/file-name ast) (ast/line-number ast))
  ;;       var (lookup-sym (.sym ast))]
  ;;   (c-code ""
  ;;           ["switch (" (.c-var var) "->type) {" line-sep
  ;;            (map (seq type-nums) (fn [type-num]
  ;;                                   ["case " type-num ": " line-sep]))
  ;;            "break;" line-sep " default: " line-sep
  ;;            "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
  ;;            (ast/file-name ast) "\"," (ast/line-number ast)
  ;;            ");" line-sep
  ;;            "fprintf(stderr, \"Expected %s, got %s\\n\", \""
  ;;            (str (.type-sym ast)) "\", extractStr(type_name(empty_list, " (.c-var var)
  ;;            ")));" line-sep
  ;;            "abort();" line-sep
  ;;            "}" line-sep]
  ;;           [] UnknownType {} {}))


  Assertion
  (assert-type [ast]
    (maybe (.type-sym ast))))

(extend-type ast/min-count-assertion
  Emitter
  (to-constraint [ast]
    (sm/state-maybe (ItemsConstraint (repeat (.len ast) top-type)
                                     (list [(ast/file-name ast) (ast/line-number ast)])
                                     nothing
                                     "")))

  (emit [ast]
    (for [var (lookup-sym (.sym ast))]
      (c-code "" [] [] {}
              {(.c-var var) (-> (ItemsConstraint (repeat (.len ast) top-type)
                                                 (list [(ast/file-name ast) (ast/line-number ast)])
                                                 nothing
                                                 "")
                                (update-var (.c-var var))
                                (update-sym (.sym ast)))}))))

(extend-type ast/result-ast
  Assertion
  (return-assertion? [ast] (maybe ast))

  Emitter
  (produces-code? [ast] nothing)

  (replace-syms [ast subs]
    (either (for [new-sym (get subs (.sym ast))]
              (.sym ast new-sym))
            (sm/state-maybe ast)))

  (to-constraint [ast]
    (to-constraint (.assertion ast))))

(defn emit-tail-expr [ast result-constraint expr]
  (do
    ;; TODO: periodically enable this to check on things
    ;; (print-err 'check (some return-assertions assert-return-type) return-type
    ;;            (ast/file-name ast) (ast/line-number ast))
    (merge-with (partial compose-constraints "" 0)
                (.constraints expr)
                {(.c-var expr) result-constraint})
    (collapse-expressions [expr
                           (c-code (.c-var expr)
                                   ["return(" (.c-var expr) ");" line-sep]
                                   [] {(.c-var expr) 1}
                                   {(.c-var expr) result-constraint})])))

(deftype TailCall [ast params result-constraint]
  (assert (instance? Vector params))

  Stringable
  (string-list [expr]
    (comp (list "<TailCall ") (string-list ast) " " (string-list result-constraint) " "
          (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name ast))
  (ast/line-number [_]
    (ast/line-number ast))

  Emitter
  (emit [_]
    (comp (for [_ (sm/when (and (instance? ast/call-ast ast)
                                (instance? Tagged (.call-target ast))))
                target (emit (.call-target ast))
                _ (sm/get-in-val [.fn-context .recurse (.c-var target) (count (.args ast))])
                args (-> (.args ast)
                         (filter produces-code?)
                         (traverse emit))
                line (line-macro ast "// recursive-fixed")]
            (comp* empty-c-code (comp args
                                      [(c-code ""
                                               [line
                                                (map (zip-lists params (map args .c-var))
                                                     (fn [[param arg]]
                                                       [param " = " arg ";" line-sep]))]
                                               [] {} {})])))
          (map (emit ast)
               (fn [expr]
                 (let [expr (either (and (instance? Tagged ast)
                                         (maybe (.refs-map expr {})))
                                    expr)]
                   (emit-tail-expr ast result-constraint expr)))))))

(extend-type String
  Emitter
  (encode [s var-prefix]
    (for [var (global-var var-prefix)
          expr (emit s)]
      (c-code var [] [] {} {})))

  (emit [str-val]
    (make-static-string str-val))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                (.constraints value)))]
      [(make-c-code value)]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint)))


(defn make-static-num [num]
  (for [num-idx (sm/new-sm (fn [s]
                               (assert (instance? GlobalContext s))
                               (-> s
                                   .constants
                                   .numbers
                                   count
                                   (vector s)
                                   maybe)))
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.constants .numbers num]
                           (c-code num-ptr [] [] {}
                                   {num-ptr (TypeConstraint {IntegerType #{}} empty-list 'Integer nothing
                                                            num-ptr)}))]
    (c-init num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            {} {num-ptr (TypeConstraint {IntegerType #{}} empty-list 'Integer nothing
                                        num-ptr)}
            "" 0)))

(extend-type Integer
  Emitter
  (encode [s var-prefix]
    (for [var (global-var var-prefix)
          expr (emit s)]
      (c-code var [] [] {} {})))

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [num]
    (comp (sm/get-in-val [.constants .numbers num])
          (make-static-num num)))

  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                (.constraints value)))]
      [(make-c-code value)]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint)))


(extend-type ast/quoted-ast
  Emitter
  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast)

  (emit [ast]
    (let [sym (.q-val ast)]
      (comp (sm/get-in-val [.constants .symbols sym])
            (for [sym-idx (sm/new-sm (fn [s]
                                       (assert (instance? GlobalContext s))
                                       (-> s
                                           .constants
                                           .symbols
                                           count
                                           (vector s)
                                           maybe)))
                  :let [sym-var (str "sym" sym-idx)
                        sym-ptr (str "symPtr" sym-idx)
                        constraint (update-path sym-constraint
                                                (ast/file-name ast) (ast/line-number ast))]
                  _ (sm/assoc-in-val [.constants .symbols sym]
                                     (c-code sym-ptr [] [] {}
                                             {sym-ptr constraint}))]
              (c-code sym-ptr
                      []
                      ["SubString " sym-var " = {SymbolType, -1, " (count (str sym))
                       ", 0, 0, \"" sym "\"};\n"
                       "Value *" sym-ptr " = (Value *)&" sym-var ";\n"]
                      {} {sym-ptr constraint})))))

  (emit-defined-value [ast defined-sym]
    (for [quoted (emit ast)
          _ (new-module-def defined-sym (c-code (.c-var quoted) [] [] {}
                                                {(.c-var quoted) (update-path sym-constraint
                                                                              (ast/file-name ast)
                                                                              (ast/line-number ast))}))]
      [(make-c-code quoted)]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint)))


(def vect-constraint (TypeConstraint {VectorType #{}} empty-list 'Vector nothing ""))

(defn call-vector [target args arg-asts]
  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [_ (sm/when (= target 'vector))
          vect-sym (genlocal "newVect")
          result-sym (genlocal "rslt")
          line (line-macro target "// call-vector")]
      (let [arg-constraints (.constraints (collapse-expressions args))
            constraints (comp vect-constraint
                              (StaticLengthConstraint (count args)
                                                      empty-list
                                                      nothing
                                                      result-sym)
                              (ItemsConstraint (map args (fn [arg]
                                                           (either (get arg-constraints (.c-var arg))
                                                                   top-type)))
                                               empty-list
                                               nothing
                                               result-sym))]
        (comp* empty-c-code
               (comp args
                     [(c-init result-sym
                              [line
                               "Vector *" vect-sym " = empty_vect;" line-sep
                               (map args
                                    (fn [arg]
                                      (let [arg-sym (.c-var arg)]
                                        [vect-sym " = mutateVectConj(" vect-sym ", "
                                         arg-sym ");" line-sep])))
                               "Value *" result-sym " = (Value *)" vect-sym ";" line-sep]
                              [] {}
                              {result-sym (update-path constraints file-name line-number)}
                              file-name line-number)]))))))

(def list-constraint (TypeConstraint {ListType #{}} empty-list 'List nothing ""))

(defn call-list [target args arg-asts]
  (let [file-name (ast/file-name target)
        line-number (ast/line-number target)]
    (for [_ (sm/when (= target 'list))
          line (line-macro target "// call-list")
          list-sym (genlocal "newList")
          result-sym (genlocal "rslt")]
      (let [arg-constraints (.constraints (collapse-expressions args))
            constraints (comp list-constraint
                              (StaticLengthConstraint (count args)
                                                      empty-list
                                                      nothing
                                                      result-sym)
                              (ItemsConstraint (map args (fn [arg]
                                                           (either (get arg-constraints (.c-var arg))
                                                                   top-type)))
                                               empty-list
                                               nothing
                                               result-sym))]
        (comp* empty-c-code
               (comp args
                     [(c-init result-sym
                              [line "List *" list-sym " = empty_list;" line-sep
                               (map (reverse args)
                                    (fn [arg]
                                      (let [arg-sym (.c-var arg)]
                                        [list-sym " = listCons(" "(Value *)" arg-sym
                                         ", " list-sym ");" line-sep])))
                               "Value *" result-sym " = (Value *)" list-sym ";" line-sep]
                              [] {}
                              {result-sym (update-path constraints file-name line-number)}
                              file-name line-number)]))))))

(defn call-proto-impl [target args ast]
  (either (for [dispatch-val (first args)]
            (let [num-args (count args)
                  disp-type (expr-type-num dispatch-val)]
              (for [_ (sm/when-not (= UnknownType disp-type))
                    impl-info (get-proto-impl target num-args disp-type)
                    constraints (arg-constraints (.args ast) args (.param-constraints impl-info)
                                                 (ast/file-name ast) (ast/line-number ast))
                    _ (comp (sm/update-in-val [.constants .other 'type-known-sites] inc)
                            (sm/assoc-in-val [.constants .other 'type-known-sites] 1))
                    result-var (genlocal "rslt")
                    line (line-macro target (str "// call proto fn " target))]
                (comp* empty-c-code
                       (comp args
                             [(c-init result-var
                                      [line "Value *" result-var " = ((FnType" num-args " *)(((FnArity *)"
                                       (.c-var impl-info) ")->fn))("
                                       (interpose (conj (map args .c-var)
                                                        ["((FnArity *)" (.c-var impl-info) ")->closures"])
                                                  ", ")
                                       ");" line-sep]
                                      [] {}
                                      (assoc constraints
                                        result-var (.result-constraints impl-info))
                                      (ast/file-name ast) (ast/line-number ast))])))))
          (zero sm/state-maybe)))

(defn inline-wrap-and-apply* [name args]
  ;; TODO: this is subtly broken in replacing syms/bound-vars. It breaks on:
  ;; (for [name (list 1 2 3 4)
  ;;       :let [name (str name)]
  ;;       :when-not (= "." (subs name 0 1))]
  ;;   name)

  ;; (let [[dispatch-ast & arg-asts] args]
  ;;   (for [dispatch-val (emit dispatch-ast)
  ;;         impl-ast (map (get-proto-impl name (count args)
  ;;                                       (expr-type-num dispatch-val))
  ;;                       .ast)
  ;;         expr (-> impl-ast
  ;;                  (replace-bound-vars {})
  ;;                  (inline-expr (cons dispatch-val arg-asts)))]
  ;;     expr))
  (zero sm/state-maybe)
  )


(defn inline-flat-map [name args]
  (let [[dispatch-ast f-ast] args]
    (for [dispatch-val (emit dispatch-ast)
          :let [dispatch-type (expr-type-num dispatch-val)]
          :when-not (= UnknownType dispatch-type)
          impl-ast (map (get-proto-impl name 2 dispatch-type)
                        .ast)
          :let [impl-ast (replace-bound-vars impl-ast {})
                [dispatch-sym f-sym] (.fixed (.params impl-ast))]
          body-exprs (traverse (.body impl-ast)
                               (fn [ast]
                                 (replace-syms ast {f-sym f-ast})))]
      (ast/let-ast [(ast/binding dispatch-sym dispatch-val)]
                   (vec body-exprs)))))

(extend-type rdr/tagged-symbol
  Emitter
  (encode [s var-prefix]
    (for [var (global-var var-prefix)
          expr (emit s)]
      (c-code var [] [] {} {})))

  (constrain-sym [sym constraint]
    (for [var (sm/get-in-val [.fn-context .syms sym])
          :let [constraint (-> (compose-constraints (ast/file-name sym) (ast/line-number sym)
                                                    constraint (expr-constraints var))
                               (update-var (str (.c-var var)))
                               (update-sym sym))]
          _ (set-sym sym (.constraints var {(.c-var var) constraint}))]
      constraint))

  (get-param-constraints [sym constraint-map]
    (for [expr (lookup-sym sym)]
      (-> (either (get constraint-map (.c-var expr))
                  top-type)
          (update-var (.c-var expr))
          (update-sym sym))))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] {arg-var 1} {})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                constraint (expr-constraints evalled)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.constraints (assoc (.constraints evalled)
                                            arg-var constraint))
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] []
                                    {(.c-var evalled) 1}
                                    {(.c-var evalled) constraint})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [(c-init (.c-var evalled) (.init evalled) (.decl evalled)
                                     (.refs-map evalled)
                                     (.constraints evalled)
                                     (ast/file-name binding) (ast/line-number binding))]))))

  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (new-module-def defined-sym value)]
      [(make-c-code value)]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (emit-call-expr [target-ast args call-expr-ast]
    (comp (call-vector target-ast args (.args call-expr-ast))
          (call-list target-ast args (.args call-expr-ast))
          (call-proto-impl target-ast args call-expr-ast)))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)
          num-args (count args)]
      (either (or (and (< 0 num-args)
                       (or (= name 'wrap)
                           (= name 'apply*))
                       (maybe (inline-wrap-and-apply* name args)))
                  (and (= 2 num-args)
                       (or (= name 'flat-map)
                           (= name 'map))
                       (maybe (inline-flat-map name args))))
              (zero sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))


(extend-type Symbol
  Emitter
  (constrain-sym [sym constraint]
    (for [var (sm/get-in-val [.fn-context .syms sym])
          :let [constraint (-> (compose-constraints (ast/file-name sym) (ast/line-number sym)
                                                    constraint (expr-constraints var))
                               (update-var (str (.c-var var)))
                               (update-sym sym))
                type-num (either (for [type-nums (extract-type-map constraint)
                                       :when (= 1 (count type-nums))
                                       type-num (first (keys type-nums))]
                                   type-num)
                                 UnknownType)]
          _ (set-sym sym (-> var
                             (.constraints {(.c-var var) constraint})))]
      constraint))

  (get-param-constraints [sym constraint-map]
    (for [expr (lookup-sym sym)]
      (-> (either (get constraint-map (.c-var expr))
                  top-type)
          (update-var (.c-var expr))
          (update-sym sym))))

  (bind [binding]
    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                arg (c-code arg-var [] [] {arg-var 1} {})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding arg))]
      (ParamBinding [arg-var] [])))

  (bind [binding evalled]
    (assert (instance? C-expr evalled))

    (for [arg-var (genlocal binding "arg")
          :let [arg-var (str arg-var)
                constraint (expr-constraints evalled)
                evalled (-> evalled
                            (.c-var arg-var)
                            (.constraints (assoc (.constraints evalled)
                                            arg-var constraint))
                            (.init [(.init evalled) "Value *" arg-var " = "
                                    (.c-var evalled) ";" line-sep]))
                evalled-ref (c-code (.c-var evalled) [] []
                                    {(.c-var evalled) 1}
                                    {(.c-var evalled) constraint})]
          _ (comp (redef-proto-fn-error binding)
                  (set-sym binding evalled-ref))]
      (either (and (empty? (.init evalled))
                   (maybe (ParamBinding [(.c-var evalled)] [evalled])))
              (ParamBinding [(.c-var evalled)]
                            [(c-init (.c-var evalled) (.init evalled) (.decl evalled)
                                     (.refs-map evalled)
                                     (.constraints evalled)
                                     (ast/file-name binding) (ast/line-number binding))]))))

  (emit [sym]
    (lookup-sym sym))

  (replace-syms [ast subs]
    (sm/state-maybe (get subs ast ast)))

  (inline-expr [name arg-asts]
    (let [args (filter arg-asts produces-code?)
          num-args (count args)]
      (either (or (and (< 0 num-args)
                       (or (= name 'wrap)
                           (= name 'apply*))
                       (maybe (inline-wrap-and-apply* name args)))
                  (and (= 2 num-args)
                       (or (= name 'flat-map)
                           (= name 'map))
                       (maybe (inline-flat-map name args))))
              (zero sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (get subs ast ast)))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          line-info (line-macro ast "// inline")
          :let [init [line-info (.txt ast) "\n#\n"]]
          type-num (get-type-number (.result-type ast))
          expr (either (and (= UnknownType type-num)
                            (maybe (sm/state-maybe (c-code "" init [] {} {}))))
                       (for [c-var (genlocal "rslt")
                             constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))]
                         (c-code c-var init [] {} {c-var constraint})))]
      expr))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))
          constraint (type-constraint type-num (ast/file-name ast) (ast/line-number ast))
          c-var (comp (map (lookup-declaration defined-sym) .c-var)
                      (global-var defined-sym "var"))
          _ (new-module-def defined-sym (c-code (str c-var) [] [] {}
                                                {(str c-var) constraint}))
          line-info (line-macro ast "// inline")]
      [(c-code c-var [] [line-info "Value *" c-var " = " (.txt ast) ";" line-sep "\n#\n"]
               {} {c-var constraint})]))

  (emit-definition [ast]
    (for [target-lang (sm/state-maybe 'C)
          :when (= (.lang ast) target-lang)
          type-num (get-type-number (.result-type ast))]
      [(c-code "" [] [(.txt ast)] {} {})]))

  (tail-call [ast params result-constraint]
    ;; TODO: statically verify the return type, if possible
    ast)

  (replace-syms [ast _]
    (sm/state-maybe ast))

  (replace-bound-vars [ast _]
    ast))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (map (traverse (.value-exprs ast) (fn [ast]
                                          (emit-defined-value ast defined-sym)))
           flatten))))

(extend-type ast/declaration-ast
  Emitter
  (emit-definition [ast]
    (let [sym (.sym ast)]
      (comp (map (lookup-declaration sym) (fn [_] []))
            (for [c-var (global-var sym "var")
                  :let [c-info (c-code c-var [] [] {} {})]
                  _ (sm/assoc-in-val [.modules (ast/file-name sym) .declarations sym]
                                     (maybe c-info))]
              [(-> c-info
                   (.c-var "")
                   (.decl ["Value *" c-var ";\n"]))])))))

(extend-type StaticFnPtr
  Emitter
  (call-site-meta-data [v f l]
    (sm/state-maybe (c-code "empty_list" [] [] {} {})))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'static-fixed-sites] inc)
          (sm/assoc-in-val [.constants .other 'static-fixed-sites] 1))))

(extend-type ProtoDispFnPtr
  Emitter
  (call-site-meta-data [_ file-name line-number]
    (let [str-val (str file-name ": " line-number)]
      (map (make-static-string str-val)
           (fn [expr]
             (.c-var expr (str "(List *)" (.c-var expr)))))))

  (update-call-site-count [_]
    (comp (sm/update-in-val [.constants .other 'proto-dispatch-sites] inc)
          (sm/assoc-in-val [.constants .other 'proto-dispatch-sites] 1))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-info (lookup-static-arity-info (.c-var target) (count arg-vars))
          constraints (arg-constraints (.args ast) arg-vars (.param-constraints arity-info)
                                       file-name line-number)
          result-sym (genlocal "rslt")
          _ (update-call-site-count (.c-var arity-info))
          line (line-macro ast "// static-fixed")
          call-site-location (call-site-meta-data (.c-var arity-info) file-name line-number)]
      (c-init result-sym
              [line "Value *" result-sym " = " (.c-var arity-info) "("
               (interpose (cons (.c-var call-site-location)
                                (seq (map arg-vars .c-var))) ", ") ");" line-sep]
              (.decl call-site-location)
              {} (assoc constraints
                   result-sym (.result-constraint arity-info))
              file-name line-number))))

(defn call-static-variadic [target arg-vars ast]
  (let [file-name (ast/file-name ast)
        line-number (ast/line-number ast)]
    (for [arity-info (lookup-static-arity-info (.c-var target) 'variadic)
          arg-consts (arg-constraints (.args ast) arg-vars (.param-constraints arity-info)
                                      file-name line-number)
          _ (comp (sm/update-in-val [.constants .other 'static-variadic-sites] inc)
                  (sm/assoc-in-val [.constants .other 'static-variadic-sites] 1))
          args-list (call-list (rdr/tag 'list file-name line-number)
                               (map arg-vars (fn [arg]
                                               (.init arg [])))
                               (.args ast))
          result-sym (genlocal "rslt")
          line (line-macro ast "// static-variadic")]
      (c-init result-sym
              [(.init args-list)
               line
               "Value *" result-sym " = " (.c-var arity-info) "(empty_list, (Value *)"
               (.c-var args-list) ");" line-sep]
              [] {}
              (assoc-all arg-consts
                         (.c-var args-list) (compose-constraints file-name line-number
                                                                 (.param-constraints arity-info)
                                                                 (expr-constraints args-list))
                         result-sym (.result-constraint arity-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn call-dyn-fn-value [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (for [arity-sym (genlocal "arity")
        :when (= FunctionType (expr-type-num target))
        _ (comp (sm/update-in-val [.constants .other 'dyn-fn-sites] inc)
                (sm/assoc-in-val [.constants .other 'dyn-fn-sites] 1))
        variadic-sym (genlocal "dynArgs")
        fn-var (genlocal "fn")
        result-sym (genlocal "rslt")
        line (line-macro ast "// dynamic fn type")]
    (let [arg-syms (conj args (str arity-sym "->closures"))
          num-args (count args)]
      (c-init result-sym
              ["Value *" result-sym ";" line-sep
               "FnArity *" arity-sym " = findFnArity(" (.c-var target)
               ", " num-args ");" line-sep
               "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) { "
               "FnType" num-args " *" fn-var " = (FnType" num-args " *)"
               arity-sym "->fn;" line-sep
               "\n" line
               result-sym " = " fn-var "(" (to-str (interpose arg-syms ", ")) ");" line-sep
               "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) { "
               "FnType1 *" fn-var " = (FnType1 *)" arity-sym "->fn;" line-sep
               "List *" variadic-sym " = empty_list;" line-sep
               (map (reverse (rest arg-syms))
                    (fn [arg-sym]
                      (str variadic-sym " = (List *)listCons("
                           arg-sym ", " variadic-sym ");" line-sep)))
               line result-sym " = " fn-var "(" (str arity-sym) "->closures, (Value *)"
               variadic-sym ");" line-sep
               "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s' at: %s, %d.\\n\", "
               "((Function *)" (.c-var target) ")->name, \"" (ast/file-name ast)
               "\", " (ast/line-number ast) ");\n  abort();\n}\n"
               "dec_and_free("(.c-var target) ", 1);" line-sep]
              [] {} {}
              (ast/file-name ast) (ast/line-number ast)))))

(def symbols-sym (symbol "#symbols"))
(def types-sym (symbol "#types"))
(def protocols-sym (symbol "#protocols"))
(def invoke-sym (rdr/tag 'invoke))
(def Type-sym (rdr/tag 'Type 'core 0))
(def Function-sym (rdr/tag 'Function 'core 0))
(def Container-sym (rdr/tag 'Container 'core 0))
(def Stringable-sym (rdr/tag 'Stringable 'core 0))
(def type-name-sym (rdr/tag 'type-name))
(def =*-sym (rdr/tag '=*))
(def apply*-sym (rdr/tag 'apply*))
(def get-type-sym (rdr/tag 'reified-get-type))
(def extract-sym (rdr/tag 'extract))
(def instance?-sym (rdr/tag 'instance?))
(def new-type-value-sym (rdr/tag 'new-type-value))
(def string-list-sym (rdr/tag 'string-list))
(def list-sym (rdr/tag 'list))
(def has-field-sym (rdr/tag 'has-field))
(def identical-sym (rdr/tag 'identical))
(def Eq-sym (rdr/tag 'Eq))
(def Associative-sym (rdr/tag 'Associative 'core 0))
(def get-symb (rdr/tag 'get))
(def maybe-sym (rdr/tag 'maybe))
(def HashMapNode-sym (rdr/tag 'HashMapNode 'core 0))
(def Hashable-sym (rdr/tag 'Hashable 'core 0))
(def sha1-sym (rdr/tag 'sha1))
(def sha1-update-sym (rdr/tag 'sha1-update))
(def sha1-init-sym (rdr/tag 'sha1-init))
(def sha1-finalize-sym (rdr/tag 'sha1-finalize))
(def sha1-update-type-sym (rdr/tag 'sha1-update-type))
(def assoc*-sym (rdr/tag 'assoc*))
(def make-value-sym (rdr/tag 'make-value))
(def store-sym (rdr/tag 'store))
(def reified-type-args-sym (rdr/tag 'reified-type-args))
(def nth-sym (rdr/tag 'nth))

(defn call-dyn-unknown-type [target args ast]
  ;; TODO: eventually, we maight be able to establish some constraints for 'target'
  (let [num-args (count args)
        num-invoke-args (inc num-args)]
    (for [arity-sym (genlocal "arity")
          variadic-sym (genlocal "dynArgs")
          fn-sym (genlocal "fn")
          result-sym (genlocal "rslt")
          invoke-arity-sym (lookup-core-fn-arity invoke-sym num-invoke-args)
          _ (comp (sm/update-in-val [.constants .other 'dyn-unknown-sites] inc)
                  (sm/assoc-in-val [.constants .other 'dyn-unknown-sites] 1))
          line (line-macro ast "// dynamic unknown type")]
      (let [arg-syms (conj args (str arity-sym "->closures"))]
        (c-init result-sym
                [line "Value *" result-sym ";" line-sep
                 "if((" (.c-var target) ")->type != FunctionType) {" line-sep
                 result-sym " = " invoke-arity-sym "("
                 (to-str (interpose (list* "(List *)0" (.c-var target) args) ", ")) ");"
                 line-sep "} else {" line-sep

                 "FnArity *" arity-sym " = findFnArity(" (.c-var target) ", " num-args ");" line-sep
                 "if(" arity-sym " != (FnArity *)0 && !" arity-sym "->variadic) {" line-sep
                 "FnType" num-args " *" fn-sym " = (FnType" num-args " *)" arity-sym "->fn;"
                 line-sep
                 result-sym " = " fn-sym "(" (to-str (interpose arg-syms ", ")) ");" line-sep
                 "} else if(" arity-sym " != (FnArity *)0 && " arity-sym "->variadic) {" line-sep
                 "FnType1 *" fn-sym " = (FnType1 *)" arity-sym "->fn;" line-sep
                 "List *" variadic-sym " = empty_list;" line-sep
                 (map (reverse (rest arg-syms))
                      (fn [arg-sym]
                        (str variadic-sym " = (List *)listCons("
                             arg-sym ", " variadic-sym ");" line-sep)))
                 result-sym " = " fn-sym "(" (str arity-sym) "->closures, (Value *)"
                 variadic-sym ");" line-sep
                 "} else {" line-sep "fprintf(stderr, \"\\n*** no arity found for '%s'.\\n\", "
                 "((Function *)" (.c-var target) ")->name"
                 ");" line-sep "  abort();" line-sep "}" line-sep
                 "dec_and_free("(.c-var target) ", 1);" line-sep "}" line-sep]
                [] {} {}
                (ast/file-name ast) (ast/line-number ast))))))

(defn call-invoke [target args ast]
  (let [num-args (inc (count args))
        target-type (expr-type-num target)]
    (for [_ (sm/when-not (= UnknownType target-type))
          invoke-info (get-proto-impl Function-sym invoke-sym num-args target-type)
          _ (comp (sm/update-in-val [.constants .other 'invoke-sites] inc)
                  (sm/assoc-in-val [.constants .other 'invoke-sites] 1))
          constraints (arg-constraints (cons target (seq (.args ast)))
                                       (cons target args)
                                       (.param-constraints invoke-info)
                                       (ast/file-name ast) (ast/line-number ast))
          result-sym (genlocal "rslt")
          line (line-macro ast "// call invoke")]
      (c-init result-sym
              [line "Value *" result-sym " = ((FnType" num-args " *)(((FnArity *)" (.c-var invoke-info) ")->fn))("
               (interpose (conj (cons (.c-var target) (map args .c-var))
                                "empty_list") ", ") ");" line-sep]
              [] {} (assoc constraints
                      result-sym (.result-constraints invoke-info))
              (ast/file-name ast) (ast/line-number ast)))))

(defn update-last [asts f]
  (either (empty? asts)
          (let [[tail & init] (-> asts
                                  (filter produces-code?)
                                  reverse)]
            (-> (f tail)
                (cons init)
                reverse
                vec))))

(defn make-bindings [params args]
  (-> (zip-lists (seq params) (seq args))
      (map (fn [[param val]]
             (ast/binding-ast param val)))
      (vec)))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          ast (extract (update-in ast [.call-target]
                                  (fn [target-ast]
                                    ((instance? Symbol target-ast)
                                     (rdr/tag target-ast)
                                     target-ast))))]
      ;; TODO: use deftypes for each of the different kind of call sites.
      (comp (for [new-ast (inline-expr (.call-target ast) (.args ast))
                  call-site (emit new-ast)]
              (c-init (.c-var call-site) (.init call-site) (.decl call-site)
                      (.refs-map call-site)
                      (.constraints call-site)
                      (ast/file-name ast) (ast/line-number ast)))
            (flat-map (-> (.args ast)
                          (filter produces-code?)
                          (traverse emit))
                      (fn [args]
                        (comp (emit-call-expr (.call-target ast) args ast)
                              (for [target (emit (.call-target ast))
                                    call-site (comp (call-static-fixed target args ast)
                                                    (call-static-variadic target args ast)
                                                    (call-invoke target args ast)
                                                    (call-dyn-fn-value target (map args .c-var) ast)
                                                    (call-dyn-unknown-type target (map args .c-var) ast))]
                                (comp* target (comp args [call-site])))
                              (compilation-error "Could not compile call site at:"
                                                 file-name line-number)))))))

  (emit-defined-value [fn-val defined-sym]
    (comp (for [[type-sym type-syms] (sm/when (and (= (.call-target fn-val) 'comp*)
                                                   (maybe (.args fn-val))))
                ns-path (sym-ns-path type-sym)
                type-info (get-type-info ns-path type-sym)
                :when-not (empty? type-info)
                other-types-info (traverse (.args type-syms)
                                           (fn [sym]
                                             (for [ns-path (sym-ns-path sym)
                                                   type-info (get-type-info ns-path sym)
                                                   :when-not (empty? type-info)]
                                               type-info)))
                :let [all-types-info (comp* type-info other-types-info)
                      reified-type-num (extract rdr/type-counter)
                      x* (rdr/tag "#x")
                      y* (rdr/tag "#y")]
                _ (sm/assoc-in-val [.modules (ast/file-name defined-sym) .types defined-sym]
                                   reified-type-num)
                _ (sm/assoc-in-val [.type-maps reified-type-num] (TypeInfo defined-sym all-types-info))
                expr (emit-defined-value
                      (ast/reified
                       reified-type-num
                       {Type-sym
                        [[instance?-sym
                          [(ast/fn-arity-ast
                            (str defined-sym "_instance_QMARK_") (FnValPtr "")
                            (ast/params [x* y*]) ""
                            [(ast/and-ast
                              [(ast/call-ast (rdr/tag 'some)
                                              [(ast/call-ast list-sym (vec (keys all-types-info)))
                                               (ast/call-ast (rdr/tag 'partial)
                                                             [=*-sym
                                                              (ast/call-ast get-type-sym [y*])])])
                               (ast/call-ast maybe-sym [y*])])])]]]})
                      defined-sym)]
            expr)
          (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
                fn-context (reset-fn-context init-fn-context)
                value (emit fn-val)
                var (comp (map (lookup-declaration defined-sym) .c-var)
                          (global-var defined-sym "var"))
                init-fn-context (reset-fn-context fn-context)
                _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
                _ (new-module-def defined-sym (c-code var [] [] {}
                                                      {var (expr-constraints value)}))]
            [(c-init var [(.init value)
                          var " = " (.c-var value) ";" line-sep
                          var "->refs = -1;" line-sep "\n#\n"]
                     [(.decl value) "Value *" var ";\n"]
                     (.refs-map value)
                     (.constraints value)
                     (ast/file-name fn-val) (ast/line-number fn-val))])))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint))

  (replace-syms [ast subs]
    (for [target (replace-syms (.call-target ast) subs)
          args (traverse (.args ast) (fn [ast]
                                       (replace-syms ast subs)))]
      (ast/call-ast target (vec args))))

  (inline-expr [ast arg-asts]
    ;; TODO: remove the hard-coded check for 'new-sm
    (comp (for [_ (sm/when (= (.call-target ast) 'new-sm))
                f-ast (sm/when (first (.args ast)))
                new-ast (inline-expr f-ast arg-asts)]
            new-ast)
          (for [new-call-target (inline-expr (.call-target ast) (.args ast))
                new-ast (inline-expr new-call-target arg-asts)]
            new-ast)))

  (replace-bound-vars [ast subs]
    (ast/call-ast (replace-bound-vars (.call-target ast) subs)
                  (map (.args ast) (fn [ast]
                                     (replace-bound-vars ast subs))))))

(defprotocol AllSyms
  (all-symbols [ast]
    (assert-result l (instance? Vector l))
    [ast]))

(extend-type C-expr
  C-Code
  (expr-constraints [expr]
    (either (get (.constraints expr) (.c-var expr))
            top-type))

  Emitter
  (bind-list [list-var params]
    (let [file-name (ast/file-name params)
          line-num (ast/line-number params)
          list-constraint (update-path list-constraint file-name line-num)
          fixed-count (count (.fixed params))
          tail-sym (either (.variadic params)
                           (rdr/tag "#tail"))
          items-constraints (extract-items-constraints (expr-constraints list-var))
          list-var (.refs-map list-var (dissoc (.refs-map list-var) (.c-var list-var)))]
      (for [tail-binding (bind tail-sym)
            _ (comp (sm/when (empty? (.init list-var)))
                    (set-sym (.c-var list-var) list-var))
            _ (constrain-sym tail-sym list-constraint)
            :let [tail-var (-> tail-binding .vars first extract)]
            r (comp (sm/when (and (= 0 fixed-count)
                                  (maybe (ParamBinding [(.c-var list-var)]
                                                       [list-var
                                                        (c-init tail-var ["Value *" tail-var " = seq(empty_list, "
                                                                          (.c-var list-var) ");" line-sep]
                                                                [] {(.c-var list-var) 1}
                                                                {tail-var list-constraint}
                                                                file-name line-num)]))))
                    (for [dest-args (genlocal "destArgs")
                          fixed-bindings (map (traverse (.fixed params) bind) vec)
                          :let [fixed-vars (flat-map fixed-bindings .vars)
                                fixed-exprs (map fixed-vars (fn [var]
                                                              (c-init var [] [] {} {}
                                                                      file-name line-num)))
                                tail-expr (c-init tail-var [] [] {} {tail-var list-constraint}
                                                  file-name line-num)]
                          _ (traverse fixed-exprs (fn [expr]
                                                    (set-sym (.c-var expr) expr)))
                          _ (set-sym tail-var tail-expr)]
                      (ParamBinding [(.c-var list-var)]
                                    (comp [list-var
                                           (c-code ""
                                                   (destruct-seq (.c-var list-var)
                                                                 (conj fixed-vars tail-var)
                                                                 dest-args file-name line-num)
                                                   [] {(.c-var list-var) 1} {})]
                                          (conj fixed-exprs tail-expr)
                                          (flat-map fixed-bindings .destruct)
                                          (.destruct tail-binding)))))]
        r))))

(extend-type ast/params-ast
  AllSyms
  (all-symbols [params]
    (comp (flat-map (.fixed params) all-symbols)
          (either (map (.variadic params) all-symbols)
                  [])))

  Emitter
  (get-param-constraints [params constraint-map]
    (map (traverse (.fixed params) (fn [param]
                                     (get-param-constraints param constraint-map)))
         (fn [items-constraints]
           (-> (ItemsConstraint empty-list empty-list nothing "")
               (update-path (ast/file-name params) (ast/line-number params))
               (.items-constraints items-constraints)))))

  (bind [params]
    (for [param-var (genlocal "arg")
          destruct (bind-list (c-code param-var [] [] {} {})
                              params)]
      destruct))

  (bind [params evalled]
    (bind-list evalled params))

  (replace-bound-vars [ast subs]
    (let [new-fixed (map (.fixed ast) (fn [param]
                                        (replace-bound-vars param subs)))]
      (ast/params-ast new-fixed (map (.variadic ast) (fn [v]
                                                       (replace-bound-vars v subs)))))))


(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (for [val-var (emit (.val ast))
          bound-var (bind (.binding ast) val-var)]
      bound-var)))

(defn merge-constraints [c1 c2]
  (comp c1 c2))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals get-syms
          bindings (traverse (.bindings ast) emit)
          body-exprs (traverse (.body ast) emit)
          :let [code (collapse-expressions (comp (flat-map bindings .destruct) body-exprs))]
          result-var (either (map (= "" (.c-var code)) sm/state-maybe)
                             (genlocal "let_rslt"))
          moar-constraints (traverse (zip-lists (.bindings ast) bindings)
                                     (fn [[binding-ast param-binding]]
                                       (for [binding-constraint (get-param-constraints (.binding binding-ast)
                                                                                       (.constraints code))]
                                         (either (and (instance? ItemsConstraint binding-constraint)
                                                      (let [[var] (.vars param-binding)]
                                                        (maybe {var binding-constraint})))
                                                 {}))))
          _ (set-syms locals)]
      (let [constraints (reduce moar-constraints (.constraints code)
                                (fn [m1 m2]
                                  (merge-with (partial compose-constraints (ast/file-name ast) (ast/line-number ast))
                                              m1 m2)))]
        (c-init result-var
                [(.init code)
                 (either (= "" result-var)
                         [line-sep "Value *" result-var " = " (.c-var code) ";" line-sep])]
                (.decl code) (.refs-map code)
                (assoc constraints result-var (expr-constraints code))
                (ast/file-name ast) (ast/line-number ast)))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (comp (map (lookup-declaration defined-sym) .c-var)
                    (global-var defined-sym "var"))
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          _ (new-module-def defined-sym (c-code var [] [] {}
                                                {var (expr-constraints value)}))]
      [(c-init var [(.init value)
                    var " = " (.c-var value) ";" line-sep
                    var "->refs = -1;" line-sep "\n#\n"]
               [(.decl value) "Value *" var ";\n"]
               (.refs-map value)
               {var (expr-constraints value)}
               (ast/file-name ast) (ast/line-number ast))]))

  (tail-call [ast params result-constraint]
    (.body ast (-> ast
                   .body
                   (tail-call params result-constraint))))

  (replace-syms [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (comp (for [binding-ast (sm/when (first bindings))
                          new-val (replace-syms (.val binding-ast) subs)
                          :let [new-subs (reduce (all-symbols (.binding binding-ast))
                                                 subs dissoc)]
                          new-bindings (recur (rest bindings) new-bindings new-subs)]
                      (conj new-bindings (.val binding-ast new-val)))
                    (sm/state-maybe new-bindings)))]
      (for [new-bindings (f (.bindings ast) [] subs)
            new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body)))))

  (inline-expr [ast arg-asts]
    (let [unique-syms (map arg-asts (fn [_] (gensym "#arg")))]
      (-> ast
          (.bindings (comp (make-bindings unique-syms arg-asts)
                           (.bindings ast)))
          (.body (update-last (.body ast) (fn [ast]
                                            (ast/call-ast ast unique-syms))))
          (sm/state-maybe))))

  (replace-bound-vars [ast subs]
    (let [f (fn recur [bindings new-bindings subs]
              (either (for [binding-ast (first bindings)]
                        (let [new-val (replace-bound-vars (.val binding-ast) subs)
                              new-subs (reduce (all-symbols (.binding binding-ast))
                                               subs (fn [new-subs sym]
                                                      (assoc new-subs sym (rdr/tag (str "#" sym)))))
                              [new-bindings new-subs] (recur (rest bindings) new-bindings new-subs)]
                          [(conj new-bindings
                                 (ast/binding-ast (replace-bound-vars (.binding binding-ast)
                                                                      new-subs)
                                                  new-val))
                           new-subs]))
                      [new-bindings subs]))]
      (let [[new-bindings new-subs] (f (.bindings ast) empty-list subs)
            new-body (map (.body ast) (fn [ast]
                                        (replace-bound-vars ast new-subs)))]
        (ast/let-ast (vec new-bindings) (vec new-body))))))


(defn index [coll]
  (let [coll (seq coll)]
    (zip-lists (range (count coll)) coll)))

(defn closure-reified-value [type-num impl-fns file-name line-number]
  (let [inits (map impl-fns .init)]
    (for [reified-sym (genlocal "reifiedDyn")
          :when-not (every inits empty?)]
      (c-init reified-sym
              [inits
               "Value *" reified-sym " = (Value *)malloc_reified("
               (count impl-fns) ");" line-sep
               "((ReifiedVal *)" reified-sym ")->type = " type-num ";" line-sep
               "((ReifiedVal *)" reified-sym ")->implCount = "
               (count impl-fns) ";" line-sep
               "((ReifiedVal *)" reified-sym ")->typeArgs = (Value *)0;" line-sep
               (-> impl-fns
                   (map .c-var)
                   (index)
                   (map (fn [[index sym]]
                          ["((ReifiedVal *)" reified-sym
                           ")->impls[" index "] = (Value *)" sym ";" line-sep])))]
              (map impl-fns .decl)
              (apply merge-with + (map impl-fns .refs-map))
              {reified-sym (TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>") nothing
                                           reified-sym)}
              file-name line-number))))

(defn static-reified-value [type-num impl-fns]
  (for [reified-sym (global-var "reifiedStatic")
        reified-ptr (global-var "reifiedPtr")]
    (c-code reified-ptr
            []
            [(map impl-fns .decl)
             "ReifiedVal " reified-sym " = {"
             type-num ", -1, (Value *)0, 0, {}};" line-sep
             "Value *" reified-ptr " = (Value *)&" reified-sym ";" line-sep]
            {} {reified-ptr (TypeConstraint {type-num #{}} empty-list (symbol "<Reified Type Value>") nothing
                                         reified-ptr)})))

(defprotocol ArityType
  (closure-arity? [_]
    (assert-result x (instance? Maybe x))
    nothing)
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (assert-result x (instance? sm/new-sm x))))

(defn new-static-arity
  ([fn-ptr num-params arity-var result-constraints]
   (assert (instance? FnValPtr fn-ptr))
   (assert (instance? ResultConstraint result-constraints))
   (assert (instance? CFnPtr arity-var))

   (new-static-arity fn-ptr num-params arity-var result-constraints empty-items-constraint))

  ([fn-ptr num-params arity-var result-constraints param-constraints]
   (assert (instance? FnValPtr fn-ptr))
   (assert (instance? ResultConstraint result-constraints))
   (assert (instance? CFnPtr arity-var))

   (for [_ (sm/assoc-in-val [.fns fn-ptr num-params]
                            (StaticArityInfo arity-var
                                             param-constraints
                                             (.assertion result-constraints)))]
     '_)))

(deftype StaticArity [arity-fn-var c-fn param-count var-info param-constraints result-constraints]
  (assert (instance? FnValPtr arity-fn-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? C-expr var-info))
  (assert (instance? ItemsConstraint param-constraints))
  (assert (instance? ResultConstraint result-constraints))

  Stringable
  (string-list [_]
    (comp (list "<StaticArity " (str arity-fn-var) " " (str param-count) " ")
          (string-list var-info) " " (str result-constraints) ">"))

  ArityType
  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (for [_ (new-proto-impl proto-sym fn-name param-count dispatch-type-num (.c-var var-info) arity-ast
                            param-constraints result-constraints)]
      var-info)))

(deftype ClosureArity [arity-fn-var params var-info result-constraint]
  (assert (instance? CFnPtr arity-fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? C-expr var-info))
  (assert (instance? ResultConstraint result-constraint))

  Stringable
  (string-list [_]
    (comp (list "<ClosureArity " (str arity-fn-var) " " (str params) " ")
          (string-list var-info)))

  ArityType
  (closure-arity? [arity] (maybe arity))

  (reify-arity [_ dispatch-type-num arity-ast fn-name proto-sym]
    (let [param-count (count params)
          fn-arity-sym (gensym "protoFnArity")
          impl-fn-sym (gensym "protoImpl")]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            [dispArg & args] (traverse (.fixed params) (fn [arg] (genlocal arg "arg")))
            :let [arg-decls (to-str (interpose (conj (map (cons dispArg args)
                                                          (fn [arg] (str "Value *" arg)))
                                                     (str "List *closures"))
                                               ", "))
                  args (to-str (interpose (comp ["closures" dispArg] args) ", "))]
            _ (new-proto-impl proto-sym fn-name param-count dispatch-type-num
                              (ArityValPtr (str "&" fn-arity-sym)) arity-ast
                              empty-items-constraint result-constraint)
            _ (sm/update-in-val [.reify-fn-index] inc)]
        (let [reified-fn (c-code "" []
                                 ["// implementation of " fn-name "\n"
                                  "Value *" impl-fn-sym "(" arg-decls ") {" line-sep
                                  "FnArity *arityPtr = (FnArity *)((ReifiedVal *)" dispArg
                                  ")->impls["
                                  reify-fn-index "];" line-sep
                                  "incRef(" dispArg ", 1);" line-sep
                                  "Value *rval = ((FnType" param-count
                                  " *)arityPtr->fn)(arityPtr->" args ");" line-sep
                                  "dec_and_free(" dispArg ", 1);" line-sep
                                  "return(rval);" line-sep
                                  "};\n\n"
                                  "FnArity " fn-arity-sym " = {FnArityType, -1, " param-count
                                  ", (List *)0, 0, " impl-fn-sym "};" line-sep]
                                 {} {})]
          (comp reified-fn var-info))))))

(defn checking-fn [fn-sym params param-vars arity-fn-var constraints]
  (let [file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)
        constraints-list (.items-constraints constraints)]
    (for [dest-args (genlocal "destArgs")
          checking-fn-var (global-var fn-sym "paramChecker")]
      (either (or (and (.variadic params)
                       (maybe (c-code checking-fn-var
                                      ["Value *" checking-fn-var
                                       "(List *closures, Value *args) {\n"
                                       (destruct-seq 'args (.vars param-vars)
                                                     dest-args file-name line-number)
                                       "return(" arity-fn-var
                                       "(closures, args));\n};\n"]
                                      [] {} {})))
                  (and (every constraints-list (partial = top-type))
                       (maybe (c-code arity-fn-var [] [] {} {}))))
              (c-code checking-fn-var
                      ["Value *" checking-fn-var "("
                       (-> (.vars param-vars)
                           (map (fn [param] (str "Value *" param)))
                           (seq)
                           (conj "List *closures")
                           (interpose ", "))
                       ") {\n"
                       (for [[constraint var] (zip-lists constraints-list
                                                         (.vars param-vars))]
                         (-> constraint
                             (update-var var)
                             (runtime-check top-type file-name line-number)))
                       "return(" arity-fn-var "("
                       (-> (.vars param-vars)
                           (seq)
                           (conj "closures")
                           (interpose ", "))
                       "));\n};\n"]
                      [] {} {})))))

(defn destruct-closures [closure-info]
  (for [destArgs (genlocal "destArgs")]
    (let [closures (-> closure-info
                       (map (fn [[arg]] arg))
                       (seq)
                       (conj "closuresTail")
                       (reverse))
          closure-count (count closures)]
      (cons (c-code ""
                    [(map closures (fn [arg] ["Value *" arg ";" line-sep]))
                     "incRef((Value *)closures, 1);" line-sep
                     "Value **" destArgs "[" closure-count "] = {"
                     (interpose (map closures (fn [arg] ["&" arg])) ", ")
                     "};" line-sep
                     "destructValue(\"\", \"\", (Value *)closures"
                     ", " closure-count ", " destArgs ");" line-sep]
                    [] {} {})
            (map (seq closure-info)
                 (fn [[arg _ constraint]]
                   (c-init arg [] [] {} {arg constraint} "" 0)))))))

(defn emit-closure-arity [fn-sym fn-context c-fn params param-vars body-exprs]
  (assert (instance? CFnPtr c-fn))

  (for [closures (sm/new-sm (fn [s]
                              (assert (instance? GlobalContext s))
                              (let [closures (-> s .fn-context .closed-over .closures)]
                                (and (first closures)
                                     (maybe [closures s])))))
        closures-destruct (destruct-closures closures)
        :let [body (collapse-expressions (comp (.destruct param-vars)
                                               closures-destruct
                                               body-exprs))
              closure-constraints (.constraints body)]
        param-constraints (get-param-constraints params closure-constraints)
        _ (reset-fn-context fn-context)
        arity-var (genlocal fn-sym "dynArity")
        closure-vars (traverse closures (fn [[closed-over sym]]
                                          (for [closure (lookup-sym sym)]
                                            (let [new-constraint (either (get closure-constraints closed-over)
                                                                         top-type)]
                                              (c-code ""
                                                      [arity-var "->closures = listCons((Value *)"
                                                       (.c-var closure) ", (List *)" arity-var
                                                       "->closures);" line-sep]
                                                      [] {(.c-var closure) 1}
                                                      {arity-var (update-var list-constraint (str (.c-var closure)))
                                                       (.c-var closure) new-constraint})))))]
    (let [file-name (ast/file-name fn-sym)
          line-number (ast/line-number fn-sym)
          param-constraints (update-path param-constraints file-name line-number)
          result-constraint (expr-constraints body)
          result-constraint (either (instance? ResultConstraint result-constraint)
                                    (ResultConstraint result-constraint))
          arity-decl [(.decl body)
                      "Value *" c-fn "("
                      (-> (.vars param-vars)
                          (map (fn [param] (str "Value *" param)))
                          (seq)
                          (conj "List *closures")
                          (interpose ", "))
                      ") {\n"
                      "\nwhile (1) {\n"
                      (for [[constraint var] (zip-lists (.items-constraints param-constraints)
                                                        (.vars param-vars))]
                        (-> constraint
                            (update-var var)
                            (runtime-check top-type file-name line-number)))
                      (.init body)
                      line-sep "};};\n"]
          arity-init ["FnArity *" arity-var
                      " = malloc_fnArity();" line-sep
                      arity-var "->count = " (count (.vars param-vars))
                      ";" line-sep
                      arity-var "->variadic = "
                      ((.variadic params) "1" "0") ";" line-sep
                      arity-var "->fn = " c-fn ";" line-sep
                      arity-var "->closures = empty_list;" line-sep]]
      (ClosureArity c-fn params
                    (.constraints (comp* (c-code arity-var arity-init arity-decl {} {})
                                         (comp closure-vars
                                               [(c-init arity-var [] [] {} {}
                                                        file-name line-number)]))
                                  {})
                    result-constraint))))

(defn emit-static-arity [fn-sym fn-context fn-var c-fn params param-vars result-constraint body-exprs]
  (assert (instance? FnValPtr fn-var))
  (assert (instance? ast/params-ast params))
  (assert (instance? ParamBinding param-vars))
  (assert (instance? CFnPtr c-fn))

  (let [body (collapse-expressions (comp (.destruct param-vars) body-exprs))
        result-constraint (expr-constraints body)
        result-constraint (either (instance? ResultConstraint result-constraint)
                                  (ResultConstraint result-constraint))]
    (for [arity-var (global-var fn-sym "staticArity")
          param-constraints (get-param-constraints params (.constraints body))
          checker-fn (checking-fn fn-sym params param-vars c-fn param-constraints)
          _ (reset-fn-context fn-context)]
      (do
        ;; TODO: use this to eliminate unknown return type values
        ;; (and (= UnknownType result-type)
        ;;      (maybe (print-err 'unknown-return-type fn-sym
        ;;                        (ast/file-name body-exprs) (ast/line-number body-exprs))))
        (StaticArity fn-var c-fn ((.variadic params) 'variadic (count params))
                     (c-code (ArityValPtr (str "&" arity-var)) []
                             [(.decl body)
                              "Value *" c-fn "("
                              (-> (.vars param-vars)
                                  (map (fn [param] (str "Value *" param)))
                                  (seq)
                                  (conj "List *closures")
                                  (interpose ", "))
                              ") {\nwhile (1) {\n"
                              (.init body)
                              line-sep "};};\n"
                              (.init checker-fn)
                              "FnArity " arity-var " = {FnArityType, -1, "
                              (count (.vars param-vars))
                              ", (List *)0, " ((.variadic params) "1" "0")
                              ", " (.c-var checker-fn) "};" line-sep]
                             {} {})
                     param-constraints
                     result-constraint)))))

(defn bind-params [params fn-var]
  (assert (instance? ast/params-ast params))

  (comp (for [_ (sm/when (.variadic params))
              param-var (genlocal "arg")
              destruct (bind-list (c-code param-var [] [] {} {}) params)]
          destruct)
        (for [vars (traverse (.fixed params) bind)
              :when-not (empty? vars)
              _ (sm/assoc-in-val [.fn-context .recurse fn-var (count params)] '_)]
          (let [[var & vars] vars
                param-vars (comp* var vars)]
            (ParamBinding (.vars param-vars)
                          (comp (map (.vars param-vars)
                                     (fn [var]
                                       (c-param var [] [] {} {}
                                                (ast/file-name params) (ast/line-number params))))
                                (.destruct param-vars)))))
        (for [_ (sm/assoc-in-val [.fn-context .recurse fn-var 0] '_)]
          (ParamBinding [] []))))

(defn emit-fn-arity
  ([fn-sym fn-var params body]
   (assert (instance? FnValPtr fn-var))

   (flat-map (global-var fn-sym "arityImpl")
             (fn [c-fn]
               (emit-fn-arity fn-sym fn-var params body (StaticFnPtr c-fn)))))

  ([fn-sym fn-var params body c-fn]
   (assert (instance? FnValPtr fn-var))
   (assert (instance? CFnPtr c-fn))
   (assert (min-count body 1))

   (either (and (empty? (filter body produces-code?))
                (maybe (zero sm/state-maybe)))
           (let [file-name (ast/file-name body)
                 line-number (ast/line-number body)
                 param-asserts (filter body assertion?)]
             (for [fn-context (reset-fn-context)
                   result-constraint (map (-> body
                                              (filter return-assertion?)
                                              (map .assertion)
                                              (traverse to-constraint))
                                          (fn [constraints]
                                            (let [result-type (update-sym (comp* top-type constraints)
                                                                          "<result value>")]
                                              (and (= bottom-type result-type)
                                                   (do
                                                     (apply print-err "Conflicting result assertions"
                                                            (either (= "" file-name)
                                                                    (str " at " file-name ": " line-number))
                                                            "\n"
                                                            (format-path result-type 0))
                                                     (maybe (abort))))
                                              result-type)))
                   _ (comp (get-sym fn-sym)
                           (set-sym fn-sym (c-code fn-var [] [] {}
                                                   {fn-var fn-constraint})))
                   param-vars (bind-params params fn-var)
                   :let [param-vars (either (and (some body (partial instance? ast/inline-ast))
                                                 (maybe (.destruct param-vars [])))
                                            param-vars)]
                   body-exprs (-> body
                                  (filter produces-code?)
                                  ((fn [body] (comp param-asserts body)))
                                  (tail-call (.vars param-vars) result-constraint)
                                  (traverse emit))
                   arity-info (comp (emit-closure-arity fn-sym fn-context c-fn params
                                                        param-vars body-exprs)
                                    (emit-static-arity fn-sym fn-context fn-var c-fn params
                                                       param-vars result-constraint body-exprs))]
               arity-info)))))

(deftype ProtoImplDeclaration [proto-sym fn-name arity-ast arity-var c-fn c-decl]
  (assert (instance? Tagged proto-sym))
  (assert (instance? Tagged fn-name))
  (assert (instance? ArityValPtr arity-var))
  (assert (instance? CFnPtr c-fn))
  (assert (instance? ast/fn-arity-ast arity-ast))
  (assert (instance? Vector c-decl))

  Stringable
  (string-list [_]
    (list "<ProtoImplDeclaration " (str proto-sym) " " (str fn-name) ">")))

(defn declare-impl [type-str type-num [proto-sym fn-name arity-ast]]
  (assert (instance? Integer type-num))

  (let [num-args (count (.params arity-ast))]
    (for [impl-fn-var (global-var fn-name "staticArity")
          arity-impl-var (global-var (str type-str fn-name) "arityImpl")
          c-fn (global-var (str type-str fn-name) "arityFn")
          :let [impl-fn-var (FnValPtr impl-fn-var)
                arity-impl-var (ArityValPtr arity-impl-var)
                c-fn (ProtoDispFnPtr c-fn)]
          dispatcher-info (get-proto-impl proto-sym fn-name num-args 0)
          :let [sym-map (reduce (zip-lists (-> dispatcher-info .ast .params .fixed)
                                           (-> arity-ast .params .fixed))
                                {} (fn [m [old-sym new-sym]]
                                     (assoc m old-sym new-sym)))
                result-assertions (-> dispatcher-info
                                      .ast
                                      .body
                                      (filter return-assertion?))]
          param-assertions (-> dispatcher-info
                               .ast
                               .body
                               (filter assertion?)
                               (traverse (fn [ast]
                                           (replace-syms ast sym-map))))
          :let [arity-ast (.body arity-ast (comp [] param-assertions result-assertions (.body arity-ast)))]
          _ (new-static-arity impl-fn-var num-args c-fn
                              (.result-constraints dispatcher-info))
          _ (new-proto-impl proto-sym fn-name num-args type-num arity-impl-var arity-ast
                            empty-items-constraint
                            (.result-constraints dispatcher-info))]
      (ProtoImplDeclaration proto-sym fn-name
                            arity-ast
                            arity-impl-var c-fn
                            ["Value *" c-fn "("
                             (interpose (cons "List *closures"
                                              (seq (map (-> arity-ast .params .fixed)
                                                        (fn [param]
                                                          (str "Value *")))))
                                        ", ")
                             ");\n"
                             "FnArity *" arity-impl-var ";\n"]))))

(defn update-param-constraint [constraint sym]
  ;; (assert (instance? Constraints constraint))
  (-> constraint
      (update-path (ast/file-name sym) (ast/line-number sym))
      (update-sym sym)))

(defn emit-impl [type-str type-num impl-decl]
  (assert (instance? ProtoImplDeclaration impl-decl))

  (let [[proto-sym fn-sym arity-ast arity-var c-fn] (type-args impl-decl)
        params (.params arity-ast)
        [disp-param] (.fixed params)
        num-args (count params)
        file-name (ast/file-name fn-sym)
        line-number (ast/line-number fn-sym)]
    (for [
          ;; _ (debug 'impl type-str fn-sym num-args file-name line-number)
          disp-constraint (comp (for [_ (sm/get-in-val [.constants .type-names type-num])
                                      ;; TODO: this needs to be factored out
                                      constraint (type-constraint type-num file-name line-number)]
                                  (update-param-constraint constraint disp-param))
                                (sm/state-maybe top-type))
          ext-fn (comp (emit-fn-arity (rdr/tag (str type-str fn-sym))
                                      (.fn-var arity-ast)
                                      params
                                      (comp [disp-constraint]
                                            (.body arity-ast))
                                      c-fn)
                       (compilation-error "Could not compile protocol fn:"
                                          (str "'" fn-sym "' in")
                                          (str file-name ",") line-number))
          reified (reify-arity ext-fn type-num arity-ast fn-sym proto-sym)
          ;; _ (debug "---------")
          ]
      (-> reified
          (.c-var arity-var)
          (.init (either (or (empty? (.decl reified))
                             (and (instance? StaticArity ext-fn)
                                  (maybe (.init reified))))
                         [(.init reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))
          (.decl (either (or (empty? (.decl reified))
                             (and (instance? ClosureArity ext-fn)
                                  (maybe (.decl reified))))
                         [(.decl reified)
                          "FnArity *" arity-var " = " (.c-var reified) ";\n"]))))))

(defn extend-type* [ast type-num]
  (assert (instance? Integer type-num))
  (let [impl-arities (for [[proto-sym impl-fns] (seq (.impls ast))
                           [fn-name arities] (seq impl-fns)
                           impl-arity arities]
                       [proto-sym fn-name (.fn-var impl-arity (FnValPtr (str (.fn-var impl-arity))))])]
    (comp (sm/when (empty? impl-arities))
          (for [type-str (comp (map (sm/get-in-val [.constants .type-names type-num])
                                    (fn [type]
                                      (str type "_")))
                               (sm/state-maybe (str "_" type-num "_")))
                _ (traverse (keys (.impls ast))
                            (fn [protocol-name]
                              (comp (get-protocol protocol-name)
                                    (compilation-error "Invalid protocol:" protocol-name "in"
                                                       (str (ast/file-name ast) ",")
                                                       (ast/line-number protocol-name)))))
                ;; TODO: make sure the proto-name/fn-name exists
                ;; especially that the fn-name doesn't exist in a different proto-name
                impl-arities (traverse impl-arities (partial declare-impl type-str type-num))
                [head-fn & fns] (traverse impl-arities (partial emit-impl type-str type-num))]
            (cons (.decl head-fn [(map impl-arities .c-decl) (.decl head-fn)])
                  fns)))))

(extend-type ast/reify-ast
  Emitter
  (emit [ast]
    (let [reified-type-num (.type-num ast)]
      (for [reify-fn-index (sm/get-val .reify-fn-index)
            _ (sm/set-val .reify-fn-index 0)
            impl-fns (extend-type* ast reified-type-num)
            _ (sm/set-val .reify-fn-index reify-fn-index)
            reified-result (comp (closure-reified-value reified-type-num impl-fns
                                                        (ast/file-name ast) (ast/line-number ast))
                                 (static-reified-value reified-type-num impl-fns))]
        reified-result)))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-in-val [.rt-init .fn-context])
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          init-fn-context (reset-fn-context fn-context)
          _ (sm/assoc-in-val [.rt-init .fn-context] init-fn-context)
          value (comp (map (lookup-declaration defined-sym)
                           (fn [c-info]
                             (c-code (.c-var value) [(.init value) "\n" (.c-var c-info) " = "
                                                     (.c-var value) ";" line-sep]
                                     (.decl value) (.refs-map value)
                                     {(.c-var value) (expr-constraints value)})))
                      (sm/state-maybe value))
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                {(.c-var value) (expr-constraints value)}))]
      [value]))

  (tail-call [ast params result-constraint]
    (TailCall ast params result-constraint)))


(defn filter-vals [m f]
  (reduce (seq m) {}
          (fn [m [k v]]
            (either (map (f v) (fn [_] (assoc m k v)))
                    m))))

(defn decrement-refs [refs-map [var var-refs]]
  (either (update-in refs-map [var] (fn [refs]
                                      (- refs var-refs)))
          refs-map))

(defprotocol EmitCond
  (emit-cond-clause [clause]
    (let [file-name (ast/file-name clause)
          file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)]
      (for [syms get-syms
            expr (emit clause)
            _ (set-syms syms)]
        (either (and (or (= MaybeType (expr-type-num expr))
                         (= "" (.c-var expr)))
                     (maybe expr))
                (.init expr [(.init expr)
                             "if (" (.c-var expr) "->type != MaybeType) {" line-sep
                             "fprintf(stderr, \"Wrong type of result returned at %s, line %d\\n\", \""
                             file-name "\","
                             (ast/line-number clause)
                             ");" line-sep
                             "fprintf(stderr, \"Expected Maybe, got %s\\n\", extractStr(type_name(empty_list, "
                             (.c-var expr) ")));" line-sep
                             "abort();" line-sep
                             "}" line-sep]))))))

(extend-type rdr/tagged-symbol
  EmitCond
  (emit-cond-clause [clause]
    (for [expr (emit clause)
          constraint (type-constraint (expr-type-num expr)
                                      (ast/file-name clause) (ast/line-number clause))]
      (let [expr-c (expr-constraints expr)]
        (.constraints expr (assoc (.constraints expr)
                             (.c-var expr) (comp constraint expr-c)))))))

(extend-type Symbol
  EmitCond
  (emit-cond-clause [clause]
    (for [expr (emit clause)
          constraint (type-constraint (expr-type-num expr)
                                      (ast/file-name clause) (ast/line-number clause))]
      (let [expr-c (expr-constraints expr)]
        (.constraints expr (assoc (.constraints expr)
                             (.c-var expr) (comp constraint expr-c)))))))

(defn clause-refs [exprs]
  (let [clause-vars (-> exprs
                        (remove (fn [c] (empty? (.init c))))
                        (map .c-var)
                        set)
        refs-maps (map exprs .refs-map)]
    (-> (apply merge-with + refs-maps)
        (remove-keys clause-vars))))

(defn last-init [evalled-clauses result-var]
  (let [last-clause (either (last evalled-clauses)
                            (do
                              (print-err "Booom!!!")
                              (abort)))]
    ;; TODO: only check the constraints that haven't been checked yet
    [(map (seq (.constraints last-clause))
          (fn [[var constraint]]
            (either (and (get (.refs-map last-clause) var)
                         (maybe (runtime-check (update-var constraint (str var)) top-type "" 0)))
                    "")))
     ((= "" (.c-var last-clause))
      (.init last-clause)
      [(.init last-clause)
       result-var " = " (.c-var last-clause) ";" line-sep])]))

(defn cond-clause-init [cond-test result-var [init refs-map] clause]
  (let [refs-map (-> (.refs-map clause)
                     seq
                     (reduce refs-map decrement-refs))]
    [(conj (vec init)
           ;; TODO: only check the constraints that haven't been checked yet
           [(map (seq (.constraints clause))
                 (fn [[var constraint]]
                   (either (and (get (.refs-map clause) var)
                                (maybe (runtime-check (update-var constraint (str var)) top-type "" 0)))
                           "")))
            (.init clause)
            result-var " = " (.c-var clause) ";" line-sep
            cond-test result-var ",\"\",0)) {" line-sep
            (map (seq refs-map) (fn [[c-sym remaining]]
                                  (either (and (= 0 remaining)
                                               (maybe ""))
                                          ["dec_and_free(" c-sym ", " remaining ");" line-sep])))])
     refs-map]))

(defn clause-inits [evalled-clauses cond-test refs-map result-var]
  (let [[clause-inits] (reduce (butlast evalled-clauses)
                               [[] refs-map]
                               (partial cond-clause-init cond-test result-var))]
    clause-inits))

(defn emit-cond-expr [cond-test result-var clauses tail-return]
  (map (-> clauses
           (filter produces-code?)
           (traverse emit-cond-clause))
       (fn [evalled-clauses]
         (let [refs-map (clause-refs evalled-clauses)
               [first-clause] evalled-clauses]
           (c-init result-var
                   ["Value *" result-var ";" line-sep
                    (-> evalled-clauses
                        (clause-inits cond-test refs-map result-var)
                        (conj (last-init evalled-clauses result-var))
                        (interpose [tail-return "} else {" line-sep
                                    "dec_and_free(" result-var ", 1);" line-sep]))
                    (-> (count evalled-clauses)
                        (dec)
                        (repeat (str "}" line-sep)))]
                   (map evalled-clauses .decl) refs-map
                   (assoc (.constraints first-clause)
                     result-var (TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing result-var))
                   (ast/file-name clauses) (ast/line-number clauses))))))

(deftype TailAnd [clauses]
  (assert (instance? List clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailAnd ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "andRslt")
          expr (emit-cond-expr "if (isNothing(" result-var
                               (.clauses ast) (str "return(nothing);" line-sep))]
      expr)))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (either (and (empty? clauses)
                   (maybe (sm/state-maybe empty-c-code)))
              (for [result-var (genlocal "andRslt")
                    expr (emit-cond-expr "if (isNothing(" result-var clauses "")]
                expr))))

  (tail-call [ast params result-constraint]
    (let [clauses (-> (.clauses ast)
                      (filter produces-code?)
                      seq
                      reverse)]
      (either (map (first clauses)
                   (fn [last-clause]
                     (TailAnd (-> (tail-call last-clause params result-constraint)
                                  (cons (rest clauses))
                                  reverse))))
              (TailAnd empty-list))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast (vec new-clauses))))

  (replace-bound-vars [ast subs]
    (ast/and-ast (map (.clauses ast) (fn [ast]
                                       (replace-bound-vars ast subs))))))

(deftype TailOr [clauses]
  (assert (instance? Vector clauses))

  Stringable
  (string-list [expr]
    (comp (list "<TailOr ") (flat-map clauses string-list) (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clauses))
  (ast/line-number [_]
    (ast/line-number clauses))

  Emitter
  (emit [ast]
    (for [result-var (genlocal "orRslt")
          expr (emit-cond-expr "if (!isNothing(" result-var (.clauses ast)
                               (str "return(" result-var ");" line-sep))]
      expr)))

(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (either (and (empty? clauses)
                   (maybe (sm/state-maybe empty-c-code)))
              (flat-map (genlocal "orRslt")
                        (fn [result-var]
                          (emit-cond-expr "if (!isNothing(" result-var clauses
                                          line-sep))))))

  (tail-call [ast params result-constraint]
    (let [clauses (filter (.clauses ast) produces-code?)]
      (TailOr (either (flat-map (last clauses)
                                (fn [last-clause]
                                  (store clauses (dec (count clauses))
                                         (tail-call last-clause params result-constraint))))
                      []))))

  (replace-syms [ast subs]
    (for [new-clauses (traverse (.clauses ast)
                                (fn [ast]
                                  (replace-syms ast subs)))]
      (.clauses ast new-clauses)))

  (replace-bound-vars [ast subs]
    (ast/or-ast (map (.clauses ast) (fn [ast]
                                      (replace-bound-vars ast subs))))))

(deftype TailEither [clause alt result-constraint]

  Stringable
  (string-list [expr]
    (comp (list "<TailEither ") (list ">")))

  ast/FileLineInfo
  (ast/file-name [_]
    (ast/file-name clause))
  (ast/line-number [_]
    (ast/line-number clause))

  Emitter
  (emit [ast]
    (for [cond-val (emit clause)
          alt-val (map (emit alt)
                       (fn [expr]
                         (let [expr (either (and (instance? Tagged alt)
                                                 (maybe (.refs-map expr {})))
                                            expr)]
                           (emit-tail-expr alt result-constraint expr))))
          result-var (genlocal "rslt")]
      (let [cond-rslt (.c-var cond-val)
            refs-map (merge-with + (.refs-map cond-val) (.refs-map alt-val))]
        (c-code ""
                [(.init cond-val)
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 "Value *" result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "return(" result-var ");" line-sep
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val))
                refs-map
                {result-var result-constraint
                 (.c-var cond-val) (TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing (.c-var cond-val))})))))

(extend-type ast/either-ast
  Emitter
  (emit [ast]
    (for [result-var (genlocal "eitherRslt")
          cond-val (emit (.clause ast))
          alt-val (emit (.alt ast))]
      (let [cond-rslt (.c-var cond-val)
            refs-map (-> (merge-with + (.refs-map cond-val) (.refs-map alt-val))
                         (filter-vals (partial < 0)))]
        (c-init result-var
                [(.init cond-val)
                 "Value *" result-var ";" line-sep
                 "if (!isNothing(" cond-rslt ",\"\",0)) {" line-sep
                 result-var " = maybeExtract(" cond-rslt ");" line-sep
                 (map (seq (.refs-map alt-val))
                      (fn [[c-sym remaining]]
                        (either (and (= 0 remaining)
                                     (maybe ""))
                                ["dec_and_free(" c-sym ", " remaining ");" line-sep])))
                 "} else {" line-sep
                 "dec_and_free(" cond-rslt ", 1);" line-sep
                 (.init alt-val)
                 result-var " = " (.c-var alt-val) ";" line-sep
                 "}" line-sep]
                (comp (.decl cond-val) (.decl alt-val)) refs-map
                {(.c-var cond-val) (TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing (.c-var cond-val))}
                (ast/file-name ast) (ast/line-number ast)))))

  (tail-call [ast params result-constraint]
    (TailEither (.clause ast) (.alt ast) result-constraint))

  (replace-syms [ast subs]
    (for [new-ast (replace-syms (.clause ast) subs)
          new-alt (replace-syms (.alt ast) subs)]
      (ast/either-ast new-ast new-alt)))

  (replace-bound-vars [ast subs]
    (ast/either-ast (replace-bound-vars (.clause ast) subs)
                    (replace-bound-vars (.alt ast) subs))))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [;; _ (debug 'main-fn)
          fn-arity (emit-fn-arity (rdr/tag 'main) (FnValPtr "") (.params ast) (.body ast))
          ;; _ (debug "=======")
          result-constraint (map (type-constraint IntegerType "" 0) ResultConstraint)
          _ (new-static-arity (FnValPtr 'main) 1 (.c-fn fn-arity) result-constraint)]
      [(c-code "" [] (.decl (.var-info fn-arity)) {} {})])))


(defn static-fn [fn-sym fn-var arities]
  (assert (instance? FnValPtr fn-var))
  (for [struct-var (global-var fn-sym "fnStruct")
        emitted-arities (traverse arities
                                  (fn [static-arity]
                                    (for [_ (new-static-arity fn-var
                                                              (.param-count static-arity)
                                                              (.c-fn static-arity)
                                                              (.result-constraints static-arity)
                                                              (.param-constraints static-arity))]
                                      (.var-info static-arity))))]
    (let [arity-count (count emitted-arities)]
      (c-code fn-var []
              ["\n// --------- " fn-sym " -------------\n"
               "Value *" fn-var ";\n"
               (map emitted-arities .decl)
               "Function " struct-var " = {FunctionType, -1, \""
               fn-sym "\", " arity-count ", "
               "{" (to-str (interpose (map emitted-arities .c-var)
                                      ", "))
               "}};\n"
               "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
              {} {fn-var fn-constraint}))))

(defn closure-fn [fn-sym fn-var arities]
  (for [_ (sm/when (some arities closure-arity?))
        struct-var (global-var fn-sym "fnStruct")
        line (line-macro fn-sym (str "//creating " fn-sym))]
    (let [arity-count (count arities)
          emitted-arities (map arities .var-info)]
      (c-init (str fn-var)
              [(map emitted-arities .init)
               line "Function *" struct-var " = malloc_function(" arity-count ");" line-sep
               struct-var "->name = \"" fn-sym "\";" line-sep
               struct-var "->arityCount = " arity-count ";" line-sep
               (map (zip-lists (map emitted-arities .c-var)
                               (range arity-count))
                    (fn [[sym index]]
                      (str struct-var "->arities[" index "] = " sym ";" line-sep)))
               "Value *" fn-var " = (Value *)" struct-var ";" line-sep]
              [(map emitted-arities .decl)] (apply merge-with + (map emitted-arities .refs-map))
              (assoc (.constraints (collapse-expressions emitted-arities))
                (str fn-var) fn-constraint)
              (ast/file-name fn-sym) (ast/line-number fn-sym)))))

(defn missing-impl-body [proto-sym fn-sym prototype]
  (comp (filter (.default-body prototype) assertion?)
        (filter (.default-body prototype) return-assertion?)
        [(ast/inline-ast
          'C nothing
          (str "fprintf(stderr,\"*** Could not find implementation of '" proto-sym "/" fn-sym
               " at %s\\n\", ((String *)closures)->buffer);\nabort();\n")
          (ast/file-name fn-sym) (ast/line-number fn-sym))]))

(defn emit-proto-default [protocol-sym fn-sym disp-fn-var prototype]
  (let [body (filter (.default-body prototype) produces-code?)
        body (either (and (empty? body)
                          (maybe (missing-impl-body protocol-sym fn-sym prototype)))
                     (.default-body prototype))]
    (for [arity-impl-var (global-var (str "Default_" fn-sym) "arityImpl")
          :let [arity-impl-var (ProtoDispFnPtr arity-impl-var)]
          static-arity (emit-fn-arity (rdr/tag (str "Default_" fn-sym)) disp-fn-var
                                      (.params prototype)
                                      (comp (remove (.default-body prototype) produces-code?)
                                            body)
                                      arity-impl-var)
          _ (sm/assoc-in-val [.modules (ast/file-name protocol-sym) .protocols protocol-sym fn-sym
                              (.param-count static-arity) 0]
                             (ProtoImpl 0 (.c-var (.var-info static-arity))
                                        (ast/fn-arity (.params prototype) "" body)
                                        (.param-constraints static-arity)
                                        (.result-constraints static-arity)))
          _ (sm/assoc-in-val [.fns (.arity-fn-var static-arity) (.param-count static-arity) .param-constraints]
                             (.param-constraints static-arity))]
      (.decl (.var-info static-arity)))))

(defn create-dispatcher [proto-sym [fn-sym arities]]
  (for [proto-sym-expr (emit (ast/quoted-ast proto-sym))
        fn-sym-expr (emit (ast/quoted-ast fn-sym))

        fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                     (global-var (str "dispFn_" fn-sym) "fn"))
        :let [fn-var (FnValPtr fn-var)]
        arities-info (traverse arities
                               (fn [arity]
                                 (let [arg-count (count (.params arity))]
                                   (for [c-fn (global-var (str "disp_" fn-sym) "dispatcher")
                                         result-constraints (-> arity
                                                                .default-body
                                                                (filter return-assertion?)
                                                                (traverse to-constraint))
                                         _ (new-static-arity fn-var arg-count (ProtoDispFnPtr c-fn)
                                                             (comp* (ResultConstraint top-type)
                                                                    result-constraints)
                                                             empty-items-constraint)]
                                     ["Value *" c-fn "("
                                      (-> (map (range arg-count) (fn [n] (str "Value *arg" n)))
                                          (conj "List *closures")
                                          (interpose ", "))
                                      ");\n"]))))

        _ (new-module-def fn-sym (c-code fn-var [] [] {} {fn-var fn-constraint}))
        default-fns (traverse arities (partial emit-proto-default proto-sym fn-sym fn-var))]
    [(.decl proto-sym-expr)
     (.decl fn-sym-expr)
     "\n// proto fn for " proto-sym "/" fn-sym "\n"
     "\n// --------- " fn-sym " -------------\n"
     "Value *" fn-var ";\n"
     arities-info
     default-fns]))

(defn check-protocol-name [proto-sym]
  ;; Ensure all protocol symbols are unique
  (comp (for [proto-info (sm/get-in-val [.modules (ast/file-name proto-sym) .protocols proto-sym])]
          (do
            (print-err  "Duplicate protocol"
                        (str "'" proto-sym "'") "at"
                        (str (ast/file-name proto-sym) ":")
                        (ast/line-number proto-sym))
            (abort)))
        (sm/state-maybe '_)))

(extend-type ast/protocol-ast
  Emitter
  (emit-definition [ast]
    (let [proto-name (.protocol-sym ast)
          prototype-map (reduce (.prototypes ast) {}
                                (fn [m prototype]
                                  (either (update m (.fn-name prototype)
                                                  (fn [prototypes]
                                                    (conj prototypes prototype)))
                                          (assoc m (.fn-name prototype) [prototype]))))]
      (for [_ (check-protocol-name proto-name)
            decl (traverse (seq prototype-map)
                           (partial create-dispatcher proto-name))]
        [(c-code "" [] decl {} {})]))))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-fn-arity (either (and (= "" (.fn-sym ast))
                                (maybe (rdr/tag 'anon
                                                (ast/file-name (.params ast))
                                                (ast/line-number (.params ast)))))
                           (.fn-sym ast))
                   (FnValPtr (str (.fn-var ast))) (.params ast) (.body ast)))

  (inline-expr [ast arg-asts]
    (sm/state-maybe (ast/let-ast (make-bindings (.fixed (.params ast)) arg-asts)
                                 (.body ast))))

  (replace-syms [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs dissoc)]
      (for [new-body (traverse (.body ast) (fn [ast]
                                             (replace-syms ast subs)))]
        (.body ast (vec new-body)))))

  (replace-bound-vars [ast subs]
    (let [subs (reduce (all-symbols (.params ast)) subs
                       (fn [subs sym]
                         (assoc subs sym (rdr/tag (str "#" sym)))))]
      (-> ast
          (.params (replace-bound-vars (.params ast) subs))
          (.body (map (.body ast) (fn [ast]
                                    (replace-bound-vars ast subs))))))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (comp (for [fn-sym (sm/when (.fn-sym ast))
                ;; _ (debug "=========")
                ;; _ (debug 'fn-sym fn-sym (ast/file-name fn-sym) (ast/line-number fn-sym))
                fn-var (comp (map (lookup-declaration fn-sym) .c-var)
                             (global-var fn-sym "fn"))
                :let [fn-var (FnValPtr fn-var)]
                arities (traverse (map (.arities ast) (fn [arity]
                                                        (-> arity
                                                            (.fn-sym fn-sym)
                                                            (.fn-var fn-var))))
                                  emit)
                fn-expr (comp (closure-fn fn-sym fn-var arities)
                              (static-fn fn-sym fn-var arities))
                ;; _ (debug "---------")
                ]
            fn-expr)
          (for [fn-var (global-var "fn")
                :let [fn-var (FnValPtr fn-var)]
                arities (traverse (.arities ast) emit)
                fn-expr (comp (closure-fn 'anon fn-var arities)
                              (static-fn 'anon fn-var arities))]
            fn-expr)))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (new-module-def defined-sym (c-code (.c-var value) [] [] {}
                                                {(.c-var value) fn-constraint}))]
      [(make-c-code value)]))

  (tail-call [x params result-constraint]
    (TailCall x params result-constraint))

  (inline-expr [ast arg-asts]
    (for [arity (sm/when (-> (.arities ast)
                             (filter (fn [arity]
                                       (= (count arg-asts) (count (.params arity)))))
                             first))
          expr (inline-expr arity arg-asts)]
      expr))

  (replace-syms [ast subs]
    (for [new-arities (traverse (.arities ast)
                                (fn [arity]
                                  (replace-syms arity subs)))]
      (.arities ast (vec new-arities))))

  (replace-bound-vars [ast subs]
    (.arities ast (map (.arities ast) (fn [arity]
                                        (replace-bound-vars arity subs))))))

(extend-type ast/extend-ast
  Emitter
  (emit-definition [ast]
    (let [type-sym (.type ast)]
      (comp (for [ns-path (sym-ns-path (.type ast))
                  type-nums (get-type-numbers (maybe type-sym))
                  fns (map (traverse (seq type-nums) (partial extend-type* ast))
                           flatten)]
              fns)
            (compilation-error "Trying to extend unknown type: "
                               type-sym "at"
                               (str (ast/file-name (.type ast)) ":")
                               (ast/line-number (.type ast)))))))


(deftype constraint-ast [constraint ast]
  ;; TODO; re-enable
  ;; (assert (instance? SymbolConstraints constraint))

  Stringable
  (string-list [_]
    (list "<ExprConstraint " (str constraint) " " (str ast) ">"))

  Emitter
  (replace-syms [_ subs]
    (for [new-ast (replace-syms ast subs)]
      (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (update-sym constraint new-sym))
                                   constraint)]
        (constraint-ast new-constraint new-ast))))

  (replace-bound-vars [_ subs]
    (let [new-constraint (either (for [sym (.sym constraint)
                                         new-sym (get subs sym)]
                                     (update-sym constraint new-sym))
                                 constraint)
          new-ast (replace-bound-vars ast subs)]
      (constraint-ast new-constraint new-ast)))

  (tail-call [_ params return-constraints]
    (constraint-ast constraint (tail-call ast params return-constraints)))

  (emit [_]
    (for [expr (emit ast)]
      (add-constraint expr (-> constraint
                               (update-path (ast/file-name ast) (ast/line-number ast)))
                      (ast/file-name ast) (ast/line-number ast)))))

(defn constructor-expr [new-type-name new-type-constraint type-val-sym fields assertions]
  (let [reified-type-num (extract rdr/type-counter)
        x* (rdr/tag "#x")
        y* (rdr/tag "#y")]
    (ast/definition new-type-name
      [(ast/reified reified-type-num
                    {Type-sym
                     [[type-name-sym
                       [(ast/fn-arity-ast (str new-type-name "_const_type_name") (FnValPtr "")
                                          (ast/params ['_]) ""
                                          [(str "*" new-type-name " constructor*")])]]
                      [instance?-sym
                       [(ast/fn-arity-ast (str new-type-name "_instance_QMARK_") (FnValPtr "")
                                          (ast/params [x* y*]) ""
                                          [(ast/and-ast
                                            [(ast/call-ast =*-sym
                                                            [(ast/call-ast get-type-sym [type-val-sym])
                                                             (ast/call-ast get-type-sym [y*])])
                                             (ast/call-ast maybe-sym [y*])])])]]]

                     Function-sym
                     [[invoke-sym
                       [(ast/fn-arity-ast (str new-type-name "_invoke") (FnValPtr "")
                                          (ast/params (vec (cons '_ (seq fields)))) ""
                                          (comp assertions
                                                [(constraint-ast
                                                  new-type-constraint
                                                  (ast/call-ast new-type-value-sym
                                                                [type-val-sym
                                                                 (ast/call-ast 'vector
                                                                               (vec fields))]))]))]]]

                     Container-sym
                     [[apply*-sym
                       [(ast/fn-arity-ast (str new-type-name "_apply_ST_") (FnValPtr "")
                                          (ast/params ['_ 'fields]) ""
                                          ;; TODO: need field constraints here
                                          [(ast/call-ast new-type-value-sym
                                                          [type-val-sym
                                                           (ast/call-ast 'vec ['fields])])])]]]

                     Stringable-sym
                     [[string-list-sym
                       [(ast/fn-arity (ast/params ['z]) ""
                                      [(ast/call-ast list-sym
                                                     ["<TypeCon " (str new-type-name) " ["
                                                      (to-str (interpose fields ", ")) "]>"])])]]]})])))

(defn type-val-expr [type-sym type-num type-val-sym fields impls]
  (let [x* (rdr/tag "#x")
        y* (rdr/tag "#y")
        field* (rdr/tag "#field")
        ctxt* (rdr/tag "#ctxt")]
    (ast/definition type-val-sym
      [(ast/reified type-num
                    (merge-with comp
                                {Type-sym
                                 [[type-name-sym
                                   [(ast/fn-arity-ast (str type-sym "_type_name") (FnValPtr "")
                                                      (ast/params [x*]) ""
                                                      [(str type-sym)])]]
                                  [has-field-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_has_field") (FnValPtr "")
                                     (ast/params [x* field*]) ""
                                     [(ast/or-ast
                                       (conj (map fields
                                                  (fn [field]
                                                    (ast/call-ast identical-sym
                                                                  [(rdr/tag (str "." field))
                                                                   field*])))
                                             (rdr/tag 'nothing)))])]]]

                                 Eq-sym
                                 [[=*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_EQ_STAR_") (FnValPtr "")
                                     (ast/params [x* y*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast
                                         =*-sym [(ast/call-ast get-type-sym [x*])
                                                 (ast/call-ast get-type-sym [y*])])
                                        (ast/call-ast
                                         =*-sym [(ast/call-ast reified-type-args-sym [x*])
                                                 (ast/call-ast reified-type-args-sym [y*])])
                                        (ast/call-ast maybe-sym [x*])])])]]]

                                 Associative-sym
                                 [[get-symb
                                   [(ast/fn-arity-ast
                                     (str type-sym "_get") (FnValPtr "")
                                     (ast/params [x* field*]) ""
                                     [(ast/and-ast
                                       [(ast/call-ast has-field-sym [x* field*])
                                        (ast/call-ast maybe-sym
                                                      [(ast/call-ast field* [x*])])])])]]]

                                 HashMapNode-sym
                                 [[assoc*-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_assoc_STAR_") (FnValPtr "")
                                     (ast/params [x* field* 'new-value '_ '_]) ""
                                     [(ast/call-ast
                                       extract-sym
                                       [(ast/or-ast
                                         [(ast/and-ast
                                           [(ast/call-ast has-field-sym [x* field*])
                                            (ast/call-ast
                                             maybe-sym
                                             [(ast/call-ast field* [x* 'new-value])])])
                                          (ast/call-ast maybe-sym [x*])])])])]]]

                                 Hashable-sym
                                 [[sha1-update-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1_update") (FnValPtr "")
                                     (ast/params [x* ctxt*]) ""
                                     [(ast/call-ast sha1-update-type-sym [x* ctxt*])
                                      (ast/call-ast
                                       sha1-update-sym
                                       [(ast/call-ast reified-type-args-sym [x*]) ctxt*])])]]
                                  [sha1-sym
                                   [(ast/fn-arity-ast
                                     (str type-sym "_sha1") (FnValPtr "")
                                     (ast/params [x*]) ""
                                     [(ast/call-ast
                                       sha1-finalize-sym
                                       [(ast/call-ast
                                         sha1-update-sym
                                         [x* (ast/call-ast sha1-init-sym [])])])])]]]}
                                impls))])))

(defn declare-getters [new-type-name fields]
  (traverse fields
            (fn [field]
              (let [getter-sym (rdr/tag (str "." field) 'core 0)]
                (comp (map (sm/get-in-val [.modules 'core .protocols Type-sym getter-sym]) (fn [_] []))
                      (create-dispatcher Type-sym
                                         [getter-sym
                                          [(ast/prototype getter-sym
                                                          (ast/params [(symbol "#x")])
                                                          (ast/block-comment "" 0 [])
                                                          [(FieldConstraint getter-sym
                                                                            ""
                                                                            empty-list
                                                                            (maybe (symbol "#x"))
                                                                            "")])
                                           (ast/prototype getter-sym
                                                          (ast/params [(symbol "#x") (symbol "#y")])
                                                          (ast/block-comment "" 0 [])
                                                          [(FieldConstraint getter-sym
                                                                            ""
                                                                            empty-list
                                                                            (maybe (symbol "#x"))
                                                                            "")])]]))))))

(defn create-getters [sym constraint fields field-constraints]
  (let [type-value (rdr/tag "#value")]
    {Type-sym
     (map (zip-lists (seq fields) (range (count fields)) field-constraints)
          (fn [[field field-index field-constraint]]
            (let [new-value (rdr/tag (str field))
                  extract-field (ast/call-ast extract-sym
                                              [(ast/call-ast nth-sym
                                                             [(ast/call-ast reified-type-args-sym
                                                                            [type-value])
                                                              field-index])])
                  extract-field (either (map (= top-type field-constraint)
                                             (fn [_]
                                               [extract-field]))
                                        [(constraint-ast field-constraint extract-field)])
                  set-field [(update-sym field-constraint field)
                             (constraint-ast constraint
                                             (ast/call-ast make-value-sym
                                                           [type-value
                                                            (ast/call-ast extract-sym
                                                                          [(ast/call-ast
                                                                            store-sym
                                                                            [(ast/call-ast
                                                                              reified-type-args-sym
                                                                              [type-value])
                                                                             field-index new-value])])]))]]
              [(rdr/tag (str "." field))
               [(ast/fn-arity-ast (str sym "_" field) (FnValPtr "")
                                  (ast/params [type-value new-value]) ""
                                  set-field)
                (ast/fn-arity-ast (str sym "_" field) (FnValPtr "")
                                  (ast/params [type-value]) ""
                                  extract-field)]])))}))

(defn destruct-impl-fields [sym ast field-types arity]
  (let [[type-value-parameter] (.fixed (.params arity))
        return-assertions (filter (.body arity) return-assertion?)
        new-body (comp return-assertions
                       [(ast/assert-type (.sym ast) type-value-parameter)]
                       (filter (.body arity) assertion?)
                       [(ast/let-ast [(ast/binding (.fields ast)
                                        (constraint-ast field-types (ast/call-ast
                                                                     reified-type-args-sym
                                                                     [type-value-parameter])))]
                                     (remove (.body arity) assertion?))])]
    (-> arity
        (.body new-body)
        (.fn-sym (str sym "_" fn-name)))))

(defn destructure-fields [sym ast field-types]
  (let [impls (comp* {} (filter (.impls ast)
                                (partial instance? HashMap)))]
    (map-vals impls
              (fn [impl-arities]
                (map impl-arities
                     (fn [[fn-name arities]]
                       [fn-name (map arities
                                     (partial destruct-impl-fields sym ast field-types))]))))))

(extend-type ast/type-ast
  Emitter
  (emit-definition [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)
          sym (.sym ast)
          fields (.fixed (.fields ast))
          const-arity-index (inc (count fields))
          field-assertions (filter (.impls ast) assertion?)]
      (comp (for [_ (sm/get-in-val [.modules file-name .types sym])
                  _ (compilation-error (str "Trying to re-define type name: '" sym "' in module "
                                            (either (and (= file-name 'core)
                                                         (maybe "$TOCCATA_DIR/core.toc"))
                                                    file-name)
                                            ", " line-number))]
              "")

            (for [type-val-sym (global-var "#type-val-")
                  :let [type-val-sym (rdr/tag type-val-sym file-name line-number)
                        type-num (extract rdr/type-counter)
                        type-map {type-num (-> fields
                                               (map (fn [name]
                                                      (symbol
                                                       (str "." name))))
                                               set)}
                        new-type-constraint (TypeConstraint type-map (list [file-name line-number])
                                                            sym nothing "")]
                  _ (sm/assoc-in-val [.type-maps type-num] (TypeInfo sym type-map))
                  _ (sm/assoc-in-val [.modules file-name .types sym] type-num)
                  _ (sm/assoc-in-val [.constants .type-names type-num] (str sym))
                  type-val-decl (emit-definition (ast/declaration-ast type-val-sym))
                  getters (declare-getters sym fields)

                  type-constructor (emit-definition
                                    (constructor-expr sym new-type-constraint type-val-sym fields
                                                      field-assertions))
                  field-maps (traverse field-assertions
                                       (fn [assertion]
                                         (map (to-constraint (.assertion assertion))
                                              (fn [c]
                                                {(.sym (.assertion assertion)) c}))))
                  :let [field-map (reduce field-maps {} (fn [m field-map]
                                                          (merge-with (partial compose-constraints
                                                                               file-name line-number)
                                                                      m field-map)))
                        field-constraints (ItemsConstraint
                                           (map (seq fields) (fn [field]
                                                               (either (get field-map field)
                                                                       top-type)))
                                           empty-list (maybe (symbol (str sym "-field-constraints"))) "")
                        impls (merge-with comp
                                          (create-getters sym new-type-constraint fields
                                                          (.items-constraints field-constraints))
                                          (destructure-fields sym ast field-constraints))]
                  type-val-def (emit-definition (type-val-expr sym type-num type-val-sym
                                                               fields impls))

                  const-type-num (map (sm/get-in-val [.modules file-name .values sym])
                                      expr-type-num)
                  _ (sm/assoc-in-val [.modules 'core .protocols Function-sym invoke-sym const-arity-index
                                      const-type-num .result-constraints]
                                     (ResultConstraint new-type-constraint))]
              (comp type-val-decl
                    [(c-code "" [] (flatten getters) {} {})]
                    type-constructor
                    type-val-def))))))

(def global-context (GlobalContext (FunctionArityContext {} 0 {} {} empty-closures)
                                   (RuntimeInit (FunctionArityContext {} 0 {} {} empty-closures)
                                                [])
                                   {}                       ;; map for module info
                                   {}                       ;; map for static fns
                                   {}                       ;; map for namespaces
                                   (ConstantValues {} {} {} type-names {})
                                   0                        ;; reify-fn-index
                                   core-types               ;; type-maps
                                   ))

(def logger (agent ""))
(defn log [& msg]
  (send logger (fn [_]
                 (apply print-err msg))))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defprotocol FreeGlobal
  (free-global [_]
    (assert-result x (instance? Vector x))
    []))

(extend-type c-init
  FreeGlobal
  (free-global [c-info]
    ["freeGlobal(" (.c-var c-info) ");" line-sep]))

(defn gather-protocols [file-name]
  (for [protocols (sm/get-in-val [.modules file-name .protocols])
        expr (encode protocols "protos_")
        _ (traverse (for [[proto-sym proto-fns] (seq protocols)
                          [fn-sym arities] (seq proto-fns)]
                      [proto-sym fn-sym arities])
                    (fn [[proto-sym fn-sym arities]]
                      (for [disp-fn (sm/get-in-val [.modules file-name .values fn-sym])
                            :let [fn-var (.c-var disp-fn)]
                            c-fns (traverse (keys arities)
                                            (fn [arg-count]
                                              (for [disp-arity (lookup-static-arity-info fn-var arg-count)
                                                    arity-var (global-var "arity")]
                                                [arg-count arity-var (.c-var disp-arity)])))
                            struct-var (global-var "fn")]
                        (write-strings
                         [(map c-fns
                               (fn [[arg-count arity-var c-fn]]
                                 (let [impls (extract (get arities arg-count))]
                                   ["Value *" c-fn "(List *"
                                    (interpose (cons "closures" (map (range arg-count) (partial str "Value *arg")))
                                               ",")
                                    ") {\nFnArity *arity;\n"
                                    "switch (arg0->type) {\n"
                                    (map (seq (dissoc impls 0))
                                         (fn [[type-num arity-info]]
                                           ["case " (str type-num) ": arity = " (.c-var arity-info) ";\nbreak;\n"]))
                                    ;; TODO: search for impl in protos hash-map
                                    "default: arity = " (.c-var (extract (get impls 0))) ";\n"
                                    "}\n"
                                    "FnType" arg-count " *_fn = (FnType" arg-count " *)arity->fn;\n" 
                                    "return(_fn(arity->closures, " (-> (map (range arg-count) (partial str "arg"))
                                                                       (interpose ", "))
                                    "));\n}\n"
                                    "FnArity " arity-var " = {FnArityType, -1, "
                                    arg-count
                                    ", (List *)0, 0, " c-fn "};\n"])))
                          "Function " struct-var " = {FunctionType, -1, \""
                          fn-sym "\", " (count c-fns) ", "
                          "{" (interpose (map c-fns (fn [[_ arity-var]] (str "&" arity-var))) ", ")
                          "}};\n"
                          "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]))))
        protos-var (sm/get-in-val [.modules file-name .values protocols-sym])]
    (c-code (.c-var protos-var)
            [(.init expr) (.c-var protos-var) " = " (.c-var expr) ";\n"]
            [] {} {})))

(def emit-main*
  (for [main-fn (comp (lookup-static-arity-info (FnValPtr 'main) 1)
                      (compilation-error "'main' function is missing"))
        modules (sm/get-in-val [.modules])
        protos (traverse (keys modules) gather-protocols)
        values (sm/get-in-val [.rt-init .exprs])]
    (write-strings ["\n#\n"
                    "\nint main (int argc, char **argv) {\n"
                    "maybeNothing = maybe((List *)0, (Value *)0, nothing);\n"
                    "maybeNothing->refs = -1;\n"
                    "outstream = stdout;\n"
                    "__atomic_store(&futuresQueue.input, &empty_list, __ATOMIC_RELAXED);\n"
                    "futuresQueue.output = empty_list;\n"
                    "pthread_mutex_init(&futuresQueue.mutex, NULL);\n"
                    "pthread_cond_init(&futuresQueue.notEmpty, NULL);\n"
                    "pthread_mutex_init(&shutDown.access, NULL);\n"
                    "startWorkers();\n"
                    (map protos (fn [proto]
                                  [(.init proto) (.c-var proto) "->refs = -1;\n"]))
                    (map values .init) "\n"
                    "#\n"
                    "  List *argList = malloc_list();\n"
                    "  argList->len = 0;\n"
                    "  argList->head = (Value *)0;\n"
                    "  argList->tail = (List *)0;\n"
                    "  List *tail = argList;\n"
                    "  for(int i = 0; i < argc; i++) {\n"
                    "     List *newTail = malloc_list();\n"
                    "     newTail->len = 0;\n"
                    "     newTail->tail = (List *)0;\n"
                    "     newTail->head = (Value *)0;\n"
                    "     tail->head = stringValue(argv[i]);\n"
                    "     tail->tail = newTail;\n"
                    "     tail = newTail;\n"
                    "     argList->len++;\n}\n"
                    "  argList->refs = -1;\n"
                    "Value *the_final_answer = " (.c-var main-fn)
                    "((List *)empty_list, (Value *)argList);\n\n"
                    "#ifdef CHECK_MEM_LEAK\n"
                    ;; (map (vals modules) (fn [module]
                    ;;                       (either (map (get-in module [.values symbols-sym])
                    ;;                                    (fn [expr]
                    ;;                                      (free-global (c-init (.c-var expr)
                    ;;                                                           [] [] {} {} "" 0))))
                    ;;                               "")))
                    ;; (map (vals modules) (fn [module]
                    ;;                       (either (map (get-in module [.values types-sym])
                    ;;                                    (fn [expr]
                    ;;                                      (free-global (c-init (.c-var expr)
                    ;;                                                           [] [] {} {} "" 0))))
                    ;;                               "")))
                    (map (vals modules) (fn [module]
                                          (either (map (get-in module [.values protocols-sym])
                                                       (fn [expr]
                                                         (free-global (c-init (.c-var expr)
                                                                              [] [] {} {} "" 0))))
                                                  "")))
                    (map values free-global) "\n"
                    "#\n"
                    "  cleanupMemory(the_final_answer, maybeNothing, argList);\n"
                    "  if (malloc_count - free_count != 0)\n"
                    "    return(1);\n"
                    "#endif\n"
                    "#\n"
                    "  return(0);\n};\n"])))

(defn get-proto-dispatch-sym [fn-sym num-args]
  (for [fn-var (lookup-sym fn-sym)
        arity-var (sm/get-in-val [.fns (.c-var fn-var) num-args])]
    (.c-var arity-var)))

(def ast-emitter (agent (maybe global-context)))

(defn update-context [context update]
  (assert (instance? Maybe context))
  (flat-map (flat-map context update) second))

(defn new-module [context module-name]
  (update-context context
                  (comp (sm/get-in-val [.modules module-name])
                        (for [protos-var (global-var "protos_")
                              _ (sm/assoc-in-val [.modules module-name]
                                                 (Module module-name
                                                         {protocols-sym (c-code protos-var [] [] {} {})}
                                                         {} core-type-nums {}))]
                          (write-strings ["Value *" protos-var " = (Value *)&emptyBMI;\n"]))
                        (compilation-error "Compilation error (Could not prepare new module"
                                           module-name ".)"))))

(defn emit-ast [context ast]
  (update-context context
                  (comp (for [emitted (emit-definition ast)
                              :let [emitted (map emitted (fn [expr]
                                                           (write-strings (.decl expr))
                                                           (.decl expr [])))]
                              _ (sm/update-in-val [.rt-init .exprs] (fn [exprs]
                                                                      (comp exprs emitted)))]
                          "")
                        (compilation-error "Could not emit code for expression at "
                                           (ast/file-name ast) (ast/line-number ast)))))

(defn emit-main [context]
  (update-context context
                  (comp emit-main*
                        (compilation-error "Compilation error (Could not emit 'main' function.)"))))


(def fixup-native-symbols*
  (apply* (sm/state-maybe (fn [& decl]
                            (write-strings decl)))
          (list (map (get-proto-dispatch-sym (rdr/tag 'type-name) 1)
                     (fn [arity-sym]
                       ["Value *(*type_name)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 1)
                     (fn [arity-sym]
                       ["Value *(*invoke0Args)(List *, Value *) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 2)
                     (fn [arity-sym]
                       ["Value *(*invoke1Arg)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'invoke) 3)
                     (fn [arity-sym]
                       ["Value *(*invoke2Args)(List *, Value *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag '=*) 2)
                     (fn [arity-sym]
                       ["Value *(*equalSTAR)(List *, Value *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'hash-seq) 2)
                     (fn [arity-sym]
                       ["Value *(*hashSeq)(List *, Value*, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'count) 1)
                     (fn [arity-sym]
                       ["Value *(*count)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'seq) 1)
                     (fn [arity-sym]
                       ["Value *(*seq)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'sha1) 1)
                     (fn [arity-sym]
                       ["Value *(*sha1)(List *, Value*) = " arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'dissoc*) 4)
                     (fn [arity-sym]
                       ["Value *(*dissoc)(List *, Value*, Value*, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (get-proto-dispatch-sym (rdr/tag 'has-field) 2)
                     (fn [arity-sym]
                       ["Value *(*hasField)(List *, Value*, Value*) = "
                        arity-sym ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'show) 1)
                     (fn [arity-ptr]
                       ["Value *(*showFn)(List *, Value *) = " arity-ptr ";\n"]))

                (map (lookup-core-fn-arity (rdr/tag 'fn-apply) 2)
                     (fn [arity-ptr]
                       ["Value *(*fn_apply)(List *, Value*, Value*) = " arity-ptr ";\n"]))
                )
          ))

(defn fixup-native-symbols [context]
  (update-context context
                  (comp fixup-native-symbols*
                        (compilation-error "Compilation error (Could not fixup native symbols.)"))))

(defn file-directory [src-file-name]
  (map (sys/realpath src-file-name)
       (fn [real-path]
         (let [[path-len] (reduce real-path [-1 0]
                                  (fn [[slash-pos c-pos] c]
                                    (let [c-pos (inc c-pos)]
                                      ((= c "/")
                                       [c-pos c-pos]
                                       [slash-pos c-pos]))))]
           (subs real-path 0 path-len)))))

(def compile-module)
(def module-compiler (agent {}))

(defprotocol ASTEmitter
  (send-to-emitter [ast]
    (send ast-emitter emit-ast ast))
  (add-namespace [ast root-dir proj-dir])
  (load-module [ast root-dir proj-dir]))

(extend-type ast/module-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [waiter (promise)
          file-path (str root-dir (.file-path ast))]
      (send module-compiler compile-module file-path waiter root-dir proj-dir)
      [waiter file-path])))

(def clone-repo)
(def repo-cloner (agent {}))

(defn clone-repo* [ast root-dir proj-dir]
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        branch (either (or (get opts 'tag)
                           (get opts 'branch))
                       "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)]
    (either (and (sys/sh-proc "/usr/bin/git" (list "clone" "--branch" branch
                                                   (.repo ast) dep-path))
                 (or (map (get opts 'sha)
                          (fn [sha]
                            ;; working with the OS. Give it a chance to catch up
                            (sys/sleep 3)
                            (or (sys/sh-proc "/usr/bin/git"
                                             (list "-C" dep-path "checkout" sha))
                                (do
                                  (print-err "Failed checkout of" sha "in" dep-path)
                                  (abort)))
                            (sys/sleep 3)))
                     (maybe (sys/sleep 3))))
            (do
              (print-err "Cloning git dependency" (.repo ast) "failed.")
              (abort)))
    dep-path))

(defn clone-repo [cloned ast waiter root-dir proj-dir]
  (assert (instance? HashMap cloned))
  (let [opts (.args ast)
        checkout (either (or (get opts 'tag)
                             (get opts 'sha)
                             (get opts 'branch))
                         "master")
        dep-path (str proj-dir "dependencies/git/" (.repo ast) "/" checkout)
        module-path (str dep-path "/" (.file ast))]
    (either (or (map (sys/access module-path) (fn [_]
                                                (deliver waiter dep-path)
                                                cloned))
                (and (sys/access dep-path)
                     (do
                       (print-err "Dependency file" (.file ast)
                                  "missing from existing copy of repository"
                                  (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
                       (abort)))
                (update cloned dep-path (fn [cloning-future]
                                          (map cloning-future (partial deliver waiter))
                                          cloning-future)))
            (assoc cloned dep-path (future (fn []
                                             (let [dep-path (clone-repo* ast root-dir proj-dir)]
                                               (deliver waiter dep-path)
                                               dep-path)))))))

(extend-type ast/git-dep-ast
  ASTEmitter
  (load-module [ast root-dir proj-dir]
    (let [file (.file ast)]
      (or (-> file
              seq
              (filter (partial = "/"))
              empty?)
          (do
            (print-err "For git dependencies,"
                       "files may only be imported from root of repository,"
                       file "is invalid.")
            (abort)))

      (let [clone-waiter (promise)
            dep-path (do
                       (send repo-cloner clone-repo ast clone-waiter root-dir proj-dir)
                       (extract clone-waiter))
            waiter (promise)
            module-path (str dep-path "/" file)]
        (or (sys/access module-path)
            (do
              (print-err "Dependency file" file "missing from cloned repository"
                         (.repo ast) ":" (ast/file-name ast) (ast/line-number ast))
              (abort)))
        (send module-compiler compile-module module-path waiter (str dep-path "/") proj-dir)
        [waiter module-path]))))

(extend-type ast/add-ns-ast
  ASTEmitter
  (add-namespace [ast root-dir proj-dir]
    (let [[waiter mod-file-name] (load-module (.mod ast) root-dir proj-dir)]
      (send ast-emitter
            (fn [context]
              (update-context context
                              (sm/assoc-in-val [.namespaces (ast/file-name ast) (.ns-sym ast)]
                                               mod-file-name))))
      waiter)))

(def analyze-forms
  (rd/parser (grmr/none-or-more
              (grmr/any
               (grmr/apply-fn (fn [modules]
                                (map modules extract))
                              (grmr/one-or-more
                               (grmr/apply-fn add-namespace
                                              rdr/read-add-ns
                                              (grmr/get-value 'root-directory)
                                              (grmr/get-value 'project-directory))))
               (grmr/apply-fn send-to-emitter
                              rdr/top-level)))))

(defn gather-symbols [context file-name]
  (update-context context
                  (comp (for [
                              ;; symbols (sm/get-in-val [.modules file-name .values])
                              ;; expr (encode symbols "symbols_")
                              ;; _ (sm/assoc-in-val [.modules file-name .values symbols-sym] expr)
                              protos (sm/get-in-val [.modules 'core .values protocols-sym])
                              _ (sm/assoc-in-val [.modules 'core .values (rdr/tag 'protocols)] protos)]
                          '_)
                        (sm/state-maybe '_))))

(defn gather-types [context file-name]
  (update-context context
                  (comp (for [types (sm/get-in-val [.modules file-name .types])
                              expr (encode types "types_")
                              _ (sm/assoc-in-val [.modules file-name .values types-sym] expr)]
                          '_)
                        (sm/state-maybe '_))))

(defn encode-ns [file-name]
  (send ast-emitter (fn [context]
                      (update-context context
                                      (for [
                                            ;; symbols (sm/get-in-val [.modules file-name .values
                                            ;;                         symbols-sym])
                                            ;; _ (sm/assoc-in-val [.modules file-name .values
                                            ;;                     (rdr/tag file-name)]
                                            ;;                    symbols)
                                            ;; types (sm/get-in-val [.modules file-name .values
                                            ;;                       types-sym])
                                            ;; _ (sm/assoc-in-val [.modules file-name .values
                                            ;;                     (rdr/tag file-name)]
                                            ;;                    types)
                                            protos (sm/get-in-val [.modules file-name .values protocols-sym])
                                            _ (sm/assoc-in-val [.modules file-name .values (rdr/tag 'protocols)]
                                                               protos)
                                            _ (sm/update-in-val
                                               [.rt-init .exprs]
                                               (fn [exprs]
                                                 (comp exprs 
                                                       [(c-code ""
                                                                [;; (.c-var symbols) "->refs = -1;\n"
                                                                 ;; (.c-var types) "->refs = -1;\n"
                                                                 (.c-var protos) "->refs = -1;\n"]
                                                                [] {} {})])))]
                                        '_)))))

(defn load-core [modules]
  (either (or (and (get modules 'core)
                   (maybe modules))
              (for [file-in (fio/file-in path-to-core)
                    :let [_ (send ast-emitter new-module 'core)]
                    _ (analyze-forms {'file-name 'core
                                      'line-number 1
                                      'project-directory ""
                                      'root-directory ""}
                                     (lazy-list file-in))]
                (do
                  (send ast-emitter gather-symbols 'core)
                  ;; (send ast-emitter gather-types 'core)
                  (assoc modules 'core 'loaded))))
          (do
            (print-err "Could not compile Toccata core."
                       "Is the $TOCCATA_DIR environment variable set correctly?")
            (abort))))

(defn compile-module [loaded-modules file-name waiter-prom root-dir proj-dir]
  (assert (instance? HashMap loaded-modules))
  (let [loaded-modules (load-core loaded-modules)]
    (either (map (get loaded-modules file-name)
                 (fn [loaded]
                   (map loaded (fn [_]
                                 (deliver waiter-prom file-name)))
                   loaded-modules))
            (assoc loaded-modules file-name
                   (future (fn []
                             (either (flat-map (fio/file-in file-name)
                                               (fn [file-in]
                                                 (send ast-emitter new-module file-name)
                                                 (analyze-forms {'file-name file-name
                                                                 'root-directory root-dir
                                                                 'project-directory proj-dir
                                                                 'line-number 1}
                                                                (lazy-list file-in))))
                                     (do
                                       (print-err "Could not compile" file-name)
                                       (abort)))
                             (deliver waiter-prom file-name)))))))


(main [params]
  (let [[_ file-name] params
        waiter (promise)]
    (or (map (file-directory file-name)
             (fn [root-dir]
               (write-strings ["\n#define _XOPEN_SOURCE 600"
                               "\n#include <stdlib.h>"
                               "\n#include \"core.h\"\n"])
               (send module-compiler compile-module file-name waiter root-dir root-dir)))
        (do
          (print-err "Could not find " (str "'" file-name "'"))
          (abort)))
    (extract waiter)
    (send ast-emitter emit-main)
    (send ast-emitter fixup-native-symbols)
    (send ast-emitter (fn [ctxt]
                        (map (get-in ctxt ['_ .constants .other])
                             (fn [counts]
                               (apply print-err "\n" (interpose (map (seq counts)
                                                                     (fn [[k v]]
                                                                       (str k ": " v)))
                                                                "\n"))))))
    ;; wait for agents to clear their queues
    (let [waiter (promise)]
      (send ast-emitter (fn [_]
                          (send string-writer (fn [_]
                                                (deliver waiter 'x)))))
      (extract waiter))))
