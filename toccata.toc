
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, NumberType};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, StringType};"))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang              ;; language to compile to
                        fn-context               ;; context for the fn currently being compiled
                        modules                  ;; info for each module compiled
                        numbers
                        strings
                        ])

;; information that must be tracked for each module
(deftype Module [path values]
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [syms]
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn new-module [path]
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {}))))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))

;; useful for debugging the compiler
(def sm-space (sm/state-maybe ""))
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (map (apply debug msg)
       (fn [_] (abort))))

;; information about a compiled expression or expressions
(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (str type-num) ", "
          (str (count init)) " ," (str refs-map) ">")))

(defprotocol Emitter
  ;; All AST nodes will implement this fn
  (emit [_])

  ;; All AST nodes that can be in the value expression of a definition implement this
  (emit-defined-value [_ defined-sym])

  ;; All top-level AST nodes implement this
  (emit-definition [_]))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(defn genlocal [pre]
  (for [sym-count (map (sm/get-in-val [.fn-context .syms]) count)]
    (symbol (str pre sym-count))))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (.file-name sym) .values sym]))

(defn lookup-sym [sym]
  (comp (sm/get-in-val [.fn-context .syms sym])
        (lookup-module-def sym)))

(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))
  (emit-defined-value [_ _]
    (sm/state-maybe []))
  (emit-definition  [_]
    (sm/state-maybe [])))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-val .strings) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.strings str-val]
                             (c-code str-ptr [] [] StringType {}))]
      (c-code str-ptr
              []
              ["struct {\nint64_t type;\n int32_t refs;\n   int64_t len;\n   Integer *hash;\n   char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.strings str-val])
          (make-static-string str-val)))
  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [value])))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-val .numbers) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-code num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Number
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.numbers num])
          (make-static-num num)))
  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [value])))


(extend-type rdr/tagged-symbol
  Emitter
  (emit [sym]
    (lookup-sym sym)))


(defn get-type [type-symbol]
  (sm/state-maybe 0))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))
  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (lookup-module-def defined-sym)
                      (global-var "var_"))
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] c-var)]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})]))
  (emit-definition [ast]
    (map (emit ast) vector)))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-defined-value ast defined-sym)))]
        (apply comp evalled)))))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [exprs (traverse (.body ast) sm/state-maybe emit)]
      [(c-code "" (comp ["\nint main (int argc, char **argv) {\n"]
                         (apply comp (map exprs .init))
                         ["\nreturn(0);\n}\n"])
                [] 0 {})])))

(def global-context (GlobalContext 'C
                                   (FunctionArityContext {})
                                   {}                       ;; map for module info
                                   {}                       ;; map for const numbers
                                   {}                       ;; map for const strings
                                   ))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(main [args]
      (let [[_ file-name] args]
        (for [in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (for [_ (new-module "")
                                    emitted (traverse asts sm/state-maybe emit-definition)
                                    mod (sm/get-in-val [.modules ""])
                                    _ (debug 'mod mod 'vals (.values mod))]
                                emitted)]
              [emitted-exprs] (emit-code global-context)]
          (map (apply comp emitted-exprs)
               (fn [emitted]
                 (write-str (.decl emitted))
                 (write-str (.init emitted)))))))
