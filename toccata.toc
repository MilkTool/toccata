
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def UnknownType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, NumberType};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, StringType};"))
(def FnArityType (inline-C Number "(Value *)&(Number){NumberType, -1, FnArityType};"))
(def FunctionType (inline-C Number "(Value *)&(Number){NumberType, -1, FunctionType};"))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang              ;; language to compile to
                        fn-context               ;; context for the fn currently being compiled
                        modules                  ;; info for each module compiled
                        numbers                  ;; static numbers
                        strings                  ;; static strings
                        fns                      ;; static functions
                        ])

;; information that must be tracked for each module
(deftype Module [path values]
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [syms]
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn new-module [path]
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {}))))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))

;; useful for debugging the compiler
(def sm-space (sm/state-maybe ""))
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (map (apply debug msg)
       (fn [_] (abort))))

;; information about a compiled expression or expressions
(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (str type-num) ", "
          (str (count init)) " ," (str refs-map) ">"))

  Composition
  (zero [_] (c-code "" [] [] UnknownType {}))
  (comp* [c cs]
    (let [[c & cs] (reverse (cons c cs))]
      (reduce cs c
              (fn [result expr]
                (c-code (.c-var result)
                        (list (.init expr) (.init result))
                        (list (.decl expr) (.decl result))
                        (.type-num result)
                        (extract (or (and (empty? (.init expr))
                                          (maybe (merge-with + (.refs-map result) (.refs-map expr))))
                                     (maybe (assoc (merge-with + (.refs-map expr) (.refs-map result))
                                                   (.c-var expr) 0))))))))))

(def empty-c-code (c-code "" [] [] UnknownType {}))


(defprotocol Emitter
  ;; All AST nodes will implement this fn
  (emit [_])

  ;; All AST nodes produce a value that can be assigned to a symbol
  (emit-defined-value [ast defined-sym])

  ;; All top-level AST nodes implement this
  (emit-definition [_]))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(defn genlocal [pre]
  (for [sym-count (map (sm/get-in-val [.fn-context .syms]) count)]
    (symbol (str pre sym-count))))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (.file-name sym) .values sym]))

(defn lookup-sym [sym]
  (comp (sm/get-in-val [.fn-context .syms sym])
        (lookup-module-def sym)))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn new-static-arity [fn-var num-params arity-var type-num]
  (sm/assoc-in-val [.fns fn-var num-params]
                   (c-code arity-var [] [] type-num {})))


(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))
  (emit-defined-value [_ _]
    (sm/state-maybe []))
  (emit-definition  [_]
    (sm/state-maybe [])))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-val .strings) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.strings str-val]
                             (c-code str-ptr [] [] StringType {}))]
      (c-code str-ptr
              []
              ["struct {\nint64_t type;\n int32_t refs;\n   int64_t len;\n   Integer *hash;\n   char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.strings str-val])
          (make-static-string str-val)))
  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [value])))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-val .numbers) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-code num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Number
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.numbers num])
          (make-static-num num)))
  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [value])))


(extend-type rdr/tagged-symbol
  Emitter
  (emit [sym]
    (lookup-sym sym)))


(defn get-type [type-symbol]
  (sm/state-maybe 0))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))
  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (lookup-module-def defined-sym)
                      (global-var "var_"))
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] c-var)]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})]))
  (emit-definition [ast]
    (map (emit ast) vector)))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-defined-value ast defined-sym)))]
        (apply comp evalled)))))


;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        result-sym (genlocal "rslt")]
    (c-code result-sym
            ["\n// static-fixed\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq arg-vars)) ", ") ");\n"]
            [] (.type-num arity-info) {})))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [target (emit (.call-target ast))
            args (emit (.args ast))
            call-site (call-static-fixed target (map args .c-var) file-name line-number)]
        (comp* target (comp args [call-site]))))))


(defprotocol GenBinding
  (gen-binding-syms [param]
    ;; generate bindings for symbols and tagged-symbols
    (for [param-var (genlocal "arg")
          :let [var-info (c-code param-var ["//" (str param) " " (str param-var) "\n"] []
                                 UnknownType {param-var 1})]
          _ (sm/assoc-in-val [.fn-context .syms param] var-info)]
      var-info)))

(deftype StaticArity [arity-fn-var param-count var-info])

(defn reset-fn-context [arity-fn-sym num-params]
  (for [curr-fn-context (sm/get-val .fn-context)
        _ (sm/set-val .fn-context (FunctionArityContext {}))]
    curr-fn-context))

;; probably the most complex function in the whole compiler
(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (let [params (.fixed (.params ast))
          param-count (count params)]
      (for [arity-fn-var (global-var "arityImpl_")
            arity-var (global-var "fnArity_")
            fn-context (reset-fn-context arity-fn-var param-count)
            param-syms (traverse params sm/state-maybe gen-binding-syms)
            body-exprs (emit (.body ast))
            _ (sm/set-val .fn-context fn-context)]
        (let [param-decls (map param-syms (fn [param]
                                            (str "Value *" (.c-var param))))
              fn-decl (cons (c-code ""
                                    ["Value *" arity-fn-var "("
                                     (interpose (cons "List *closures" param-decls) ", ")
                                     ") {\n"]
                                    [] FnArityType {})
                            param-syms)
              fn-expr (comp fn-decl body-exprs)
              fn-body [(map fn-expr .decl)
                       (map fn-expr .init)]
              return-result "\n};\n\n"]
          (StaticArity arity-fn-var param-count
                       (c-code (str "&" arity-var) []
                               [fn-body
                                return-result "FnArity " arity-var " = {FnArityType, -1, " param-count
                                ", (List *)0, " "0" ", " arity-fn-var "};\n"]
                               FnArityType {})))))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (let [fn-name (.fn-sym ast)]
      (for [struct-var (global-var "fnStruct")
            fn-var (global-var "fn")
            arities-info (emit (.arities ast))
            emitted-arities (traverse arities-info sm/state-maybe
                                      (fn [static-arity]
                                        (for [_ (new-static-arity fn-var
                                                                  (.param-count static-arity)
                                                                  (.arity-fn-var static-arity)
                                                                  (.type-num (.var-info static-arity)))]
                                          (.var-info static-arity))))]
        (let [arity-count (count emitted-arities)
              arity-vars (map emitted-arities .c-var)]
          (c-code fn-var
                  []
                  ["\n// --------- " fn-name " --------------\n"
                   "Value *" fn-var ";\n"
                   (map emitted-arities .decl)
                   "\n// --------- " fn-name " declaration --------------\n"
                   "Function " struct-var " = {FunctionType, -1, \""
                   fn-name "\", " arity-count ", "
                   "{" (to-str (interpose arity-vars ", ")) "}};\n"
                   "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
                  FunctionType {})))))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code (.c-var value) [] [] (.type-num value) (.refs-map value)))]
      [value])))


(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [exprs (traverse (.body ast) sm/state-maybe emit)]
      [(c-code "" (comp ["\nint main (int argc, char **argv) {\n"]
                         (apply comp (map exprs .init))
                         ["\nreturn(0);\n}\n"])
                (apply comp (map exprs .decl)) 0 {})])))

(def global-context (GlobalContext 'C
                                   (FunctionArityContext {})
                                   {}                       ;; map for module info
                                   {}                       ;; map for const numbers
                                   {}                       ;; map for const strings
                                   {}                       ;; map for static fns
                                   ))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(main [params]
      (let [[_ file-name] params]
        (println)
        (for [in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (for [_ (new-module "")
                                    emitted (traverse asts sm/state-maybe emit-definition)
                                    ;; mod (sm/get-in-val [.modules ""])
                                    ;; _ (debug 'mod mod 'vals (.values mod))
                                    ]
                                emitted)]
              [emitted-exprs] (emit-code global-context)]
          (map (apply comp emitted-exprs)
               (fn [emitted]
                 (write-str (.decl emitted))
                 (write-str (.init emitted)))))))
