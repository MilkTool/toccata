
;; The specification of Toccata's syntax
(add-ns rdr (module "reader.toc"))

;; define the AST node types
(add-ns ast (module "ast.toc"))

(add-ns grmr (module "grammar.toc"))
(add-ns fio (module "file-io.toc"))
(add-ns rd (module "recursive-descent.toc"))
(add-ns sm (module "state-maybe.toc"))

(def UnknownType (inline-C Number "(Value *)&(Number){NumberType, -1, 0};"))
(def IntegerType (inline-C Number "(Value *)&(Number){NumberType, -1, NumberType};"))
(def StringType (inline-C Number "(Value *)&(Number){NumberType, -1, StringType};"))
(def SubStringType (inline-C Number "(Value *)&(Number){NumberType, -1, SubStringType};"))
(def FnArityType (inline-C Number "(Value *)&(Number){NumberType, -1, FnArityType};"))
(def FunctionType (inline-C Number "(Value *)&(Number){NumberType, -1, FunctionType};"))
(def ListType (inline-C Number "(Value *)&(Number){NumberType, -1, ListType};"))
(def MaybeType (inline-C Number "(Value *)&(Number){NumberType, -1, MaybeType};"))
(def VectorType (inline-C Number "(Value *)&(Number){NumberType, -1, VectorType};"))

;; There's a bunch of information to keep track of while compiling
(deftype GlobalContext [target-lang           ;; language to compile to
                        fn-context            ;; context for the fn currently being compiled
                        init-fn-context       ;; context for the initialization code
                        modules               ;; info for each module compiled
                        numbers               ;; static numbers
                        strings               ;; static strings
                        fns                   ;; static functions
                        ])

;; information that must be tracked for each module
(deftype Module [path values]
  Stringable
  (string-list [_] (list "<Module '" path "'>")))

;; Every function arity has some information that's local to it
(deftype FunctionArityContext [var-count syms]
  Stringable
  (string-list [_]
    (list "<FunctionArityContext " (str (count syms)) ">")))

(defn reset-fn-context
  ([] (reset-fn-context (FunctionArityContext 0 {})))
  ([new-context]
   (for [curr-fn-context (sm/get-val .fn-context)
         _ (sm/set-val .fn-context new-context)]
     curr-fn-context)))

(defn new-module [path]
  (comp (sm/get-in-val [.modules path])
        (sm/assoc-in-val [.modules path]
                         (Module path {}))))

;; generate symbols that are available globally inside the 'state-maybe' container
(def global-var (sm/lift gensym))

;; create a function that will turn raw text into a list of AST's
;; using a recursive descent parser
(def analyze-forms (rd/parser (grmr/none-or-more rdr/top-level)))

;; useful for debugging the compiler
(def sm-space (sm/state-maybe ""))
(defn debug [& args]
  (map sm-space (fn [_] (apply print-err args))))

;; for when a fatal error occurs
(defn compilation-error [& msg]
  (map (apply debug msg)
       (fn [_] (abort))))

;; information about a compiled expression or expressions
(deftype c-code [c-var init decl type-num refs-map]
  Stringable
  (string-list [_]
    (list "<C-Code " (str c-var) ", " (str type-num) ", "
          (str (count init)) " ," (str refs-map) ">"))

  Composition
  (zero [_] (c-code "" [] [] UnknownType {}))
  (comp* [c cs]
    (let [[c & cs] (reverse (cons c cs))]
      (reduce cs c
              (fn [result expr]
                (c-code (.c-var result)
                        (list (.init expr) (.init result))
                        (list (.decl expr) (.decl result))
                        (.type-num result)
                        (extract (or (and (empty? (.init expr))
                                          (maybe (merge-with + (.refs-map result) (.refs-map expr))))
                                     (maybe (assoc (merge-with + (.refs-map expr) (.refs-map result))
                                                   (.c-var expr) 0))))))))))

(def empty-c-code (c-code "" [] [] UnknownType {}))

(defn collapse-exprs [exprs]
  (let [[c & cs] (reverse (seq exprs))
        c (assoc-in c [.refs-map (.c-var c)] 1)
        cs (remove cs (fn [c] (and (empty? (.init c))
                                   (empty? (.decl c)))))]
    (reduce cs c
            (fn [result expr]
              (let [init (extract (or (and (or (= 'inline (.c-var result))
                                               (= "" (.c-var expr)))
                                           (maybe [(.init expr) (.init result)]))
                                      (and (empty? (.init expr))
                                           (maybe (.init result)))
                                      (for [ref (get (.refs-map result) (.c-var expr))
                                            :when (< 0 ref)]
                                        (list (.init expr)
                                              "\nincRef(" (.c-var expr) ", "
                                              (str (dec ref)) ");\n"
                                              (.init result)))
                                      (maybe (list (.init expr)
                                                   "\ndec_and_free(" (.c-var expr) ", 1);\n"
                                                   (.init result)))))]
                (c-code (.c-var result)
                        init
                        (comp (.decl expr) (.decl result))
                        (.type-num result)
                        (extract (or (and (empty? (.init expr))
                                          (maybe (merge-with + (.refs-map expr)
                                                             (.refs-map result))))
                                     (maybe (assoc (merge-with + (.refs-map expr)
                                                               (.refs-map result))
                                                   (.c-var expr) 0))))))))))



(defprotocol Emitter
  ;; All AST nodes will implement this fn
  (emit [_])

  ;; All AST nodes produce a value that can be assigned to a symbol
  (emit-defined-value [ast defined-sym])

  ;; All top-level AST nodes implement this
  (emit-definition [_]))

(extend-type List
  Emitter
  (emit [asts]
    (traverse asts sm/state-maybe emit)))

(defn genlocal [pre]
  (for [sym-count (sm/get-in-val [.fn-context .var-count])
        _ (sm/assoc-in-val [.fn-context .var-count] (inc sym-count))]
    (symbol (str pre sym-count))))

(defn lookup-module-def [sym]
  (sm/get-in-val [.modules (.file-name sym) .values sym]))

(defn lookup-sym [sym]
  (comp (sm/get-in-val [.fn-context .syms sym])
        (lookup-module-def sym)
        (compilation-error "Undefined symbol" (str "'" sym "'") "at"
                           (str (ast/file-name sym) ":")
                           (ast/line-number sym))))

;; we cache all the info about static function arities to optimize call sites
(defn lookup-static-arity [fn-var num-params]
  (sm/get-in-val [.fns fn-var num-params]))

(defn new-static-arity [fn-var num-params arity-var type-num]
  (sm/assoc-in-val [.fns fn-var num-params]
                   (c-code arity-var [] [] type-num {})))


(extend-type ast/block-comment-ast
  Emitter
  (emit [ast]
    (sm/state-maybe (c-code "" (comp ["\n"]
                                     (map (.lines ast) (fn [line]
                                                         (str "//" line "\n"))))
                            [] 0 {})))
  (emit-defined-value [_ _]
    (sm/state-maybe []))
  (emit-definition  [_]
    (sm/state-maybe [])))


(defn make-static-string [str-val]
  (let [str-len (count str-val)]
    (for [str-idx (map (sm/get-val .strings) count)
          :let [str-sym (str "str" str-idx)
                str-ptr (str "strPtr" str-idx)]
          _ (sm/assoc-in-val [.strings str-val]
                             (c-code str-ptr [] [] StringType {}))]
      (c-code str-ptr
              []
              ["struct {\nint64_t type;\n int32_t refs;\n   int64_t len;\n   Integer *hash;\n   char buffer["
               (inc str-len)
               "];\n} " str-sym " = {StringType, -1, "
               str-len ", 0, \"" (escape-chars str-val) "\"};\n"
               "Value *" str-ptr " = (Value *)&" str-sym ";\n"]
              StringType {}))))

(extend-type String
  Emitter
  (emit [str-val]
    (comp (sm/get-in-val [.strings str-val])
          (make-static-string str-val)))

  (emit-defined-value [str-val defined-sym]
    (for [value (emit str-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code (.c-var value) [] [] (.type-num value) {}))]
      [(assoc value .c-var "")])))


(defn make-static-num [num]
  (for [num-idx (map (sm/get-val .numbers) count)
        :let [num-sym (str "num" num-idx)
              num-ptr (str "numPtr" num-idx)]
        _ (sm/assoc-in-val [.numbers num]
                           (c-code num-ptr [] [] IntegerType {}))]
    (c-code num-ptr
            []
            ["Integer " num-sym " = {IntegerType, -1, " num "};\n"
             "Value *" num-ptr " = (Value *)&" num-sym ";\n"]
            IntegerType {})))

(extend-type Number
  Emitter
  (emit [num]
    (comp (sm/get-in-val [.numbers num])
          (make-static-num num)))
  (emit-defined-value [num defined-sym]
    (for [value (emit num)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] (.c-var value))]
      [(assoc value .c-var "")])))


(extend-type rdr/tagged-symbol
  Emitter
  (emit [sym]
    (lookup-sym sym))

  (emit-defined-value [sym defined-sym]
    (for [value (lookup-sym sym)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] value)]
      [(assoc value .c-var "")])))


(defn get-type [type-symbol]
  (sm/state-maybe 0))

(extend-type ast/inline-ast
  Emitter
  (emit [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [(.txt ast)] [] type-num {})))

  (emit-defined-value [ast defined-sym]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))
          c-var (comp (lookup-module-def defined-sym)
                      (global-var "var"))
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym] c-var)]
      [(c-code "" [] ["Value *" c-var " = " (.txt ast) ";\n"] type-num {})]))

  (emit-definition [ast]
    (for [target-lang (sm/get-val .target-lang)
          :when (= (.lang ast) target-lang)
          type-num (get-type (.result-type ast))]
      (c-code "" [] [(.txt ast)] type-num {}))))


(extend-type ast/definition-ast
  Emitter
  (emit-definition [ast]
    (let [defined-sym (.sym ast)]
      (for [evalled (traverse (.value ast) sm/state-maybe
                              (fn [ast]
                                (emit-defined-value ast defined-sym)))]
        (flatten evalled)))))


(defn call-vector [target args]
  (for [_ (sm/when (= target 'vector))
        vect-sym (genlocal "newVect")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-code result-sym
                               ["\n// call-vector\n// #line " (str (ast/line-number target)) " " "\""
                                (ast/file-name target) "\"\n"
                                "Vector *" vect-sym " = empty_vect;\n"
                                (map args
                                     (fn [arg]
                                       (let [arg-sym (.c-var arg)]
                                         [vect-sym " = mutateVectConj(" vect-sym ", " arg-sym ");\n"])))
                                "Value *" result-sym " = (Value *)" vect-sym ";\n"]
                               [] VectorType {})]))))

(defn call-list [target args]
  (for [_ (sm/when (= target 'list))
        list-sym (genlocal "newList")
        result-sym (genlocal "rslt")]
    (apply comp (comp args
                      [(c-code result-sym
                                ["\n// call-list\n// #line " (str (ast/line-number target)) " " "\""
                                 (ast/file-name target) "\"\n"
                                 "List *" list-sym " = empty_list;\n"
                                 (map (reverse args)
                                      (fn [arg]
                                        (let [arg-sym (.c-var arg)]
                                          [list-sym " = listCons(" "(Value *)" arg-sym ", " list-sym ");\n"])))
                                 "Value *" result-sym " = (Value *)" list-sym ";\n"]
                                [] ListType {})]))))

;; optimize calls to static, fixed arity, functions
(defn call-static-fixed [target arg-vars file-name line-number]
  (for [arity-info (lookup-static-arity (.c-var target) (count arg-vars))
        result-sym (genlocal "rslt")]
    (c-code result-sym
            ["\n// static-fixed\n// #line " (str line-number) " " "\"" file-name "\"\n"
             "Value *" result-sym " = " (.c-var arity-info) "("
             (interpose (cons "empty_list" (seq arg-vars)) ", ") ");\n"]
            [] (.type-num arity-info) {})))

(extend-type ast/call-ast
  Emitter
  (emit [ast]
    (let [file-name (ast/file-name ast)
          line-number (ast/line-number ast)]
      (for [args (emit (.args ast))
            call-site (comp (call-vector (.call-target ast) args)
                            (call-list (.call-target ast) args)
                            (for [target (emit (.call-target ast))
                                  call-site (call-static-fixed target (map args .c-var) file-name line-number)]
                              (comp* target (comp args [call-site]))))]
        call-site)))

  (emit-defined-value [fn-val defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit fn-val)
          var (global-var "var")
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code var [] [] (.type-num value) (.refs-map value)))]
      [(c-code var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(defprotocol Bindings
  (bind [binding])
  (bind [binding evalled])
  (gen-binding-syms [param]
    ;; generate bindings for symbols and tagged-symbols
    (for [param-var (genlocal "arg")
          :let [var-info (c-code param-var ["//" (str param) " " (str param-var) "\n"] []
                                 UnknownType {param-var 1})]
          _ (sm/assoc-in-val [.fn-context .syms param] var-info)]
      var-info)))

(extend-type rdr/tagged-symbol
  Bindings
  (bind [binding]
    (for [arg-var (genlocal "arg")
          :let [arg (c-code arg-var [] [] UnknownType {})]
          _ (sm/assoc-in-val [.fn-context .syms binding] arg)]
      [arg]))
  (bind [binding evalled]
    (for [_ (sm/assoc-in-val [.fn-context .syms binding]
                             (c-code (.c-var evalled) [] [] (.type-num evalled)
                                     {(.c-var evalled) 1}))]
      [evalled])))

(extend-type ast/binding-ast
  Emitter
  (emit [ast]
    (flat-map (emit (.val ast))
              (partial bind (.binding ast)))))

(defn unpack-arg-list* [list-sym arg-syms file-name line-num]
  (comp (sm/when (for [arg (first arg-syms)
                       :when (= 1 (count arg-syms))]
                   [(c-code (.c-var arg)
                            ["Value *" (.c-var arg) " = (Value *)" list-sym ";\n" (.init arg)]
                            (.decl arg)
                            (.type-num arg)
                            (.refs-map arg))]))
        (for [arg-syms (traverse arg-syms sm/state-maybe
                                 (fn [arg]
                                   (comp (for [_ (sm/when (= "" (.c-var arg)))
                                               arg-sym (genlocal "arg")]
                                           (c-code arg-sym [""] [] UnknownType {}))
                                         (sm/state-maybe (assoc arg .init [""])))))
              ;; the [""] above signal that these expressions are where these values are created
              ;; It's an ugly hack that should be represented by a type.
              destructArgs (genlocal "destArgs_")]
          (let [len-sym (gensym "len_")]
            (cons (c-code ""
                          [(map arg-syms (fn [arg] ["Value *" (.c-var arg) ";\n"]))
                           "Value **" destructArgs "[" (count arg-syms) "] = {"
                           (interpose (map arg-syms (fn [arg] ["&" (.c-var arg)])) ", ") "};\n"
                           "destructValue(\"" file-name "\", \"" line-num "\", (Value *)" list-sym
                           ", " (count arg-syms) ", " destructArgs ");\n"]
                          [] UnknownType {list-sym 1})
                  arg-syms)))))

(extend-type ast/params-ast
  Bindings
  (gen-binding-syms [params]
    (map (traverse (.fixed params) sm/state-maybe bind) (fn [xs]
                                                          (seq (flatten xs)))))
  (bind [params]
    (for [arg-var (genlocal "arg")
          arg-syms (gen-binding-syms params)
          tail (gen-binding-syms 'tail)
          :let [arg-syms (comp arg-syms [tail])]
          args-list (unpack-arg-list* arg-var arg-syms
                                      (ast/file-name params)
                                      (ast/line-number params))]
      [(comp (apply comp args-list) (c-code arg-var [] [] UnknownType {}))]))
  (bind [params evalled]
    (for [arg-syms (gen-binding-syms params)
          tail (gen-binding-syms 'tail)
          :let [arg-syms (comp arg-syms [tail])]
          args-list (unpack-arg-list* (.c-var evalled) arg-syms
                                      (ast/file-name params)
                                      (ast/line-number params))
          evalled (sm/when (or (and (empty? (.init evalled))
                                    (maybe empty-c-code))
                               (maybe evalled)))]
      (cons evalled args-list))))

(extend-type ast/let-ast
  Emitter
  (emit [ast]
    (for [locals (sm/get-in-val [.fn-context .syms])
          bindings (emit (.bindings ast))
          body-exprs (emit (.body ast))
          _ (sm/get-in-val [.fn-context .syms] locals)]
      (collapse-exprs (comp (flatten bindings) body-exprs))))

  (emit-defined-value [ast defined-sym]
    (for [init-fn-context (sm/get-val .init-fn-context)
          fn-context (reset-fn-context init-fn-context)
          value (emit ast)
          var (global-var "var")
          init-fn-context (reset-fn-context fn-context)
          _ (sm/set-val .init-fn-context init-fn-context)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code var [] [] (.type-num value) (.refs-map value)))]
      [(c-code var [(.init value)
                    var " = " (.c-var value) ";\n"
                    var "->refs = -1;\n"]
               [(.decl value) "Value *" var ";\n"]
               (.type-num value) (.refs-map value))])))


(extend-type ast/and-ast
  Emitter
  (emit [ast]
    (for [and-result (genlocal "andRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce
                            evalled-clauses [[] total-refs]
                            (fn [[init remaining-refs] clause]
                              (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                  (partial < 0)))
                                    remaining-refs (reduce
                                                    clause-refs
                                                    remaining-refs
                                                    (fn [remaining-refs [k v]]
                                                      (extract
                                                       (or (update-in remaining-refs [k]
                                                                      (fn [remaining]
                                                                        (- remaining v)))
                                                           (maybe remaining-refs)))))]
                                [(conj (vec init)
                                       ["// and clause\n"
                                        (.init clause)
                                        and-result " = " (.c-var clause) ";\n"
                                        "if (isNothing(" and-result ")) {\n"
                                        (map (seq (filter-vals remaining-refs (partial < 0)))
                                             (fn [[c-sym remaining]]
                                               ["dec_and_free(" c-sym ", "
                                                remaining ");\n"]))
                                        "} "])
                                 remaining-refs])))]
        (c-code and-result
                ["Value *" and-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" and-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                Maybe total-refs)))))


(extend-type ast/or-ast
  Emitter
  (emit [ast]
    (for [or-result (genlocal "orRslt")
          evalled-clauses (traverse (.clauses ast) sm/state-maybe emit)]
      (let [clause-syms (set (map (remove evalled-clauses (fn [c]
                                                            (empty? (.init c)))) .c-var))
            total-refs (seq (apply merge-with + (map evalled-clauses .refs-map)))
            total-refs (remove-keys total-refs clause-syms)
            total-refs (filter-vals total-refs (partial < 0))
            [clause-inits] (reduce evalled-clauses [[] total-refs]
                                   (fn [[init remaining-refs] clause]
                                     (let [clause-refs (seq (filter-vals (.refs-map clause)
                                                                         (partial < 0)))
                                           remaining-refs (reduce
                                                           clause-refs
                                                           remaining-refs
                                                           (fn [remaining-refs [k v]]
                                                             (extract
                                                              (or
                                                               (update-in remaining-refs [k]
                                                                          (fn [remaining]
                                                                            (- remaining v)))
                                                               (maybe remaining-refs)))))]
                                       [(conj init
                                              ["// or clause\n"
                                               (.init clause)
                                               or-result " = " (.c-var clause) ";\n"
                                               "if (!isNothing(" or-result ")) {\n"
                                               (map (seq (filter-vals remaining-refs
                                                                      (partial < 0)))
                                                    (fn [[c-sym remaining]]
                                                      ["dec_and_free(" c-sym ", "
                                                       remaining ");\n"]))
                                               "} "])
                                        remaining-refs])))]
        (c-code or-result
                ["Value *" or-result ";\n"
                 (interpose clause-inits ["else {\n"
                                          "dec_and_free(" or-result ", 1);\n"])
                 (repeat (dec (count evalled-clauses))
                         "}\n")]
                (map evalled-clauses .decl)
                Maybe total-refs)))))


(deftype StaticArity [arity-fn-var param-count var-info])

(defn emit-static-arity [params body]
  (let [param-count (count params)]
    (for [arity-fn-var (global-var "arityImpl")
          arity-var (global-var "fnArity")
          fn-context (reset-fn-context)
          param-syms (gen-binding-syms params)
          body-exprs (emit body)
          _ (sm/set-val .fn-context fn-context)]
      (let [body (collapse-exprs body-exprs)
            param-decls (map param-syms (fn [param]
                                          (str "Value *" (.c-var param))))
            fn-expr (comp* (c-code "" []
                                   ["Value *" arity-fn-var "("
                                    (interpose (cons "List *closures" param-decls) ", ")
                                    ") {\n"]
                                   FnArityType {})
                           param-syms)
            fn-result (extract (or (and (= "" (.c-var body))
                                        (maybe "nothing"))
                                   (maybe (.c-var body))))]
        (StaticArity arity-fn-var param-count
                     (c-code (str "&" arity-var)
                             []
                             [(.decl body)
                              (.decl fn-expr)
                              (.init fn-expr)
                              (.init body)
                              "\nreturn(" fn-result ");\n};\n\n"
                              "FnArity " arity-var " = {FnArityType, -1, " param-count
                              ", (List *)0, " "0" ", " arity-fn-var "};\n"]
                             FnArityType {}))))))

(extend-type ast/main-ast
  Emitter
  (emit-definition [ast]
    (for [fn-arity (emit-static-arity (.params ast) (.body ast))
          _ (new-static-arity 'main 1 (.arity-fn-var fn-arity) IntegerType)]
      [(c-code "" [] (.decl (.var-info fn-arity)) 0 {})])))


(extend-type ast/fn-arity-ast
  Emitter
  (emit [ast]
    (emit-static-arity (.params ast) (.body ast))))


(extend-type ast/fn-ast
  Emitter
  (emit [ast]
    (let [fn-name (.fn-sym ast)]
      (for [struct-var (global-var "fnStruct")
            fn-var (global-var "fn")
            arities-info (emit (.arities ast))
            emitted-arities (traverse arities-info sm/state-maybe
                                      (fn [static-arity]
                                        (for [_ (new-static-arity fn-var
                                                                  (.param-count static-arity)
                                                                  (.arity-fn-var static-arity)
                                                                  (.type-num (.var-info static-arity)))]
                                          (.var-info static-arity))))]
        (let [arity-count (count emitted-arities)
              arity-vars (map emitted-arities .c-var)]
          (c-code fn-var []
                  ["\n// --------- " fn-name " --------------\n"
                   "Value *" fn-var ";\n"
                   (map emitted-arities .decl)
                   "\n// --------- " fn-name " declaration --------------\n"
                   "Function " struct-var " = {FunctionType, -1, \""
                   fn-name "\", " arity-count ", "
                   "{" (to-str (interpose arity-vars ", ")) "}};\n"
                   "Value *" fn-var " = (Value *)&" struct-var ";\n\n"]
                  FunctionType {})))))

  (emit-defined-value [fn-val defined-sym]
    (for [value (emit fn-val)
          _ (sm/assoc-in-val [.modules (.file-name defined-sym) .values defined-sym]
                             (c-code (.c-var value) [] [] (.type-num value) (.refs-map value)))]
      [(assoc value .c-var "")])))


(def global-context (GlobalContext 'C
                                   (FunctionArityContext 0 {})
                                   (FunctionArityContext 0 {})
                                   {}                       ;; map for module info
                                   {}                       ;; map for const numbers
                                   {}                       ;; map for const strings
                                   {}                       ;; map for static fns
                                   ))

(defprotocol StringWriter
  (write-str [x]
    (print x)))

(extend-type Vector
  StringWriter
  (write-str [v] (map v write-str)))

(extend-type List
  StringWriter
  (write-str [l] (map l write-str)))

(defn emit-main [vals]
  (for [main-fn (lookup-static-arity 'main 1)]
    [(c-code "" []
             ["\nint main (int argc, char **argv) {\n"
              "outstream = stdout;\n"
              (map vals .init) "\n"
              "Value *the_final_answer = " (.c-var main-fn) "((List *)0, (Value *)0);\n\n"
              "#ifdef CHECK_MEM_LEAK\n"
              (map vals (fn [val]
                          [(.c-var val) "->refs = 1;\n"
                           "freeGlobal(" (.c-var val) ");\n"]))
              "  dec_and_free(the_final_answer, 1);\n"
              "  freeAll();\n"
              "  if (malloc_count - free_count != 0)\n"
              "     return(1);\n"
              "#endif\n"
              "    return(0);\n};\n"]
             0 {})]))

(main [params]
      (let [[_ file-name] params]
        (println)
        (for [core-file (fio/file-in "core.toc")
              core-asts (analyze-forms (cache core-file))
              in-file (fio/file-in file-name)
              asts (analyze-forms (cache in-file))
              :let [emit-code (comp (for [_ (new-module "")
                                          emitted-core (traverse core-asts sm/state-maybe emit-definition)
                                          emitted (traverse asts sm/state-maybe emit-definition)
                                          main-fn (emit-main (remove (flatten emitted)
                                                                     (fn [val] (= "" (.c-var val)))))]
                                      (flatten (comp emitted-core emitted [main-fn])))
                                    (compilation-error "Could not compile"))]
              [emitted-exprs] (emit-code global-context)]
          (let [_ (write-str "\n#include \"core.h\"\n")]
            (map emitted-exprs
                 (fn [emitted]
                   (write-str (.decl emitted))))))))
